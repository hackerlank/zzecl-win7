(#Y(si::bytecodes nil nil (15 0 77 77 15 1 77 77 15 2 77 77 77 19 10 3 29) #A(t (4) (#1="SWANK" ("CL" "SWANK-BACKEND" "SWANK-MATCH" "SWANK-RPC") ("STARTUP-MULTIPROCESSING" "START-SERVER" "CREATE-SERVER" "STOP-SERVER" "RESTART-SERVER" "ED-IN-EMACS" "INSPECT-IN-EMACS" "PRINT-INDENTATION-LOSSAGE" "INVOKE-SLIME-DEBUGGER" "SWANK-DEBUGGER-HOOK" "EMACS-INSPECT" "*COMMUNICATION-STYLE*" "*DONT-CLOSE*" "*FASL-PATHNAME-FUNCTION*" "*LOG-EVENTS*" "*LOG-OUTPUT*" "*USE-DEDICATED-OUTPUT-STREAM*" "*DEDICATED-OUTPUT-STREAM-PORT*" "*CONFIGURE-EMACS-INDENTATION*" "*READTABLE-ALIST*" "*GLOBALLY-REDIRECT-IO*" "*GLOBAL-DEBUGGER*" "*SLDB-QUIT-RESTART*" "*BACKTRACE-PRINTER-BINDINGS*" "*DEFAULT-WORKER-THREAD-BINDINGS*" "*MACROEXPAND-PRINTER-BINDINGS*" "*SWANK-PPRINT-BINDINGS*" "*RECORD-REPL-RESULTS*" "*INSPECTOR-VERBOSE*" "DEBUG-ON-SWANK-ERROR" "BUFFER-FIRST-CHANGE" "FRAME-SOURCE-LOCATION" "GDB-INITIAL-COMMANDS" "RESTART-FRAME" "SLDB-STEP" "SLDB-BREAK" "SLDB-BREAK-ON-RETURN" "PROFILED-FUNCTIONS" "PROFILE-REPORT" "PROFILE-RESET" "UNPROFILE-ALL" "PROFILE-PACKAGE" "DEFAULT-DIRECTORY" "SET-DEFAULT-DIRECTORY" "QUIT-LISP" "EVAL-FOR-EMACS" "EVAL-IN-EMACS" "Y-OR-N-P-IN-EMACS" "*FIND-DEFINITIONS-RIGHT-TRIM*" "*FIND-DEFINITIONS-LEFT-TRIM*") si::dodefpackage)) #2=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/swank.lisp" 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) (#1# si::select-package)) #2# 2509) #Y(si::bytecodes nil nil (15 0 11 1 16 2 17 3 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::cl-package :cl find-package si::*make-constant variable "The COMMON-LISP package." si::set-documentation)) #2# 2532) #Y(si::bytecodes nil nil (15 0 11 1 16 2 17 3 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::keyword-package :keyword find-package si::*make-constant variable "The KEYWORD package." si::set-documentation)) #2# 2659) #Y(si::bytecodes nil nil (15 0 8 4005 17 1 15 0 15 2 15 3 19 3 4 1 0 73 29) #A(t (5) (swank::default-server-port si::*make-constant variable "The default TCP port for the server (when started manually)." si::set-documentation)) #2# 2742) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*swank-debug-p* si::*make-special boundp t variable "When true, print extra debugging information." si::set-documentation)) #2# 2850) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 30 77 19 1 3 45 4 30 1 12 15 6 32 0 12 9 0 13 1 19 4 13 10 1 43 1 43 1 52 0 1 0 73 29) #3=#A(t (14) (swank::*backtrace-pprint-dispatch-table* si::*make-special boundp copy-pprint-dispatch swank::table stream string *print-escape* :map ((#\" . "\\\"") (#\\ . "\\\\") (#\Newline . "\\n") (#\Return . "\\r")) swank::escape-string write-string #Y(swank::print-string nil nil (24 45 5 24 45 6 26 11 7 39 14 13 0 13 1 14 8 15 9 19 4 10 38 8 13 0 13 1 19 2 11 29) #3# #2# 2931) set-pprint-dispatch)) #2# 2931) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 23 15 3 15 4 15 5 15 6 15 7 15 8 15 9 11 10 7 2 6 7 52 0 15 0 15 11 15 12 19 3 13 1 0 73 29) #A(t (14) (swank::*backtrace-printer-bindings* si::*make-special boundp (*print-pretty* . t) (*print-readably*) (*print-level* . 4) (*print-length* . 6) (*print-lines* . 1) (*print-right-margin* . 200) *print-pprint-dispatch* swank::*backtrace-pprint-dispatch-table* variable "Pretter settings for printing backtraces." si::set-documentation)) #2# 3527) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*default-worker-thread-bindings* si::*make-special boundp variable "An alist to initialize dynamic variables in worker threads.  
The list has the form ((VAR . VALUE) ...).  Each variable VAR will be
bound to the corresponding VALUE." si::set-documentation)) #2# 3905) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #4=#A(t (15) (swank::call-with-bindings swank::alist swank::fun reverse swank::rlist car mapcar swank::vars cdr swank::vals #Y(swank::call-with-bindings nil nil (24 45 1 24 45 2 26 10 1 76 39 8 13 0 20 0 23 38 40 10 1 16 3 45 4 33 5 12 13 0 19 2 6 45 7 33 8 12 13 1 19 2 6 45 9 13 1 10 0 67 13 3 20 0 23 68 43 3 29) #4# #2# 4127) si::fset function "Call FUN with variables bound according to ALIST.
ALIST is a list of the form ((VAR . VAL) ...)." si::set-documentation)) #2# 4127) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 2 19 4 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #5=#A(t (15) (swank::with-bindings #:g2089 #:g2088 #:g2090 si::dm-too-few-arguments swank::alist swank::body swank::call-with-bindings lambda #Y(swank::with-bindings nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 45 6 15 7 13 1 15 8 77 10 0 7 3 6 3 73 29) #5# #2# 4490) t si::fset function "See `call-with-bindings'." si::set-documentation)) #2# 4490) #Y(si::bytecodes nil nil (15 0 1 15 12 14 16 9 3 19 4 17 15 0 15 18 15 19 19 3 20 1 0 73 29) #6=#A(t (21) (swank::defslimefun #:g2092 #:g2091 #:g2093 si::dm-too-few-arguments swank::name swank-backend::arglist rest progn defun eval-when (:compile-toplevel :load-toplevel :execute) export quote symbol-package #Y(swank::defslimefun nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 15 9 13 2 13 1 10 0 7 4 12 15 10 15 11 15 12 15 13 10 2 6 2 12 15 14 15 13 10 2 6 2 6 2 6 3 6 3 6 3 73 29) #6# #2# 4619) t si::fset function "A DEFUN for functions that Emacs can call by RPC." si::set-documentation)) #2# 4619) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 15 5 15 6 19 3 7 1 0 73 29) #7=#A(t (8) (swank::missing-arg "A required &KEY or &OPTIONAL argument was not supplied." error #Y(swank::missing-arg nil nil (26 15 1 19 1 2 29) #7# #2# 5133) si::fset function "A function that the compiler knows will never to return a value.
You can use (MISSING-ARG) as the initform for defstruct slots that
must always be supplied. This way the :TYPE slot option need not
include some arbitrary initial value like NIL." si::set-documentation)) #2# 5133) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 3 19 4 11 15 0 15 6 15 12 19 3 13 1 0 73 29) #8=#A(t (14) (swank::add-hook #:g2095 #:g2094 #:g2096 si::dm-too-few-arguments swank::place function si::dm-too-many-arguments pushnew #Y(swank::add-hook nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 13 0 10 1 6 3 73 29) #8# #2# 5480) t si::fset "Add FUNCTION to the list of values on PLACE." si::set-documentation)) #2# 5480) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 4 15 8 19 3 9 1 0 73 29) #9=#A(t (10) (swank::run-hook swank::functions swank::arguments si::%dolist-var function apply #Y(swank::run-hook nil nil (24 45 1 27 45 2 10 1 45 3 75 45 4 38 18 10 1 4 51 0 13 0 13 2 19 2 5 10 1 5 51 1 10 1 40 -20 75 73 43 2 29) #9# #2# 5776) si::fset "Call each of FUNCTIONS with ARGUMENTS." si::set-documentation)) #2# 5776) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*new-connection-hook* si::*make-special boundp variable "This hook is run each time a connection is established.
The connection structure is given as the argument.
Backend code should treat the connection structure as opaque." si::set-documentation)) #2# 5933) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*connection-closed-hook* si::*make-special boundp variable "This hook is run when a connection is closed.
The connection as passed as an argument.
Backend code should treat the connection structure as opaque." si::set-documentation)) #2# 6147) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*pre-reply-hook* si::*make-special boundp variable "Hook run (without arguments) immediately before replying to an RPC." si::set-documentation)) #2# 6344) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*after-init-hook* si::*make-special boundp variable "Hook run after user init files are loaded." si::set-documentation)) #2# 6450) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 15 5 77 15 6 9 12 77 77 15 7 19 15 8 15 0 19 1 60 78 56 15 9 1 58 12 19 2 59 1 0 73 29) #10=#A(t (61) (swank::connection swank::connection. ((swank::socket #11=(swank::missing-arg) :type t :read-only t) (swank::socket-io #12=(swank::missing-arg) :type stream :read-only t) (swank::dedicated-output nil :type #13=(or stream null)) (swank::user-input nil :type #14=(or stream null)) (swank::user-output nil :type #15=(or stream null)) (swank::user-io nil :type #16=(or stream null)) (swank::env #17='nil :type list) (swank::trace-output nil :type #18=(or stream null)) (swank::repl-results nil :type #19=(or stream null)) (swank::indentation-cache #20=(make-hash-table :test 'eq) :type hash-table) (swank::indentation-cache-packages #21='nil) (swank::communication-style nil :type #22=(member nil :spawn :sigio :fd-handler))) ((swank::socket #11# t t 0 nil) (swank::socket-io #12# stream t 1 nil) (swank::dedicated-output nil #13# nil 2 nil) (swank::user-input nil #14# nil 3 nil) (swank::user-output nil #15# nil 4 nil) (swank::user-io nil #16# nil 5 nil) (swank::env #17# list nil 6 nil) (swank::trace-output nil #18# nil 7 nil) (swank::repl-results nil #19# nil 8 nil) (swank::indentation-cache #20# hash-table nil 9 nil) (swank::indentation-cache-packages #21# t nil 10 nil) (swank::communication-style nil #22# nil 11 nil)) swank::copy-connection swank::print-connection (swank::%make-connection) swank::connection-p si::define-structure swank::%make-connection (nil :communication-style :indentation-cache-packages :indentation-cache :repl-results :trace-output :env :user-io :user-output :user-input :dedicated-output :socket-io :socket) swank::missing-arg #:socket #:socket-io #:dedicated-output #:user-input #:user-output #:user-io #:env #:trace-output #:repl-results :test eq make-hash-table #:indentation-cache #:indentation-cache-packages #:communication-style (member nil :spawn :sigio :fd-handler) typep (member nil :spawn :sigio :fd-handler) swank::communication-style si::structure-type-error hash-table swank::indentation-cache (or stream null) (or stream null) swank::repl-results (or stream null) (or stream null) swank::trace-output list swank::env (or stream null) (or stream null) swank::user-io (or stream null) (or stream null) swank::user-output (or stream null) (or stream null) swank::user-input (or stream null) (or stream null) swank::dedicated-output stream swank::socket-io 0 si::make-structure #Y(swank::%make-connection nil nil (28 10 22 40 5 19 0 11 12 46 12 22 40 5 19 0 11 12 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 2 77 46 19 22 40 2 77 46 20 22 40 9 14 21 15 22 19 2 23 12 46 24 22 40 2 77 46 25 22 40 2 77 46 26 13 0 15 27 19 2 28 76 39 12 13 0 15 29 15 0 15 30 19 4 31 13 2 15 32 19 2 28 76 39 12 13 2 15 32 15 0 15 33 19 4 31 13 3 15 34 19 2 28 76 39 12 13 3 15 35 15 0 15 36 19 4 31 13 4 15 37 19 2 28 76 39 12 13 4 15 38 15 0 15 39 19 4 31 13 5 15 40 19 2 28 76 39 12 13 5 15 40 15 0 15 41 19 4 31 13 6 15 42 19 2 28 76 39 12 13 6 15 43 15 0 15 44 19 4 31 13 7 15 45 19 2 28 76 39 12 13 7 15 46 15 0 15 47 19 4 31 13 8 15 48 19 2 28 76 39 12 13 8 15 49 15 0 15 50 19 4 31 13 9 15 51 19 2 28 76 39 12 13 9 15 52 15 0 15 53 19 4 31 13 10 15 54 19 2 28 76 39 12 13 10 15 54 15 0 15 55 19 4 31 15 56 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 13 57 29) #10# #2# 6532) si::fset find-class)) #2# 6532) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #23=#A(t (8) (swank::print-connection swank::conn stream swank::depth t si::print-unreadable-object-function #Y(swank::print-connection nil nil (24 45 1 24 45 2 24 45 3 26 13 2 13 1 14 4 14 4 77 19 5 5 29) #23# #2# 8569) si::fset)) #2# 8569) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 15 77 77 15 7 19 15 8 15 0 19 1 66 78 62 15 9 1 64 12 19 2 65 1 0 73 29) #24=#A(t (67) (swank::singlethreaded-connection swank::sconn. (swank::saved-sigint-handler (swank::event-queue #25='nil :type list) (swank::events-enqueued 0 :type fixnum)) (#26=(swank::socket (swank::missing-arg) t t 0 swank::connection.socket) #27=(swank::socket-io (swank::missing-arg) stream t 1 swank::connection.socket-io) #28=(swank::dedicated-output nil (or stream null) nil 2 swank::connection.dedicated-output) #29=(swank::user-input nil (or stream null) nil 3 swank::connection.user-input) #30=(swank::user-output nil (or stream null) nil 4 swank::connection.user-output) #31=(swank::user-io nil (or stream null) nil 5 swank::connection.user-io) #32=(swank::env 'nil list nil 6 swank::connection.env) #33=(swank::trace-output nil (or stream null) nil 7 swank::connection.trace-output) #34=(swank::repl-results nil (or stream null) nil 8 swank::connection.repl-results) #35=(swank::indentation-cache (make-hash-table :test 'eq) hash-table nil 9 swank::connection.indentation-cache) #36=(swank::indentation-cache-packages 'nil t nil 10 swank::connection.indentation-cache-packages) #37=(swank::communication-style nil (member nil :spawn :sigio :fd-handler) nil 11 swank::connection.communication-style) (swank::saved-sigint-handler nil t nil 12 nil) (swank::event-queue #25# list nil 13 nil) (swank::events-enqueued 0 fixnum nil 14 nil)) swank::copy-singlethreaded-connection swank::connection (swank::make-singlethreaded-connection) swank::singlethreaded-connection-p si::define-structure swank::make-singlethreaded-connection (nil :events-enqueued :event-queue :saved-sigint-handler :communication-style :indentation-cache-packages :indentation-cache :repl-results :trace-output :env :user-io :user-output :user-input :dedicated-output :socket-io :socket) swank::missing-arg #:socket #:socket-io #:dedicated-output #:user-input #:user-output #:user-io #:env #:trace-output #:repl-results :test eq make-hash-table #:indentation-cache #:indentation-cache-packages #:communication-style #:saved-sigint-handler #:event-queue #:events-enqueued fixnum typep swank::events-enqueued si::structure-type-error list swank::event-queue (member nil :spawn :sigio :fd-handler) (member nil :spawn :sigio :fd-handler) swank::communication-style hash-table swank::indentation-cache (or stream null) (or stream null) swank::repl-results (or stream null) (or stream null) swank::trace-output swank::env (or stream null) (or stream null) swank::user-io (or stream null) (or stream null) swank::user-output (or stream null) (or stream null) swank::user-input (or stream null) (or stream null) swank::dedicated-output stream swank::socket-io 0 si::make-structure #Y(swank::make-singlethreaded-connection nil nil (28 10 22 40 5 19 0 11 12 46 12 22 40 5 19 0 11 12 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 2 77 46 19 22 40 2 77 46 20 22 40 9 14 21 15 22 19 2 23 12 46 24 22 40 2 77 46 25 22 40 2 77 46 26 22 40 2 77 46 27 22 40 2 77 46 28 22 40 3 9 0 46 29 13 0 15 30 19 2 31 76 39 12 13 0 15 30 15 0 15 32 19 4 33 13 1 15 34 19 2 31 76 39 12 13 1 15 34 15 0 15 35 19 4 33 13 3 15 36 19 2 31 76 39 12 13 3 15 37 15 0 15 38 19 4 33 13 5 15 39 19 2 31 76 39 12 13 5 15 39 15 0 15 40 19 4 33 13 6 15 41 19 2 31 76 39 12 13 6 15 42 15 0 15 43 19 4 33 13 7 15 44 19 2 31 76 39 12 13 7 15 45 15 0 15 46 19 4 33 13 8 15 34 19 2 31 76 39 12 13 8 15 34 15 0 15 47 19 4 33 13 9 15 48 19 2 31 76 39 12 13 9 15 49 15 0 15 50 19 4 33 13 10 15 51 19 2 31 76 39 12 13 10 15 52 15 0 15 53 19 4 33 13 11 15 54 19 2 31 76 39 12 13 11 15 55 15 0 15 56 19 4 33 13 12 15 57 19 2 31 76 39 12 13 12 15 58 15 0 15 59 19 4 33 13 13 15 60 19 2 31 76 39 12 13 13 15 60 15 0 15 61 19 4 33 15 62 13 14 13 13 13 12 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 16 63 29) #24# #2# 8708) si::fset find-class)) #2# 8708) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 18 77 77 15 7 19 15 8 15 0 19 1 67 78 63 15 9 1 65 12 19 2 66 1 0 73 29) #38=#A(t (68) (swank::multithreaded-connection swank::mconn. (swank::reader-thread swank::control-thread swank::repl-thread swank::auto-flush-thread swank::indentation-cache-thread (swank::active-threads #39='nil :type list)) (#26# #27# #28# #29# #30# #31# #32# #33# #34# #35# #36# #37# (swank::reader-thread nil t nil 12 nil) (swank::control-thread nil t nil 13 nil) (swank::repl-thread nil t nil 14 nil) (swank::auto-flush-thread nil t nil 15 nil) (swank::indentation-cache-thread nil t nil 16 nil) (swank::active-threads #39# list nil 17 nil)) swank::copy-multithreaded-connection swank::connection (swank::make-multithreaded-connection) swank::multithreaded-connection-p si::define-structure swank::make-multithreaded-connection (nil :active-threads :indentation-cache-thread :auto-flush-thread :repl-thread :control-thread :reader-thread :communication-style :indentation-cache-packages :indentation-cache :repl-results :trace-output :env :user-io :user-output :user-input :dedicated-output :socket-io :socket) swank::missing-arg #:socket #:socket-io #:dedicated-output #:user-input #:user-output #:user-io #:env #:trace-output #:repl-results :test eq make-hash-table #:indentation-cache #:indentation-cache-packages #:communication-style #:reader-thread #:control-thread #:repl-thread #:auto-flush-thread #:indentation-cache-thread #:active-threads list typep swank::active-threads si::structure-type-error (member nil :spawn :sigio :fd-handler) (member nil :spawn :sigio :fd-handler) swank::communication-style hash-table swank::indentation-cache (or stream null) (or stream null) swank::repl-results (or stream null) (or stream null) swank::trace-output swank::env (or stream null) (or stream null) swank::user-io (or stream null) (or stream null) swank::user-output (or stream null) (or stream null) swank::user-input (or stream null) (or stream null) swank::dedicated-output stream swank::socket-io 0 si::make-structure #Y(swank::make-multithreaded-connection nil nil (28 10 22 40 5 19 0 11 12 46 12 22 40 5 19 0 11 12 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 2 77 46 19 22 40 2 77 46 20 22 40 9 14 21 15 22 19 2 23 12 46 24 22 40 2 77 46 25 22 40 2 77 46 26 22 40 2 77 46 27 22 40 2 77 46 28 22 40 2 77 46 29 22 40 2 77 46 30 22 40 2 77 46 31 22 40 2 77 46 32 13 0 15 33 19 2 34 76 39 12 13 0 15 33 15 0 15 35 19 4 36 13 6 15 37 19 2 34 76 39 12 13 6 15 38 15 0 15 39 19 4 36 13 8 15 40 19 2 34 76 39 12 13 8 15 40 15 0 15 41 19 4 36 13 9 15 42 19 2 34 76 39 12 13 9 15 43 15 0 15 44 19 4 36 13 10 15 45 19 2 34 76 39 12 13 10 15 46 15 0 15 47 19 4 36 13 11 15 33 19 2 34 76 39 12 13 11 15 33 15 0 15 48 19 4 36 13 12 15 49 19 2 34 76 39 12 13 12 15 50 15 0 15 51 19 4 36 13 13 15 52 19 2 34 76 39 12 13 13 15 53 15 0 15 54 19 4 36 13 14 15 55 19 2 34 76 39 12 13 14 15 56 15 0 15 57 19 4 36 13 15 15 58 19 2 34 76 39 12 13 15 15 59 15 0 15 60 19 4 36 13 16 15 61 19 2 34 76 39 12 13 16 15 61 15 0 15 62 19 4 36 15 63 13 17 13 16 13 15 13 14 13 13 13 12 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 19 64 29) #38# #2# 9303) si::fset find-class)) #2# 9303) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*emacs-connection* si::*make-special boundp variable "The connection to Emacs currently in use." si::set-documentation)) #2# 10330) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #40=#A(t (23) (swank::make-connection swank::socket stream swank::style #:g2098 :spawn swank::make-multithreaded-connection :sigio nil :fd-handler swank::make-singlethreaded-connection (:spawn :fd-handler nil :sigio) si::ecase-error :socket :socket-io :communication-style swank::conn swank::*new-connection-hook* swank::run-hook :add-connection swank::send-to-sentinel #Y(swank::make-connection nil nil (24 45 1 24 45 2 24 45 3 26 10 0 45 4 10 0 42 5 6 33 6 73 38 21 41 7 7 41 8 4 42 9 6 33 10 73 38 7 13 0 1 11 17 12 12 43 1 14 13 13 2 14 14 13 1 14 15 13 0 20 6 23 45 16 14 17 13 0 19 2 18 14 19 10 0 6 2 12 19 1 20 10 0 73 43 1 29) #40# #2# 10412) si::fset)) #2# 10412) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 1 0 16 4 12 19 2 5 29) #41=#A(t (6) (swank::ping swank::tag #Y(swank::ping nil nil (24 45 1 26 10 0 73 29) #41# #2# 10945) si::fset symbol-package export)) #2# 10945) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #42=#A(t (14) (swank::safe-backtrace #:g2102 #:g2103 0 error si::temp #Y(nil nil nil (24 45 5 26 10 0 51 2 35 1 0 29) #42# #2# 10980) si::*handler-clusters* swank::backtrace #Y(nil nil nil (26 9 0 77 19 2 8 29) #42# #2# 10980) swank-backend::call-with-debugging-environment condition #Y(swank::safe-backtrace nil nil (26 57 1 60 50 75 45 2 57 3 61 1 24 15 4 34 6 3 6 1 12 11 7 3 48 7 34 9 12 19 1 10 36 2 44 1 10 1 45 11 77 13 0 72 2 43 1 36 2 62 73 43 1 63 29) #42# #2# 10980) si::fset)) #2# 10980) #Y(si::bytecodes nil nil (15 0 15 1 14 2 1 8 12 1 9 7 3 12 15 10 1 11 6 3 12 14 12 1 13 6 2 12 19 4 14 1 0 73 29) #43=#A(t (15) (swank::swank-error (error) :initfunction swank::c swank::s swank::swank-error.condition princ #Y(nil nil nil (24 45 3 24 45 4 26 13 1 19 1 5 12 13 0 19 2 6 29) #43# #2# 11105) #Y(nil nil nil (26 34 7 73 29) #43# #2# 11105) (:initform (lambda (swank::c swank::s) (princ (swank::swank-error.condition swank::c) swank::s)) :name si::report-function) (:readers (swank::swank-error.backtrace) :initargs (:backtrace) :name swank::backtrace) (:readers (swank::swank-error.condition) :initargs (:condition) :name condition) :documentation "Condition which carries a backtrace." clos::load-defclass)) #2# 11105) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #44=#A(t (10) (swank::signal-swank-error condition swank::safe-backtrace swank::backtrace swank::swank-error :condition :backtrace error #Y(swank::signal-swank-error nil nil (24 45 1 25 40 5 19 0 2 12 46 3 26 15 4 14 5 13 1 14 6 13 0 19 5 7 29) #44# #2# 11404) si::fset)) #2# 11404) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*debug-on-swank-protocol-error* si::*make-special boundp variable "When non-nil invoke the system debugger on errors that were
signalled during decoding/encoding the wire protocol.  Do not set this
to T unless you want to debug swank internals." si::set-documentation)) #2# 11551) #Y(si::bytecodes nil nil (15 0 1 21 12 14 22 9 2 19 4 23 15 0 15 24 15 25 19 3 26 1 0 73 29) #45=#A(t (27) (swank::with-swank-error-handler #:g2106 #:g2105 #:g2107 si::dm-too-few-arguments #:g2108 #:g2109 swank::connection swank::body si::dm-too-many-arguments gensym swank::conn let handler-case handler-bind ((swank::swank-error (lambda (condition) (when swank::*debug-on-swank-protocol-error* (swank::invoke-default-debugger condition))))) progn swank::swank-error (condition) swank::close-connection ((swank::swank-error.condition condition) (swank::swank-error.backtrace condition)) #Y(swank::with-swank-error-handler nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 19 0 10 45 11 15 12 13 0 10 2 6 2 6 1 12 15 13 15 14 15 15 15 16 10 1 7 2 6 3 12 15 17 15 18 15 19 13 0 1 20 7 3 6 3 6 3 6 3 73 43 1 29) #45# #2# 11784) t si::fset function "Close the connection on internal `swank-error's." si::set-documentation)) #2# 11784) #Y(si::bytecodes nil nil (15 0 1 20 12 14 21 9 2 19 4 22 15 0 15 23 15 24 19 3 25 1 0 73 29) #46=#A(t (26) (swank::with-panic-handler #:g2111 #:g2110 #:g2112 si::dm-too-few-arguments #:g2113 #:g2114 swank::connection swank::body si::dm-too-many-arguments gensym swank::conn let handler-bind serious-condition lambda (condition) swank::close-connection (condition (swank::safe-backtrace)) (abort condition) #Y(swank::with-panic-handler nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 19 0 10 45 11 15 12 13 0 10 2 6 2 6 1 12 15 13 15 14 15 15 15 16 15 17 13 0 1 18 7 3 12 1 19 6 4 6 2 6 1 12 10 1 7 3 6 3 73 43 1 29) #46# #2# 12427) t si::fset function "Close the connection on unhandled `serious-condition's." si::set-documentation)) #2# 12427) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::notify-backend-of-connection swank::*new-connection-hook* adjoin)) #2# 12841) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #47=#A(t (5) (swank::notify-backend-of-connection swank::connection swank-backend::emacs-connected #Y(swank::notify-backend-of-connection nil nil (24 45 1 26 19 0 2 29) #47# #2# 12907) si::fset)) #2# 12907) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 24 14 3 14 4 77 19 3 5 45 6 15 7 13 0 19 2 8 10 0 43 1 52 0 1 0 73 29) #A(t (9) (swank::*swank-io-package* si::*make-special boundp :swank-io-package :use make-package package (nil t quote) import)) #2# 13012) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*log-events* si::*make-special boundp)) #2# 13197) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*log-output* si::*make-special boundp)) #2# 13226) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #48=#A(t (6) (swank::init-log-output swank::*log-output* *error-output* swank::real-output-stream #Y(swank::init-log-output nil nil (26 11 1 76 73 39 9 14 2 19 1 3 52 1 73 29) #48# #2# 13253) si::fset)) #2# 13253) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::init-log-output swank::*after-init-hook* adjoin)) #2# 13403) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #49=#A(t (11) (swank::real-input-stream stream #:g2118 synonym-stream typep synonym-stream-symbol symbol-value two-way-stream two-way-stream-input-stream #Y(swank::real-input-stream nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 13 10 1 16 5 16 6 12 19 1 0 38 23 13 0 15 7 19 2 4 39 11 10 1 16 8 12 19 1 0 38 4 10 1 73 43 1 29) #49# #2# 13452) si::fset)) #2# 13452) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #50=#A(t (11) (swank::real-output-stream stream #:g2120 synonym-stream typep synonym-stream-symbol symbol-value two-way-stream two-way-stream-output-stream #Y(swank::real-output-stream nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 13 10 1 16 5 16 6 12 19 1 0 38 23 13 0 15 7 19 2 4 39 11 10 1 16 8 12 19 1 0 38 4 10 1 73 43 1 29) #50# #2# 13707) si::fset)) #2# 13707) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 11 9 40 14 3 77 19 3 4 52 0 15 0 15 5 15 6 19 3 7 1 0 73 29) #A(t (8) (swank::*event-history* si::*make-special boundp :initial-element make-array variable "A ring buffer to record events for better error messages." si::set-documentation)) #2# 13966) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (swank::*event-history-index* si::*make-special boundp)) #2# 14094) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (swank::*enable-event-history* si::*make-special boundp t)) #2# 14128) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 15 0 15 26 15 27 19 3 28 1 0 73 29) #51=#A(t (29) (swank::log-event swank::format-string swank::args si::+io-syntax-progv-list+ #:%progv-list swank::*swank-io-package* *package* *print-pretty* *print-readably* swank::*enable-event-history* swank::*event-history* swank::*event-history-index* "~?" format si::aset 1+ length mod swank::*log-events* "~?" swank::escape-non-ascii swank::*log-output* write-string force-output #Y(swank::log-event nil nil (24 45 1 27 45 2 11 3 45 4 10 0 4 12 10 0 5 67 77 77 14 5 49 6 49 7 49 8 11 9 39 32 14 10 14 11 77 15 12 13 2 13 1 19 4 13 12 19 3 14 11 11 16 15 12 11 10 16 16 17 17 52 11 11 18 73 39 26 77 15 19 13 2 13 1 19 4 13 12 19 1 20 12 14 21 19 2 22 14 21 19 1 23 44 3 68 43 1 29) #51# #2# 14163) si::fset function "Write a message to *terminal-io* when *log-events* is non-nil.
Useful for low level debugging." si::set-documentation)) #2# 14163) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 1 0 73 29) #52=#A(t (13) (swank::event-history-to-list swank::*event-history* swank::*event-history-index* swank::idx swank::arr list subseq concatenate #Y(swank::event-history-to-list nil nil (26 14 1 14 2 46 3 46 4 15 5 13 0 13 1 19 2 6 12 13 0 9 0 13 1 19 3 6 12 19 3 7 43 2 29) #52# #2# 14894) si::fset function "Return the list of events (older events first)." si::set-documentation)) #2# 14894) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #53=#A(t (6) (swank::clear-event-history swank::*event-history* fill swank::*event-history-index* #Y(swank::clear-event-history nil nil (26 14 1 77 19 2 2 8 0 52 3 73 29) #53# #2# 15114) si::fset)) #2# 15114) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #54=#A(t (8) (swank::dump-event-history stream swank::event-history-to-list si::%dolist-var swank::e swank::dump-event #Y(swank::dump-event-history nil nil (24 45 1 26 19 0 2 45 3 75 45 4 38 18 10 1 4 51 0 13 0 13 2 19 2 5 10 1 5 51 1 10 1 40 -20 75 73 43 2 29) #54# #2# 15212) si::fset)) #2# 15212) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #55=#A(t (10) (swank::dump-event swank::event stream stringp swank::escape-non-ascii write-string "Unexpected event: ~A~%" format #Y(swank::dump-event nil nil (24 45 1 24 45 2 26 10 1 16 3 39 14 13 1 19 1 4 12 13 0 19 2 5 38 25 10 1 76 73 40 19 77 15 6 13 1 19 3 7 12 19 1 4 12 13 0 19 2 5 29) #55# #2# 15318) si::fset)) #2# 15318) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #56=#A(t (25) (swank::escape-non-ascii string swank::ascii-string-p make-string-output-stream swank::out #:loop-across-list2134 #:loop-across-index-2133 #:loop-across-vector-2132 swank::c 0 length >= aref 1+ swank::ascii-char-p write-char "\\x~4,'0X" char-code format get-output-stream-string #Y(swank::escape-non-ascii nil nil (24 45 1 26 13 0 19 1 2 39 6 10 0 73 38 100 19 0 3 45 4 77 13 1 9 0 9 0 46 5 46 6 46 7 46 8 57 9 61 2 8 65 10 2 16 10 51 4 13 3 13 4 19 2 11 39 4 35 0 1 13 2 13 3 19 2 12 51 1 10 3 16 13 51 3 13 1 19 1 14 39 10 13 1 13 5 19 2 15 38 13 13 5 15 16 10 1 16 17 12 19 3 18 35 0 0 62 43 4 10 0 16 19 43 1 29) #56# #2# 15595) si::fset function "Return a string like STRING but with non-ascii chars escaped." si::set-documentation)) #2# 15595) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #57=#A(t (7) (swank::ascii-string-p swank::o stringp swank::ascii-char-p every #Y(swank::ascii-string-p nil nil (24 45 1 26 10 0 16 2 73 39 9 33 3 12 13 0 19 2 4 29) #57# #2# 15955) si::fset)) #2# 15955) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #58=#A(t (6) (swank::ascii-char-p swank::c char-code <= #Y(swank::ascii-char-p nil nil (24 45 1 26 10 0 16 2 12 9 127 19 2 3 29) #58# #2# 16039) si::fset)) #2# 16039) #Y(si::bytecodes nil nil (15 0 1 38 12 14 25 9 2 19 4 39 15 0 15 40 15 41 19 3 42 1 0 73 29) #59=#A(t (43) (swank::destructure-case #:g2136 #:g2135 #:g2137 si::dm-too-few-arguments swank::value swank::patterns "op-" gensym "rand-" "tmp-" swank::tmp swank::operands swank::operator let* car cdr case #:loop-list2153 swank::body swank::pattern #:loop-list-head2154 #:loop-list-tail2155 0 #60=#:loop-desetq-temp t eq #:g2156 #:g2157 swank::op swank::rands destructuring-bind rplacd last caar error #61="destructure-case failed: ~S" append #Y(swank::destructure-case nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 45 6 15 7 19 1 8 12 15 9 19 1 8 12 15 10 19 1 8 12 46 11 46 12 46 13 15 14 13 2 10 4 6 2 12 13 0 15 15 10 2 6 2 6 2 12 13 1 15 16 10 2 6 2 6 2 6 3 12 15 17 13 0 58 60 150 77 77 13 4 46 18 46 19 46 20 75 6 1 45 21 10 0 45 22 57 23 61 2 2 112 10 5 2 39 4 35 0 1 10 5 4 45 24 10 0 4 51 4 10 0 5 51 0 10 0 51 5 43 1 10 5 5 51 5 13 1 13 3 11 25 17 26 39 9 15 25 10 4 7 2 38 51 10 3 45 27 10 0 45 28 10 0 76 39 6 13 1 19 1 4 10 0 4 12 10 0 5 51 0 22 45 29 10 1 45 30 13 1 15 31 13 0 13 12 10 8 7 4 6 2 43 4 6 1 51 1 17 32 35 0 0 10 2 5 73 36 6 62 73 43 2 43 3 63 12 13 3 19 1 33 16 34 12 11 25 17 26 39 5 75 73 38 16 15 25 15 35 15 36 10 2 6 3 6 2 6 1 73 12 19 2 37 7 3 6 3 73 43 3 29) #59# #2# 16094) si::fset function "Dispatch VALUE to one of PATTERNS.
A cross between `case' and `destructuring-bind'.
The pattern syntax is:
  ((HEAD . ARGS) . BODY)
The list of patterns is searched for a HEAD `eq' to the car of
VALUE. If one is found, the BODY is executed with ARGS bound to the
corresponding values in the CDR of VALUE." si::set-documentation)) #2# 16094) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (swank::*slime-interrupts-enabled* si::*make-special)) #2# 17136) #Y(si::bytecodes nil nil (15 0 1 15 12 14 16 9 3 19 4 17 1 0 73 29) #62=#A(t (18) (swank::with-interrupts-enabled% #:g2159 #:g2158 #:g2160 si::dm-too-few-arguments swank::flag swank::body si::dm-too-many-arguments progn ((swank-backend::check-slime-interrupts)) multiple-value-prog1 let swank::*slime-interrupts-enabled* ((swank-backend::check-slime-interrupts)) append #Y(swank::with-interrupts-enabled% nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 10 1 73 39 4 1 9 73 12 15 10 15 11 15 12 10 1 6 2 6 1 12 10 0 7 3 12 10 1 39 3 1 13 7 3 6 1 12 19 2 14 7 2 73 29) #62# #2# 18587) t si::fset)) #2# 18587) #Y(si::bytecodes nil nil (15 0 1 7 12 14 6 9 1 19 4 8 1 0 73 29) #63=#A(t (9) (swank::with-slime-interrupts #:g2162 #:g2161 #:g2163 swank::body swank::with-interrupts-enabled% t #Y(swank::with-slime-interrupts nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 10 0 6 3 73 29) #63# #2# 18845) si::fset)) #2# 18845) #Y(si::bytecodes nil nil (15 0 1 6 12 14 7 9 1 19 4 8 1 0 73 29) #64=#A(t (9) (swank::without-slime-interrupts #:g2165 #:g2164 #:g2166 swank::body swank::with-interrupts-enabled% #Y(swank::without-slime-interrupts nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 77 10 0 6 3 73 29) #64# #2# 18933) t si::fset)) #2# 18933) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #65=#A(t (36) (swank::invoke-or-queue-interrupt function "invoke-or-queue-interrupt: ~a~%" swank::log-event swank::*slime-interrupts-enabled* boundp "interrupts-enabled~%" swank-backend::*pending-slime-interrupts* nconc "too many queued interrupts~%" #:g2171 #:g2172 0 :name continue :function si::temp #Y(nil nil nil (27 45 16 10 0 51 2 35 1 0 29) #65# #2# 19026) :report-function stream "Continue from interrupt" format #Y(nil nil nil (24 45 19 26 13 0 15 20 19 2 21 29) #65# #2# 19026) si::make-restart si::*restart-clusters* serious-condition swank::invoke-slime-debugger si::*handler-clusters* swank-backend::check-slime-interrupts t #Y(nil nil nil (26 77 14 29 72 2 29) #65# #2# 19026) apply "queue-interrupt: ~a~%" swank-backend::*interrupt-queued-handler* #Y(swank::invoke-or-queue-interrupt nil nil (24 45 1 26 15 2 13 0 19 2 3 1 4 16 5 76 39 13 75 48 4 13 0 20 0 23 44 1 38 132 11 4 39 13 15 6 19 1 3 13 0 20 0 23 38 116 14 7 10 0 6 1 12 19 2 8 52 7 11 7 5 39 82 15 9 19 1 3 57 10 60 71 75 45 11 57 12 61 1 48 14 13 15 14 14 15 34 17 12 14 18 34 22 12 19 6 23 6 1 12 11 24 3 48 24 15 25 33 26 3 6 1 12 11 27 3 48 27 19 0 28 44 1 36 2 44 1 34 30 12 13 1 19 2 31 36 2 62 73 43 1 63 38 18 15 32 13 0 19 2 3 11 33 73 39 6 14 33 20 0 23 29) #65# #2# 19026) si::fset)) #2# 19026) #Y(si::bytecodes nil nil (15 0 1 12 12 14 13 9 2 19 4 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #66=#A(t (18) (swank::with-io-redirection #:g2176 #:g2175 #:g2177 si::dm-too-few-arguments #:g2178 #:g2179 swank::connection swank::body si::dm-too-many-arguments swank::with-bindings swank::connection.env #Y(swank::with-io-redirection nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 15 11 10 1 6 2 12 10 0 7 3 73 29) #66# #2# 20017) t si::fset function "Execute BODY I/O redirection to CONNECTION. " si::set-documentation)) #2# 20017) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (swank::*send-counter* si::*make-special)) #2# 20215) #Y(si::bytecodes nil nil (15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 11 15 17 19 3 18 1 0 73 29) #67=#A(t (19) (swank::with-connection #:g2181 #:g2180 #:g2182 si::dm-too-few-arguments #:g2183 #:g2184 swank::connection swank::body si::dm-too-many-arguments let function lambda (if (eq swank::*emacs-connection* swank::connection) (funcall function) (let ((swank::*emacs-connection* swank::connection) (swank-backend::*pending-slime-interrupts* 'nil) (swank::*send-counter* 0)) (swank::without-slime-interrupts (swank::with-swank-error-handler (swank::connection) (swank::with-io-redirection (swank::connection) (swank-backend::call-with-debugger-hook #'swank::swank-debugger-hook function)))))) #Y(swank::with-connection nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 15 7 10 1 6 2 12 15 11 15 12 77 10 0 7 3 6 2 6 2 12 1 13 6 3 73 29) #67# #2# 20328) t si::fset "Execute BODY in the context of CONNECTION." si::set-documentation)) #2# 20328) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #68=#A(t (23) (swank::call-with-retry-restart swank::msg swank::thunk 0 #:g2191 #:g2192 :name swank::retry :function si::temp #Y(nil nil nil (27 45 9 10 0 51 2 35 1 0 29) #68# #2# 20982) :report-function stream "~a" format #Y(nil nil nil (24 45 12 26 13 0 15 13 13 7 19 3 14 29) #68# #2# 20982) si::make-restart si::*restart-clusters* t #Y(nil nil nil (26 77 14 18 72 2 29) #68# #2# 20982) apply #Y(swank::call-with-retry-restart nil nil (24 45 1 24 45 2 26 58 60 74 57 3 61 1 1 57 4 60 59 75 45 5 57 3 61 1 37 14 6 15 7 14 8 34 10 12 14 11 34 15 12 19 6 16 6 1 12 11 17 3 48 17 13 5 20 0 23 36 4 36 2 44 1 34 19 12 13 1 19 2 20 36 2 62 43 1 63 35 0 0 62 73 63 29) #68# #2# 20982) si::fset)) #2# 20982) #Y(si::bytecodes nil nil (15 0 1 23 12 14 24 9 2 19 4 25 1 0 73 29) #69=#A(t (26) (swank::with-retry-restart #:g2196 #:g2195 #:g2197 si::dm-too-few-arguments #:g2198 #:g2199 :msg si::search-keyword #:g2200 si::missing-keyword eq "Retry." swank::msg swank::body (:msg) si::check-keyword #:g2207 string typep si::do-check-type swank::call-with-retry-restart lambda #Y(swank::with-retry-restart nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 13 0 15 7 19 2 8 45 9 13 0 1 10 17 11 39 5 1 12 38 3 10 0 45 13 10 4 45 14 13 3 15 15 19 2 16 10 1 45 17 13 0 15 18 19 2 19 76 39 13 13 0 15 18 77 15 13 19 4 20 51 2 43 1 15 21 13 1 15 22 77 10 0 7 3 6 3 73 29) #69# #2# 21114) t si::fset)) #2# 21114) #Y(si::bytecodes nil nil (15 0 1 26 12 14 27 9 2 19 4 28 1 0 73 29) #70=#A(t (29) (swank::with-struct* #:g2210 #:g2209 #:g2211 si::dm-too-few-arguments #:g2212 #:g2213 swank::conc-name get swank::obj swank::body si::dm-too-many-arguments gensym swank::var let macrolet (swank::slot) swank::getter intern concatenate 'string quote string (string swank::slot) symbol-package list #Y(swank::with-struct* nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 6 19 1 4 10 2 4 12 10 2 5 51 2 22 45 9 10 5 45 10 10 4 39 6 13 8 19 1 11 19 0 12 45 13 15 14 13 0 10 2 6 2 6 1 12 15 15 13 3 15 16 15 14 15 17 15 18 15 19 15 20 15 21 10 4 16 22 6 2 12 1 23 6 4 12 15 24 15 21 10 4 6 2 6 2 6 3 6 2 6 1 12 15 25 15 17 15 21 10 0 6 2 6 3 6 3 6 3 6 1 12 10 1 7 3 6 3 73 43 1 29) #70# #2# 21263) t si::fset)) #2# 21263) #Y(si::bytecodes nil nil (15 0 1 14 12 14 15 9 3 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #71=#A(t (20) (swank::define-special #:g2215 #:g2214 #:g2216 si::dm-too-few-arguments swank::name swank::doc si::dm-too-many-arguments progn defvar setf documentation quote 'variable #Y(swank::define-special nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 15 9 10 1 6 2 12 15 10 15 11 15 12 10 1 6 2 12 1 13 6 3 12 10 0 6 3 6 3 73 29) #71# #2# 21756) t si::fset function "Define a special variable NAME with doc string DOC.
This is like defvar, but NAME will not be initialized." si::set-documentation)) #2# 21756) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*connections* si::*make-special boundp variable "List of all active connections, with the most recent at the front." si::set-documentation)) #2# 21991) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*servers* si::*make-special boundp variable "A list ((server-socket port thread) ...) describing the listening sockets.
Used to close sockets on server shutdown or restart." si::set-documentation)) #2# 22197) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 15 4 15 5 19 3 6 1 0 73 29) #72=#A(t (7) (swank::default-connection swank::*connections* #Y(swank::default-connection nil nil (26 11 1 4 73 29) #72# #2# 22357) si::fset function "Return the 'default' Emacs connection.
This connection can be used to talk with Emacs when no specific
connection is in use, i.e. *EMACS-CONNECTION* is NIL.

The default connection is defined (quite arbitrarily) as the most
recently established one." si::set-documentation)) #2# 22357) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #73=#A(t (10) (swank::start-sentinel swank::sentinel swank-backend::find-registered :name "Swank Sentinel" swank-backend::spawn swank::thread swank-backend::register-thread #Y(swank::start-sentinel nil nil (26 15 1 19 1 2 76 73 39 22 33 1 12 14 3 15 4 19 3 5 45 6 15 1 13 0 19 2 7 43 1 29) #73# #2# 22868) si::fset)) #2# 22868) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #74=#A(t (7) (swank::sentinel swank::exit-sentinel 0 swank-backend::receive swank::sentinel-serve #Y(swank::sentinel nil nil (26 1 1 59 60 19 57 2 61 1 1 19 0 3 12 19 1 4 35 0 0 62 73 63 29) #74# #2# 23044) si::fset)) #2# 23044) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #75=#A(t (8) (swank::send-to-sentinel swank::msg swank::sentinel swank-backend::find-registered swank-backend::send swank::sentinel-serve #Y(swank::send-to-sentinel nil nil (24 45 1 26 15 2 19 1 3 45 2 10 0 39 10 13 0 13 1 19 2 4 38 6 13 1 19 1 5 43 1 29) #75# #2# 23132) si::fset)) #2# 23132) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #76=#A(t (36) (swank::sentinel-serve swank::msg #:|tmp-2234| #:|op-2232| #:|rand-2233| :add-connection #:g2235 #:g2236 si::dm-too-few-arguments swank::conn si::dm-too-many-arguments swank::*connections* :close-connection #:g2238 #:g2239 swank::connection condition swank::backtrace swank::close-connection% swank::sentinel-maybe-exit :add-server #:g2240 #:g2241 swank::socket swank::port swank::thread swank::*servers* :stop-server #:g2243 #:g2244 swank::key swank::sentinel-stop-server #61# error #Y(swank::sentinel-serve nil nil (24 45 1 26 10 0 45 2 10 0 4 45 3 10 1 5 45 4 10 1 42 5 52 10 0 45 6 10 0 45 7 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 9 10 1 39 6 13 2 19 1 10 13 0 11 11 3 52 11 73 43 3 38 293 42 12 100 10 0 45 13 10 0 45 14 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 15 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 16 10 2 76 39 6 13 3 19 1 8 10 2 4 12 10 2 5 51 2 22 45 17 10 3 39 6 13 4 19 1 10 13 2 13 1 13 0 19 3 18 19 0 19 43 5 38 191 42 20 103 10 0 45 21 10 0 45 22 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 23 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 24 10 2 76 39 6 13 3 19 1 8 10 2 4 12 10 2 5 51 2 22 45 25 10 3 39 6 13 4 19 1 10 13 2 13 1 10 0 6 3 12 11 26 3 52 26 73 43 5 38 86 42 27 76 10 0 45 28 10 0 45 29 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 30 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 24 10 2 39 6 13 3 19 1 10 13 1 13 0 19 2 31 19 0 19 43 4 38 8 15 32 13 2 19 2 33 43 3 29) #76# #2# 23295) si::fset)) #2# 23295) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 1 0 73 29) #77=#A(t (39) (swank::sentinel-stop-server swank::key swank::value swank::*servers* :key #:g2251 :socket car :port cadr (:socket :port) si::ecase-error find swank::probe delete #:g2252 #:g2253 si::dm-too-few-arguments swank::socket swank::_port swank::thread si::dm-too-many-arguments #:g2254 #:g2255 0 error si::temp #Y(nil nil nil (24 45 26 26 10 0 51 2 35 1 0 29) #77# #2# 23744) si::*handler-clusters* swank-backend::close-socket condition swank-backend::thread-alive-p swank-backend::current-thread eq swank-backend::kill-thread "No server for ~s: ~s" warn #Y(swank::sentinel-stop-server nil nil (24 45 1 24 45 2 26 13 0 14 3 14 4 10 1 45 5 10 0 42 6 6 33 7 73 38 15 42 8 6 33 9 73 38 7 13 0 1 10 17 11 12 43 1 19 4 12 45 13 10 0 39 175 13 0 14 3 19 2 14 52 3 10 0 45 15 10 0 45 16 10 0 76 39 6 13 1 19 1 17 10 0 4 12 10 0 5 51 0 22 45 18 10 1 76 39 6 13 2 19 1 17 10 1 4 12 10 1 5 51 1 22 45 19 10 2 76 39 6 13 3 19 1 17 10 2 4 12 10 2 5 51 2 22 45 20 10 3 39 6 13 4 19 1 21 57 22 60 48 75 45 23 57 24 61 1 23 15 25 34 27 3 6 1 12 11 28 3 48 28 13 5 19 1 29 36 2 44 1 10 1 45 30 77 13 0 72 2 43 1 36 2 62 43 1 63 10 0 39 16 13 0 19 1 31 39 9 13 0 19 0 32 17 33 76 73 39 6 13 0 19 1 34 43 5 38 10 15 35 13 2 13 1 19 3 36 43 1 29) #77# #2# 23744) si::fset)) #2# 23744) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #78=#A(t (11) (swank::sentinel-maybe-exit swank::*connections* swank::*servers* swank-backend::current-thread swank::sentinel swank-backend::find-registered eq swank-backend::register-thread swank::exit-sentinel #Y(swank::sentinel-maybe-exit nil nil (26 11 1 76 39 22 11 2 76 39 17 19 0 3 39 12 15 4 19 1 5 12 19 0 3 17 6 73 39 12 15 4 77 19 2 7 15 8 75 73 37 29) #78# #2# 24444) si::fset)) #2# 24444) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #79=#A(t (7) (swank::use-threads-p swank::*emacs-connection* swank::connection.communication-style :spawn eq #Y(swank::use-threads-p nil nil (26 14 1 19 1 2 12 11 3 17 4 29) #79# #2# 24744) si::fset)) #2# 24744) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #80=#A(t (5) (swank::current-thread-id swank-backend::current-thread swank-backend::thread-id #Y(swank::current-thread-id nil nil (26 19 0 1 12 19 1 2 29) #80# #2# 24856) si::fset)) #2# 24856) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((inline swank::ensure-list) proclaim)) #2# 24920) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #81=#A(t (5) (swank::ensure-list swank::thing listp #Y(swank::ensure-list nil nil (24 45 1 26 10 0 16 2 39 6 10 0 73 38 6 10 0 6 1 73 29) #81# #2# 24954) si::fset)) #2# 24954) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #82=#A(t (18) (swank::symbol-status symbol symbol-package package #:g2261 typep si::do-check-type #:g2263 symbol-name find-symbol swank::status swank::present-symbol eq #Y(swank::symbol-status nil nil (24 45 1 25 40 6 10 0 16 2 12 46 3 26 10 0 73 39 86 10 1 45 4 13 0 15 1 19 2 5 76 39 13 13 0 15 1 77 15 1 19 4 6 51 2 43 1 10 0 45 7 13 0 15 3 19 2 5 76 39 13 13 0 15 3 77 15 3 19 4 6 51 1 43 1 10 1 16 8 12 13 0 19 2 9 47 1 10 45 11 13 3 10 0 17 12 73 39 4 10 1 73 43 2 29) #82# #2# 25024) si::fset function "Returns one of 

  :INTERNAL  if the symbol is _present_ in PACKAGE as an _internal_ symbol,

  :EXTERNAL  if the symbol is _present_ in PACKAGE as an _external_ symbol,

  :INHERITED if the symbol is _inherited_ by PACKAGE through USE-PACKAGE,
             but is not _present_ in PACKAGE,

  or NIL     if SYMBOL is not _accessible_ in PACKAGE.


Be aware not to get confused with :INTERNAL and how \"internal
symbols\" are defined in the spec; there is a slight mismatch of
definition with the Spec and what's commonly meant when talking
about internal symbols most times. As the spec says:

  In a package P, a symbol S is
  
     _accessible_  if S is either _present_ in P itself or was
                   inherited from another package Q (which implies
                   that S is _external_ in Q.)
  
        You can check that with: (AND (SYMBOL-STATUS S P) T)
  
  
     _present_     if either P is the /home package/ of S or S has been
                   imported into P or exported from P by IMPORT, or
                   EXPORT respectively.
  
                   Or more simply, if S is not _inherited_.
  
        You can check that with: (LET ((STATUS (SYMBOL-STATUS S P)))
                                   (AND STATUS 
                                        (NOT (EQ STATUS :INHERITED))))
  
  
     _external_    if S is going to be inherited into any package that
                   /uses/ P by means of USE-PACKAGE, MAKE-PACKAGE, or
                   DEFPACKAGE.
  
                   Note that _external_ implies _present_, since to
                   make a symbol _external_, you'd have to use EXPORT
                   which will automatically make the symbol _present_.
  
        You can check that with: (EQ (SYMBOL-STATUS S P) :EXTERNAL)
  
  
     _internal_    if S is _accessible_ but not _external_.

        You can check that with: (LET ((STATUS (SYMBOL-STATUS S P)))
                                   (AND STATUS 
                                        (NOT (EQ STATUS :EXTERNAL))))
  

        Notice that this is *different* to
                                 (EQ (SYMBOL-STATUS S P) :INTERNAL)
        because what the spec considers _internal_ is split up into two
        explicit pieces: :INTERNAL, and :INHERITED; just as, for instance,
        CL:FIND-SYMBOL does. 

        The rationale is that most times when you speak about \"internal\"
        symbols, you're actually not including the symbols inherited 
        from other packages, but only about the symbols directly specific
        to the package in question.
" si::set-documentation)) #2# 25024) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #83=#A(t (12) (swank::symbol-external-p symbol symbol-package package swank::symbol-status :external eq #Y(swank::symbol-external-p nil nil (24 45 1 25 40 6 10 0 16 2 12 46 3 26 13 1 13 0 19 2 4 12 11 5 17 6 29) #83# #2# 28109) si::fset function "True if SYMBOL is external in PACKAGE.
If PACKAGE is not specified, the home package of SYMBOL is used." si::set-documentation)) #2# 28109) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 6 19 0 3 52 0 1 0 73 29) #A(t (4) (swank::*communication-style* si::*make-special boundp swank-backend::preferred-communication-style)) #2# 28350) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*dont-close* si::*make-special boundp variable "Default value of :dont-close argument to start-server and
  create-server." si::set-documentation)) #2# 28438) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #84=#A(t (16) (swank::start-server swank::port-file (nil :dont-close :style) swank::*communication-style* swank::style swank::*dont-close* swank::dont-close swank::port swank::announce-server-port #Y(nil nil nil (24 45 7 26 13 3 13 0 19 2 8 29) #84# #2# 28548) swank::setup-server #Y(swank::start-server nil nil (24 45 1 28 2 22 40 3 14 3 46 4 22 40 3 14 5 46 6 9 0 34 9 12 13 1 13 0 77 19 5 10 29) #84# #2# 28548) si::fset function "Start the server and write the listen port number to PORT-FILE.
This is the entry point for Emacs." si::set-documentation)) #2# 28548) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #85=#A(t (16) (swank::create-server (nil :backlog :dont-close :style :port) swank::default-server-port swank::port swank::*communication-style* swank::style swank::*dont-close* swank::dont-close swank::backlog swank::simple-announce-function swank::setup-server #Y(swank::create-server nil nil (28 1 22 40 3 14 2 46 3 22 40 3 14 4 46 5 22 40 3 14 6 46 7 22 40 2 77 46 8 13 3 33 9 12 13 2 13 1 13 0 19 5 10 29) #85# #2# 28916) si::fset function "Start a SWANK server on PORT running in STYLE.
If DONT-CLOSE is true then the listen socket will accept multiple
connections, otherwise it will be closed after the first." si::set-documentation)) #2# 28916) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #86=#A(t (7) (swank::find-external-format-or-lose swank::coding-system swank-backend::find-external-format "Unsupported coding system: ~s" error #Y(swank::find-external-format-or-lose nil nil (24 45 1 26 13 0 19 1 2 73 40 8 15 3 13 0 19 2 4 29) #86# #2# 29384) si::fset)) #2# 29384) #Y(si::bytecodes nil nil (1 0 16 1 1 2 52 0 1 0 73 29) #A(t (3) (swank::*loopback-interface* si::*make-special "127.0.0.1")) #2# 29546) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #87=#A(t (37) (swank::setup-server swank::port swank::announce-fn swank::style swank::dont-close swank::backlog swank::init-log-output swank::*loopback-interface* :backlog swank-backend::create-socket swank::socket swank-backend::local-port swank::accept-connections #Y(swank::serve nil nil (26 13 4 13 7 13 6 19 3 12 29) #87# #2# 29597) :add-server swank-backend::current-thread swank::send-to-sentinel #Y(swank::note nil nil (26 14 14 13 4 13 3 19 0 15 6 4 12 19 1 16 29) #87# #2# 29597) 0 #Y(swank::serve-loop nil nil (26 32 1 18 0 57 18 61 2 2 16 32 3 18 0 10 7 76 39 4 35 0 1 35 0 0 62 73 29) #87# #2# 29597) #:g2266 :spawn swank::start-sentinel :name "Swank ~s" format swank-backend::spawn #Y(nil nil nil (26 19 0 22 32 1 12 14 23 77 15 24 13 4 19 3 25 12 19 3 26 29) #87# #2# 29597) swank-backend::initialize-multiprocessing :fd-handler :sigio swank-backend::add-fd-handler nil (:spawn :sigio :fd-handler nil) si::ecase-error #Y(swank::setup-server nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 19 0 6 14 7 13 4 14 8 13 0 19 4 9 45 10 13 0 19 1 11 45 1 13 5 13 0 20 1 23 31 3 13 17 19 10 7 45 20 10 0 42 21 9 34 27 12 19 1 28 38 36 41 29 4 42 30 15 32 2 18 0 13 5 32 3 12 19 2 31 38 16 42 32 7 32 1 18 0 38 7 13 0 1 33 17 34 43 1 43 3 10 0 73 43 2 29) #87# #2# 29597) si::fset)) #2# 29597) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #88=#A(t (10) (swank::stop-server swank::port :stop-server :port swank::send-to-sentinel #Y(swank::stop-server nil nil (24 45 1 26 14 2 14 3 10 0 6 3 12 19 1 4 29) #88# #2# 30470) si::fset function "Stop server running on PORT." si::set-documentation)) #2# 30470) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #89=#A(t (19) (swank::restart-server (nil :dont-close :style :port) swank::default-server-port swank::port swank::*communication-style* swank::style swank::*dont-close* swank::dont-close swank::stop-server sleep :port :style :dont-close swank::create-server #Y(swank::restart-server nil nil (28 1 22 40 3 14 2 46 3 22 40 3 14 4 46 5 22 40 3 14 6 46 7 13 2 19 1 8 8 5 16 9 14 10 13 2 14 11 13 1 14 12 13 0 19 6 13 29) #89# #2# 30584) si::fset function "Stop the server listening on PORT, then start a new SWANK server 
on PORT running in STYLE. If DONT-CLOSE is true then the listen socket 
will accept multiple connections, otherwise it will be closed after the 
first." si::set-documentation)) #2# 30584) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #90=#A(t (18) (swank::accept-connections swank::socket swank::style swank::dont-close :external-format :buffering t swank-backend::accept-connection swank-backend::close-socket swank::client swank::authenticate-client swank::make-connection swank::serve-requests :stop-server :socket swank::send-to-sentinel #Y(swank::accept-connections nil nil (24 45 1 24 45 2 24 45 3 26 64 14 13 2 14 4 77 14 5 14 6 19 5 7 65 10 0 76 39 6 13 2 19 1 8 66 45 9 13 0 19 1 10 13 3 13 0 13 2 19 3 11 12 19 1 12 10 1 76 73 39 13 14 13 14 14 10 3 6 3 12 19 1 15 43 1 29) #90# #2# 31075) si::fset)) #2# 31075) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #91=#A(t (13) (swank::authenticate-client stream swank::slime-secret swank::secret swank-backend::set-stream-timeout swank::decode-message swank::first-val stringp string= "Incoming connection doesn't know the password." error #Y(swank::authenticate-client nil nil (24 45 1 26 19 0 2 45 3 10 0 73 39 44 13 1 9 20 19 2 4 13 1 19 1 5 45 6 10 0 16 7 39 8 13 0 13 1 19 2 8 76 39 6 15 9 19 1 10 43 1 13 1 77 19 2 4 43 1 29) #91# #2# 31559) si::fset)) #2# 31559) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #92=#A(t (17) (swank::slime-secret user-homedir-pathname #P".slime-secret" merge-pathnames :if-does-not-exist open swank::in "" read-line close :abort t #Y(swank::slime-secret nil nil (26 19 0 1 12 15 2 19 2 3 12 14 4 77 19 3 5 45 6 64 26 10 0 73 39 9 13 0 77 15 7 19 3 8 69 10 0 39 6 13 0 19 1 9 70 65 10 0 39 10 13 0 14 10 14 11 19 3 9 66 43 1 29) #92# #2# 31920) si::fset function "Finds the magic secret from the user's home directory.  Returns nil
if the file doesn't exist; otherwise the first line of the file." si::set-documentation)) #2# 31920) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #93=#A(t (24) (swank::serve-requests swank::connection #:g2269 swank::multithreaded-connection typep swank::spawn-threads-for-connection swank::singlethreaded-connection swank::connection.communication-style #:g2270 nil swank::simple-serve-requests :sigio swank::install-sigio-handler :fd-handler swank::install-fd-handler (nil :sigio :fd-handler) si::ecase-error (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::serve-requests nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 8 13 1 19 1 5 38 65 13 0 15 6 19 2 4 39 50 13 1 19 1 7 45 8 10 0 42 9 8 13 2 19 1 10 38 27 42 11 8 13 2 19 1 12 38 17 42 13 8 13 2 19 1 14 38 7 13 0 1 15 17 16 43 1 38 7 13 0 1 17 17 18 43 1 29) #93# #2# 32270) si::fset function "Read and process all requests on connections." si::set-documentation)) #2# 32270) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #94=#A(t (20) (swank::stop-serving-requests swank::connection #:g2273 swank::multithreaded-connection typep swank::cleanup-connection-threads swank::singlethreaded-connection swank::connection.communication-style #:g2274 nil :sigio swank::deinstall-sigio-handler :fd-handler swank::deinstall-fd-handler (nil :sigio :fd-handler) si::ecase-error (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::stop-serving-requests nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 8 13 1 19 1 5 38 62 13 0 15 6 19 2 4 39 47 13 1 19 1 7 45 8 10 0 42 9 5 75 73 38 27 42 10 8 13 2 19 1 11 38 17 42 12 8 13 2 19 1 13 38 7 13 0 1 14 17 15 43 1 38 7 13 0 1 16 17 17 43 1 29) #94# #2# 32714) si::fset)) #2# 32714) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #95=#A(t (19) (swank::announce-server-port swank::file swank::port :direction :output :if-exists :error :if-does-not-exist :create open swank::s "~S~%" format close :abort t swank::simple-announce-function #Y(swank::announce-server-port nil nil (24 45 1 24 45 2 26 13 1 14 3 14 4 14 5 14 6 14 7 14 8 19 7 9 45 10 64 22 13 0 15 11 13 1 19 3 12 69 10 0 39 6 13 0 19 1 13 70 65 10 0 39 10 13 0 14 14 14 15 19 3 13 66 43 1 13 0 19 1 16 29) #95# #2# 33081) si::fset)) #2# 33081) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #96=#A(t (9) (swank::simple-announce-function swank::port swank::*swank-debug-p* swank::*log-output* "~&;; Swank started at port: ~D.~%" format force-output #Y(swank::simple-announce-function nil nil (24 45 1 26 11 2 73 39 15 14 3 15 4 13 0 19 3 5 14 3 19 1 6 29) #96# #2# 33347) si::fset)) #2# 33347) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #97=#A(t (25) (swank::decode-message stream "decode-message~%" swank::log-event swank::*slime-interrupts-enabled* error swank::signal-swank-error si::*handler-clusters* #:g2278 #:g2279 0 swank-rpc::swank-reader-error si::temp #Y(nil nil nil (24 45 12 26 10 0 51 2 35 1 0 29) #97# #2# 33517) swank::*swank-io-package* swank-rpc::read-message swank::c :reader-error swank-rpc::swank-reader-error.packet swank-rpc::swank-reader-error.cause #Y(swank::decode-message nil nil (24 45 1 26 15 2 19 1 3 75 48 4 15 5 33 6 3 6 1 12 11 7 3 48 7 57 8 60 62 75 45 9 57 10 61 1 25 15 11 34 13 3 6 1 12 11 7 3 48 7 13 3 14 14 19 2 15 36 2 44 1 10 1 45 16 14 17 13 0 19 1 18 12 13 0 19 1 19 6 3 73 43 1 36 2 62 73 43 1 63 44 1 44 1 29) #97# #2# 33517) si::fset function "Read an S-expression from STREAM using the SLIME protocol." si::set-documentation)) #2# 33517) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #98=#A(t (16) (swank::encode-message swank-backend::message stream "encode-message~%" swank::log-event swank::*slime-interrupts-enabled* error swank::signal-swank-error si::*handler-clusters* swank::*swank-io-package* swank-rpc::write-message #Y(swank::encode-message nil nil (24 45 1 24 45 2 26 15 3 19 1 4 75 48 5 15 6 33 7 3 6 1 12 11 8 3 48 8 13 1 14 9 13 0 19 3 10 44 1 44 1 29) #98# #2# 33981) si::fset function "Write an S-expression to STREAM using the SLIME protocol." si::set-documentation)) #2# 33981) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*sldb-quit-restart* si::*make-special boundp variable "The restart that will be invoked when the user calls sldb-quit." si::set-documentation)) #2# 34259) #Y(si::bytecodes nil nil (15 0 1 21 12 14 22 9 2 19 4 23 1 0 73 29) #99=#A(t (24) (swank::with-top-level-restart #:g2282 #:g2281 #:g2283 si::dm-too-few-arguments #:g2284 #:g2285 swank::connection swank::k swank::body si::dm-too-many-arguments swank::with-connection restart-case let ((swank::*sldb-quit-restart* (find-restart 'abort))) abort (&optional swank::v) :report #100="Return to SLIME's top level." (declare (ignore swank::v)) (swank::force-user-output) #Y(swank::with-top-level-restart nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 4 45 9 10 3 39 6 13 7 19 1 10 15 11 10 2 6 1 12 15 12 15 13 15 14 10 0 7 3 12 15 15 15 16 14 17 15 18 15 19 15 20 10 1 6 7 6 3 6 3 73 29) #99# #2# 34393) t si::fset)) #2# 34393) #Y(si::bytecodes nil nil (15 0 1 57 12 19 2 58 15 0 15 26 15 59 19 3 60 1 0 73 29) #101=#A(t (61) (swank::handle-requests swank::connection swank::timeout swank::*sldb-quit-restart* swank::process-requests 0 #:g2298 #:g2299 :name abort :function si::temp #Y(nil nil nil (27 45 11 10 0 51 2 35 1 0 29) #101# #2# 34842) :report-function stream #100# write-string #Y(nil nil nil (24 45 14 26 15 15 13 0 19 2 16 29) #101# #2# 34842) si::make-restart si::*restart-clusters* find-restart swank::v swank::force-user-output #Y(nil nil nil (25 40 2 77 46 21 26 19 0 22 35 4 0 29) #101# #2# 34842) apply #Y(nil nil nil (26 57 6 60 67 75 45 7 57 5 61 1 44 14 8 15 9 14 10 34 12 12 14 13 34 17 12 19 6 18 6 1 12 11 19 3 48 19 15 9 19 1 20 48 3 13 4 19 1 4 44 1 36 2 44 1 34 23 12 13 1 19 2 24 36 2 62 73 43 1 63 29) #101# #2# 34842) function swank::*emacs-connection* eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2302 #:g2303 #:g2304 swank::swank-error #Y(nil nil nil (24 45 11 26 10 0 51 2 35 1 0 29) #101# #2# 34842) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 38 26 11 39 73 39 6 13 0 19 1 40 29) #101# #2# 34842) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 43 12 13 5 19 2 44 29) #101# #2# 34842) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(nil nil nil (26 11 3 39 8 13 0 19 1 4 38 144 57 5 61 1 1 13 2 34 25 12 46 26 46 1 14 27 10 0 17 28 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 29 49 30 49 27 75 48 31 10 0 45 32 57 33 60 83 75 45 34 57 5 61 1 45 15 35 34 36 3 6 1 12 11 37 3 48 37 15 35 34 41 3 6 1 12 11 37 3 48 37 13 4 19 1 42 12 34 45 12 19 2 46 44 1 36 2 44 1 10 1 45 38 13 4 13 0 19 1 47 12 13 0 19 1 48 12 19 3 49 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 62 73 29) #101# #2# 34842) #:g2306 #:g2307 #:g2308 #Y(nil nil nil (24 45 11 26 10 0 51 2 35 1 0 29) #101# #2# 34842) #Y(nil nil nil (24 45 38 26 11 39 73 39 6 13 0 19 1 40 29) #101# #2# 34842) #Y(nil nil nil (26 33 43 12 13 5 19 2 44 29) #101# #2# 34842) #Y(swank::handle-requests nil nil (24 45 1 25 40 2 77 46 2 26 13 1 34 50 12 46 26 46 1 14 27 10 0 17 28 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 29 49 30 49 27 75 48 31 10 0 45 51 57 52 60 83 75 45 53 57 5 61 1 45 15 35 34 54 3 6 1 12 11 37 3 48 37 15 35 34 55 3 6 1 12 11 37 3 48 37 13 4 19 1 42 12 34 56 12 19 2 46 44 1 36 2 44 1 10 1 45 38 13 4 13 0 19 1 47 12 13 0 19 1 48 12 19 3 49 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #101# #2# 34842) si::fset "Read and process :emacs-rex requests.
The processing is done in the extent of the toplevel restart." si::set-documentation)) #2# 34842) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 15 0 15 30 15 31 19 3 32 1 0 73 29) #102=#A(t (33) (swank::process-requests swank::timeout 0 (or (:emacs-rex . swank::_) (:emacs-channel-send . swank::_)) swank::wait-for-event swank::timeout? swank::event #:|tmp-2323| #:|op-2321| #:|rand-2322| :emacs-rex #:g2324 #:g2325 swank::args swank::eval-for-emacs apply :emacs-channel-send #:g2326 #:g2327 si::dm-too-few-arguments swank::channel #:g2328 #:g2329 swank::selector si::dm-too-many-arguments swank::channel-send #61# error #Y(swank::process-requests nil nil (24 45 1 26 58 60 193 57 2 61 1 1 15 3 13 2 19 2 4 47 1 5 45 6 10 1 39 5 75 73 36 3 10 0 45 7 10 0 4 45 8 10 1 5 45 9 10 1 42 10 25 10 0 45 11 10 0 45 12 10 0 45 13 33 14 12 13 0 19 2 15 43 3 38 115 42 16 105 10 0 45 17 10 0 45 18 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 20 10 1 76 39 6 13 2 19 1 19 10 1 4 12 10 1 5 51 1 22 45 21 10 0 45 22 10 0 76 39 6 13 4 19 1 19 10 0 4 12 10 0 5 51 0 22 45 23 10 1 45 13 10 5 39 6 13 6 19 1 24 13 4 13 1 13 0 19 3 25 43 7 38 8 15 26 13 2 19 2 27 43 3 43 2 35 0 0 62 73 63 29) #102# #2# 35277) si::fset function "Read and process requests from Emacs." si::set-documentation)) #2# 35277) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #103=#A(t (5) (swank::current-socket-io swank::*emacs-connection* swank::connection.socket-io #Y(swank::current-socket-io nil nil (26 14 1 19 1 2 29) #103# #2# 35775) si::fset)) #2# 35775) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #104=#A(t (8) (swank::close-connection swank::connection condition swank::backtrace :close-connection swank::send-to-sentinel #Y(swank::close-connection nil nil (24 45 1 24 45 2 24 45 3 26 14 4 13 2 13 1 10 0 6 4 12 19 1 5 29) #104# #2# 35852) si::fset)) #2# 35852) #Y(si::bytecodes nil nil (15 0 1 44 12 19 2 45 1 0 73 29) #105=#A(t (46) (swank::close-connection% swank::c condition swank::backtrace *debugger-hook* "close-connection: ~a ...~%" swank::log-event swank::*log-output* "~&;; swank:close-connection: ~A~%" swank::safe-condition-message swank::escape-non-ascii format swank::stop-serving-requests swank::connection.socket-io close swank::connection.dedicated-output swank::*connections* remove swank::*connection-closed-hook* swank::run-hook end-of-file typep finish-output "~&;; Event history start:~%" swank::dump-event-history "~
;; Event history end.~%~
;; Backtrace:~%~{~A~%~}~
;; Connection to Emacs lost. [~%~
;;  condition: ~A~%~
;;  type: ~S~%~
;;  style: ~S]~%" #:loop-list2338 swank::f swank::i #:loop-list-head2339 #:loop-list-tail2340 0 #60# #:g2341 #:g2342 error si::temp #Y(nil nil nil (24 45 36 26 10 0 51 2 35 1 0 29) #105# #2# 35990) si::*handler-clusters* "~d: ~a" rplacd type-of swank::connection.communication-style "close-connection ~a ... done.~%" #Y(swank::close-connection% nil nil (24 45 1 24 45 2 24 45 3 26 75 48 4 15 5 13 1 19 2 6 14 7 15 8 13 1 19 1 9 12 19 1 10 12 19 3 11 13 2 19 1 12 13 2 19 1 13 12 19 1 14 13 2 19 1 15 39 10 13 2 19 1 15 12 19 1 14 13 2 14 16 19 2 17 52 16 14 18 13 2 19 2 19 10 1 39 9 13 1 15 20 19 2 21 76 39 194 14 7 19 1 22 14 7 15 23 19 2 11 14 7 19 1 24 14 7 15 25 58 60 145 77 77 13 1 46 26 46 27 46 28 75 6 1 45 29 10 0 45 30 57 31 61 2 2 107 10 5 2 39 4 35 0 1 10 5 4 45 32 10 0 4 51 4 10 0 5 51 0 10 0 4 51 5 43 1 10 5 5 51 5 13 1 57 33 60 57 75 45 34 57 31 61 1 32 15 35 34 37 3 6 1 12 11 38 3 48 38 77 15 39 13 6 13 7 19 1 10 12 19 4 11 36 2 44 1 10 1 45 2 77 13 0 72 2 43 1 36 2 62 43 1 63 6 1 51 1 17 40 35 0 0 10 2 5 73 36 6 62 73 43 2 43 3 63 12 13 1 19 1 9 12 19 1 10 12 10 1 16 41 12 13 2 19 1 42 12 19 6 11 14 7 19 1 22 15 43 13 1 19 2 6 44 1 29) #105# #2# 35990) si::fset)) #2# 35990) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #106=#A(t (25) (swank::read-loop swank::connection swank::connection.socket-io swank::mconn.control-thread swank::control-thread swank::input-stream #:g2349 #:g2350 #:g2351 0 swank::swank-error si::temp #Y(nil nil nil (24 45 11 26 10 0 51 2 35 1 0 29) #106# #2# 37304) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 14 26 11 15 73 39 6 13 0 19 1 16 29) #106# #2# 37304) swank::decode-message swank-backend::send swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(swank::read-loop nil nil (24 45 1 26 13 0 19 1 2 12 13 0 19 1 3 12 46 4 46 5 10 2 45 6 57 7 60 92 75 45 8 57 9 61 1 54 15 10 34 12 3 6 1 12 11 13 3 48 13 15 10 34 17 3 6 1 12 11 13 3 48 13 57 9 61 1 1 13 6 13 5 19 1 18 12 19 2 19 35 0 0 62 73 44 1 36 2 44 1 10 1 45 14 13 4 13 0 19 1 20 12 13 0 19 1 21 12 19 3 22 43 1 36 2 62 73 43 1 63 43 1 43 2 29) #106# #2# 37304) si::fset)) #2# 37304) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #107=#A(t (16) (swank::dispatch-loop swank::connection swank::*emacs-connection* #:g2356 serious-condition condition swank::safe-backtrace swank::close-connection abort #Y(nil nil nil (24 45 5 26 13 1 13 0 19 0 6 12 19 3 7 13 0 19 1 8 29) #107# #2# 37606) si::*handler-clusters* 0 swank-backend::receive swank::dispatch-event #Y(swank::dispatch-loop nil nil (24 45 1 26 10 0 48 2 10 0 45 3 15 4 34 9 3 6 1 12 11 10 3 48 10 57 11 61 1 1 13 2 19 0 12 12 19 2 13 35 0 0 62 73 44 1 43 1 44 1 29) #107# #2# 37606) si::fset)) #2# 37606) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*auto-flush-interval* si::*make-special boundp 0.2)) #2# 37778) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #108=#A(t (10) (swank::auto-flush-loop stream 0 open-stream-p output-stream-p force-output swank::*auto-flush-interval* sleep #Y(swank::auto-flush-loop nil nil (24 45 1 26 58 60 38 57 2 61 1 1 10 2 16 3 39 5 10 2 16 4 76 39 5 75 73 36 1 13 2 19 1 5 11 6 16 7 35 0 0 62 73 63 29) #108# #2# 37816) si::fset)) #2# 37816) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 15 5 15 6 19 7 7 15 0 15 0 77 15 8 15 9 1 13 12 14 2 19 6 14 12 15 0 77 15 15 15 16 1 18 12 14 2 19 6 14 12 15 0 77 15 19 15 20 1 22 12 14 2 19 6 14 12 15 0 77 15 23 15 24 1 26 12 14 2 19 6 14 12 19 5 27 29) #109=#A(t (28) (swank::thread-for-evaluation :delete-methods t :lambda-list (swank::connection swank::id) :documentation "Find or create a thread to evaluate the next request." ensure-generic-function (swank::singlethreaded-connection t) (swank::connection swank::id) swank::connection swank::id swank-backend::current-thread #Y(nil nil nil (24 45 10 24 45 11 26 19 0 12 29) #109# #2# 38032) clos::install-method (t integer) (swank::connection swank::id) swank-backend::find-thread #Y(nil nil nil (24 45 10 24 45 11 26 13 0 19 1 17 29) #109# #2# 38032) (swank::multithreaded-connection (eql :find-existing)) (swank::connection swank::id) swank::mconn.active-threads #Y(nil nil nil (24 45 10 24 45 11 26 13 1 19 1 21 4 73 29) #109# #2# 38032) (swank::multithreaded-connection (eql t)) (swank::connection swank::id) swank::spawn-worker-thread #Y(nil nil nil (24 45 10 24 45 11 26 13 1 19 1 25 29) #109# #2# 38032) clos::associate-methods-to-gfun)) #2# 38032) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #110=#A(t (28) (swank::interrupt-worker-thread swank::connection swank::id t eq :find-existing swank::thread-for-evaluation swank::thread "interrupt-worker-thread: ~a ~a~%" swank::log-event #:g2361 swank::multithreaded-connection typep swank::simple-break swank::invoke-or-queue-interrupt #Y(nil nil nil (26 33 13 12 19 1 14 29) #110# #2# 38530) swank-backend::interrupt-thread swank::singlethreaded-connection (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error :debug-condition swank::current-thread-id "Thread with id ~a not found" format swank::current-socket-io swank::encode-message #Y(swank::interrupt-worker-thread nil nil (24 45 1 24 45 2 26 13 1 13 0 11 3 17 4 39 6 11 5 73 38 4 10 0 73 12 19 2 6 45 7 15 8 13 1 13 0 19 3 9 10 0 39 48 10 2 45 10 13 0 15 11 19 2 12 39 11 13 1 34 15 12 19 2 16 38 21 13 0 15 17 19 2 12 39 6 19 0 13 38 7 13 0 1 18 17 19 43 1 38 25 14 20 19 0 21 12 77 15 22 13 1 19 3 23 6 3 12 19 0 24 12 19 2 25 43 1 29) #110# #2# 38530) si::fset)) #2# 38530) #Y(si::bytecodes nil nil (15 0 1 56 12 19 2 57 1 0 73 29) #111=#A(t (58) (swank::spawn-worker-thread swank::connection swank::*default-worker-thread-bindings* #:g2370 #:g2371 0 :name abort :function si::temp #Y(nil nil nil (27 45 9 10 0 51 2 35 1 0 29) #111# #2# 39424) :report-function stream #100# write-string #Y(nil nil nil (24 45 12 26 15 13 13 0 19 2 14 29) #111# #2# 39424) si::make-restart si::*restart-clusters* find-restart swank::*sldb-quit-restart* swank::eval-for-emacs (:emacs-rex . swank::_) swank::wait-for-event apply swank::v swank::force-user-output #Y(nil nil nil (25 40 2 77 46 24 26 19 0 25 75 73 29) #111# #2# 39424) #Y(nil nil nil (26 57 3 60 75 75 45 4 57 5 61 1 52 14 6 15 7 14 8 34 10 12 14 11 34 15 12 19 6 16 6 1 12 11 17 3 48 17 15 7 19 1 18 48 19 33 20 12 15 21 19 1 22 5 12 19 2 23 44 1 36 2 44 1 34 26 12 13 1 19 2 23 36 2 62 73 43 1 63 29) #111# #2# 39424) function swank::*emacs-connection* eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2374 #:g2375 #:g2376 swank::swank-error #Y(nil nil nil (24 45 9 26 10 0 51 2 35 1 0 29) #111# #2# 39424) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 40 26 11 41 73 39 6 13 0 19 1 42 29) #111# #2# 39424) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 45 12 13 5 19 2 46 29) #111# #2# 39424) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(nil nil nil (26 13 0 34 27 12 46 28 46 1 14 29 10 0 17 30 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 31 49 32 49 29 75 48 33 10 0 45 34 57 35 60 83 75 45 36 57 5 61 1 45 15 37 34 38 3 6 1 12 11 39 3 48 39 15 37 34 43 3 6 1 12 11 39 3 48 39 13 4 19 1 44 12 34 47 12 19 2 48 44 1 36 2 44 1 10 1 45 40 13 4 13 0 19 1 49 12 13 0 19 1 50 12 19 3 51 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #111# #2# 39424) #Y(nil nil nil (26 14 2 34 52 12 19 2 48 29) #111# #2# 39424) "worker" swank-backend::spawn #Y(swank::spawn-worker-thread nil nil (24 45 1 26 34 53 12 14 6 15 54 19 3 55 29) #111# #2# 39424) si::fset)) #2# 39424) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #112=#A(t (16) (swank::add-active-thread swank::connection swank::thread #:g2382 swank::multithreaded-connection typep #:g2385 #:g2383 swank::mconn.active-threads #:g2384 si::structure-set swank::singlethreaded-connection (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::add-active-thread nil nil (24 45 1 24 45 2 26 10 1 45 3 13 0 15 4 19 2 5 39 34 10 1 45 6 10 3 45 7 13 1 13 0 19 1 8 3 45 9 13 1 15 4 9 17 13 0 19 4 10 43 3 38 20 13 0 15 11 19 2 5 39 5 75 73 38 7 13 0 1 12 17 13 43 1 29) #112# #2# 39740) si::fset)) #2# 39740) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #113=#A(t (17) (swank::remove-active-thread swank::connection swank::thread #:g2389 swank::multithreaded-connection typep #:g2390 swank::mconn.active-threads :count delete #:g2391 si::structure-set swank::singlethreaded-connection (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::remove-active-thread nil nil (24 45 1 24 45 2 26 10 1 45 3 13 0 15 4 19 2 5 39 39 10 2 45 6 13 2 13 3 19 1 7 12 14 8 9 1 19 4 9 45 10 13 1 15 4 9 17 13 0 19 4 11 43 1 43 1 38 20 13 0 15 12 19 2 5 39 5 75 73 38 7 13 0 1 13 17 14 43 1 29) #113# #2# 39935) si::fset)) #2# 39935) #Y(si::bytecodes nil nil (15 0 1 82 12 19 2 83 15 0 15 84 15 85 19 3 86 1 0 73 29) #114=#A(t (87) (swank::dispatch-event swank::connection swank::event "dispatch-event: ~s~%" swank::log-event #:|tmp-2411| #:|op-2409| #:|rand-2410| :emacs-rex #:g2412 #:g2413 si::dm-too-few-arguments swank::form package swank-backend::thread-id swank::id si::dm-too-many-arguments swank::thread-for-evaluation swank::thread swank::add-active-thread swank::send-event :invalid-rpc "Thread not found: ~s" format swank::current-socket-io swank::encode-message :return #:g2414 #:g2415 swank::args swank::remove-active-thread :emacs-interrupt #:g2416 #:g2417 swank::interrupt-worker-thread :write-string :debug :debug-condition :debug-activate :debug-return :channel-send :presentation-start :presentation-end :new-package :new-features :ed :indentation-update :eval :eval-no-wait :background-message :inspect :ping :y-or-n-p :read-from-minibuffer :read-string :read-aborted :test-delay #:g2418 #:g2419 swank::_ :emacs-pong :emacs-return :emacs-return-string #:g2420 #:g2421 swank-backend::find-thread :emacs-channel-send #:g2422 #:g2423 swank::channel-id swank::msg swank::find-channel swank::ch swank::channel-thread :reader-error #:g2424 #:g2425 swank::packet condition swank::safe-condition-message #61# error #Y(swank::dispatch-event nil nil (24 45 1 24 45 2 26 15 3 13 0 19 2 4 10 0 45 5 10 0 4 45 6 10 1 5 45 7 10 1 42 8 172 10 0 45 9 10 0 45 10 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 12 10 1 76 39 6 13 2 19 1 11 10 1 4 12 10 1 5 51 1 22 45 13 10 2 76 39 6 13 3 19 1 11 10 2 4 12 10 2 5 51 2 22 45 14 10 3 76 39 6 13 4 19 1 11 10 3 4 12 10 3 5 51 3 22 45 15 10 4 39 6 13 5 19 1 16 13 10 13 1 19 2 17 45 18 10 0 39 26 13 11 13 0 19 2 19 13 0 14 8 13 4 13 3 10 1 6 4 12 19 2 20 38 23 14 21 13 1 77 15 22 13 2 19 3 23 6 3 12 19 0 24 12 19 2 25 43 1 43 6 38 460 42 26 60 10 0 45 27 10 0 45 28 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 18 10 1 45 29 13 8 13 1 19 2 30 14 26 10 0 7 2 12 19 0 24 12 19 2 25 43 4 38 398 42 31 51 10 0 45 32 10 0 45 33 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 14 10 1 39 6 13 2 19 1 16 13 7 13 0 19 2 34 43 3 38 345 41 35 64 41 36 61 41 37 58 41 38 55 41 39 52 41 40 49 41 41 46 41 42 43 41 43 40 41 44 37 41 45 34 41 46 31 41 47 28 41 48 25 41 49 22 41 50 19 41 51 16 41 52 13 41 53 10 41 54 7 41 55 4 42 56 26 10 0 45 57 10 0 45 58 10 0 45 59 13 6 19 0 24 12 19 2 25 43 3 38 254 41 60 7 41 61 4 42 62 56 10 0 45 63 10 0 45 64 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 14 10 1 45 29 13 1 19 1 65 12 10 7 4 12 10 0 3 12 19 2 20 43 4 38 190 42 66 93 10 0 45 67 10 0 45 68 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 69 10 1 76 39 6 13 2 19 1 11 10 1 4 12 10 1 5 51 1 22 45 70 10 2 39 6 13 3 19 1 16 13 1 19 1 71 45 72 13 0 19 1 73 12 14 66 13 0 10 1 6 3 12 19 2 20 43 1 43 4 38 95 42 74 85 10 0 45 75 10 0 45 76 10 0 76 39 6 13 1 19 1 11 10 0 4 12 10 0 5 51 0 22 45 77 10 1 76 39 6 13 2 19 1 11 10 1 4 12 10 1 5 51 1 22 45 78 10 2 39 6 13 3 19 1 16 14 74 13 1 13 0 19 1 79 6 3 12 19 0 24 12 19 2 25 43 4 38 8 15 80 13 2 19 2 81 43 3 29) #114# #2# 40196) si::fset function "Handle an event triggered either by Emacs or within Lisp." si::set-documentation)) #2# 40196) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #115=#A(t (27) (swank::send-event swank::thread swank::event "send-event: ~s ~s~%" swank::log-event swank::*emacs-connection* swank::c #:g2431 swank::multithreaded-connection typep swank-backend::send swank::singlethreaded-connection #:g2432 swank::sconn.event-queue nconc #:g2433 si::structure-set #:g2434 swank::sconn.events-enqueued 1+ most-positive-fixnum mod #:g2435 (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::send-event nil nil (24 45 1 24 45 2 26 15 3 13 1 13 0 19 3 4 11 5 45 6 10 0 45 7 13 0 15 8 19 2 9 39 10 13 3 13 2 19 2 10 38 86 13 0 15 11 19 2 9 39 71 10 1 45 12 13 2 19 1 13 12 10 3 6 1 12 19 2 14 45 15 13 1 15 11 9 13 13 0 19 4 16 43 1 43 1 10 1 45 17 13 2 19 1 18 16 19 12 11 20 17 21 45 22 13 1 15 11 9 14 13 0 19 4 16 43 1 43 1 38 7 13 0 1 23 17 24 43 1 43 1 29) #115# #2# 42014) si::fset)) #2# 42014) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #116=#A(t (20) (swank::send-to-emacs swank::event swank::*slime-interrupts-enabled* swank::*emacs-connection* swank::c #:g2437 swank::multithreaded-connection typep swank::mconn.control-thread swank-backend::send swank::singlethreaded-connection swank::dispatch-event (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error swank::maybe-slow-down #Y(swank::send-to-emacs nil nil (24 45 1 26 75 48 2 11 3 45 4 10 0 45 5 13 0 15 6 19 2 7 39 14 13 1 19 1 8 12 13 2 19 2 9 38 25 13 0 15 10 19 2 7 39 10 13 1 13 2 19 2 11 38 7 13 0 1 12 17 13 43 1 19 0 14 43 1 44 1 29) #116# #2# 42480) si::fset function "Send EVENT to Emacs." si::set-documentation)) #2# 42480) #Y(si::bytecodes nil nil (15 0 8 100 17 1 1 0 73 29) #A(t (2) (swank::send-counter-limit si::*make-constant)) #2# 42850) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #117=#A(t (10) (swank::maybe-slow-down #:g2442 swank::*send-counter* + swank::counter swank::send-counter-limit < swank::ping-pong #Y(swank::maybe-slow-down nil nil (26 8 1 45 1 14 2 13 0 19 2 3 52 2 43 1 45 4 14 5 13 0 19 2 6 73 39 8 8 0 52 2 19 0 7 43 1 29) #117# #2# 43058) si::fset)) #2# 43058) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #118=#A(t (11) (swank::ping-pong swank::make-tag swank::tag :emacs-pong swank::pattern :ping swank::current-thread-id swank::send-to-emacs swank::wait-for-event #Y(swank::ping-pong nil nil (26 19 0 1 45 2 14 3 10 0 6 2 45 4 14 5 19 0 6 12 10 1 6 3 12 19 1 7 13 0 19 1 8 43 2 29) #118# #2# 43224) si::fset)) #2# 43224) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #119=#A(t (24) (swank::wait-for-event swank::pattern swank::timeout "wait-for-event: ~s ~s~%" swank::log-event swank::*slime-interrupts-enabled* swank::*emacs-connection* swank::c #:g2445 swank::multithreaded-connection typep swank::e swank::event-match-p #Y(nil nil nil (24 45 11 26 13 0 13 4 19 2 12 29) #119# #2# 43403) swank-backend::receive-if swank::singlethreaded-connection swank::wait-for-event/event-loop (swank::multithreaded-connection swank::singlethreaded-connection) si::etypecase-error #Y(swank::wait-for-event nil nil (24 45 1 25 40 2 77 46 2 26 15 3 13 1 13 0 19 3 4 75 48 5 11 6 45 7 10 0 45 8 13 0 15 9 19 2 10 39 11 34 13 12 13 2 19 2 14 38 27 13 0 15 15 19 2 10 39 12 13 1 13 3 13 2 19 3 16 38 7 13 0 1 17 17 18 43 1 43 1 44 1 29) #119# #2# 43403) si::fset function "Scan the event queue for PATTERN and return the event.
If TIMEOUT is 'nil wait until a matching event is enqued.
If TIMEOUT is 't only scan the queue without waiting.
The second return value is t if the timeout expired before a matching
event was found." si::set-documentation)) #2# 43403) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #120=#A(t (25) (swank::wait-for-event/event-loop swank::connection swank::pattern swank::timeout (or (not swank::timeout) (eq swank::timeout t)) si::assert-failure t eq 0 swank-backend::check-slime-interrupts swank::poll-for-event swank::event swank::sconn.events-enqueued swank::current-socket-io swank-backend::wait-for-input swank::ready swank::events-enqueued /= :interrupt (equal swank::ready (list (swank::current-socket-io))) equal swank::decode-message swank::dispatch-event #Y(swank::wait-for-event/event-loop nil nil (24 45 1 24 45 2 24 45 3 26 38 6 15 4 19 1 5 10 0 76 40 7 13 0 11 6 17 7 76 40 -18 58 60 131 57 8 61 1 1 19 0 9 13 4 13 3 19 2 10 45 11 10 0 39 7 10 0 4 73 36 2 43 1 13 4 19 1 12 12 19 0 13 6 1 12 13 2 19 2 14 12 46 15 46 16 10 4 39 4 10 1 76 39 10 77 14 6 72 2 36 3 38 54 13 0 13 6 19 1 12 12 19 2 17 40 7 13 1 11 18 17 7 40 33 38 6 15 19 19 1 5 13 1 19 0 13 6 1 17 20 76 40 -16 13 6 19 0 13 12 19 1 21 12 19 2 22 43 2 35 0 0 62 73 63 29) #120# #2# 44066) si::fset)) #2# 44066) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #121=#A(t (18) (swank::poll-for-event swank::connection swank::pattern swank::c swank::e swank::event-match-p #Y(nil nil nil (24 45 4 26 13 0 13 2 19 2 5 29) #121# #2# 44912) swank::sconn.event-queue member-if swank::tail #:g2450 ldiff nconc #:g2451 swank::singlethreaded-connection si::structure-set #Y(swank::poll-for-event nil nil (24 45 1 24 45 2 26 10 1 45 3 34 6 12 13 0 19 1 7 12 19 2 8 45 9 10 0 73 39 43 10 1 45 10 13 2 19 1 7 12 10 1 17 11 12 10 1 5 12 19 2 12 45 13 13 1 15 14 9 13 13 0 19 4 15 43 1 43 1 10 0 73 43 2 29) #121# #2# 44912) si::fset)) #2# 44912) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #122=#A(t (20) (swank::event-match-p swank::event swank::pattern keywordp numberp stringp (nil t) member equal symbolp t consp or swank::p #Y(nil nil nil (24 45 13 26 13 2 13 0 19 2 0 29) #122# #2# 45237) some "Invalid pattern: ~S" error #Y(swank::event-match-p nil nil (24 45 1 24 45 2 26 10 0 16 3 40 20 10 0 16 4 40 14 10 0 16 5 40 8 13 0 15 6 19 2 7 39 9 13 1 10 0 17 8 38 77 10 0 16 9 39 6 11 10 73 38 66 10 0 16 11 39 53 10 0 4 42 12 13 34 14 12 10 0 5 12 19 2 15 38 33 10 1 16 11 73 39 26 10 1 4 12 10 0 4 12 19 2 0 73 39 12 10 1 5 12 10 0 5 12 19 2 0 38 8 15 16 13 0 19 2 17 29) #122# #2# 45237) si::fset)) #2# 45237) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #123=#A(t (13) (swank::spawn-threads-for-connection swank::connection #:g2454 swank::control-thread #Y(nil nil nil (26 13 1 19 1 3 29) #123# #2# 45821) :name "control-thread" swank-backend::spawn #:g2455 swank::multithreaded-connection si::structure-set #Y(swank::spawn-threads-for-connection nil nil (24 45 1 26 10 0 45 2 34 4 12 14 5 15 6 19 3 7 45 8 13 1 15 9 9 13 13 0 19 4 10 43 1 43 1 10 0 73 29) #123# #2# 45821) si::fset)) #2# 45821) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #124=#A(t (23) (swank::control-thread swank::connection #:g2466 #:g2470 swank-backend::current-thread #:g2471 swank::multithreaded-connection si::structure-set #:g2472 swank::read-loop #Y(nil nil nil (26 13 2 19 1 9 29) #124# #2# 46033) :name "reader-thread" swank-backend::spawn #:g2473 #:g2474 swank::indentation-cache-loop #Y(nil nil nil (26 13 2 19 1 16 29) #124# #2# 46033) "swank-indentation-cache-thread" #:g2475 swank::dispatch-loop #Y(swank::control-thread nil nil (24 45 1 26 10 0 45 2 10 0 45 3 19 0 4 45 5 13 1 15 6 9 13 13 0 19 4 7 43 1 43 1 10 0 45 8 34 10 12 14 11 15 12 19 3 13 45 14 13 1 15 6 9 12 13 0 19 4 7 43 1 43 1 10 0 45 15 34 17 12 14 11 15 18 19 3 13 45 19 13 1 15 6 9 16 13 0 19 4 7 43 1 43 1 13 1 19 1 20 43 1 29) #124# #2# 46033) si::fset)) #2# 46033) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #125=#A(t (17) (swank::cleanup-connection-threads swank::connection swank::c swank::mconn.repl-thread swank::mconn.reader-thread swank::mconn.control-thread swank::mconn.auto-flush-thread swank::mconn.indentation-cache-thread swank::threads si::%dolist-var swank::thread swank-backend::thread-alive-p swank-backend::current-thread equal swank-backend::kill-thread #Y(swank::cleanup-connection-threads nil nil (24 45 1 26 10 0 45 2 13 0 19 1 3 12 13 0 19 1 4 12 13 0 19 1 5 12 13 0 19 1 6 12 13 0 19 1 7 6 5 45 8 10 0 45 9 75 45 10 38 38 10 1 4 51 0 10 0 39 17 13 0 19 1 11 39 10 19 0 12 12 10 0 17 13 76 39 6 13 0 19 1 14 10 1 5 51 1 10 1 40 -40 75 73 43 2 43 2 29) #125# #2# 46489) si::fset)) #2# 46489) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #126=#A(t (10) (swank::install-sigio-handler swank::connection swank::connection.socket-io swank::process-io-interrupt #Y(nil nil nil (26 13 0 19 1 3 29) #126# #2# 47014) swank-backend::add-sigio-handler t swank::handle-requests #Y(swank::install-sigio-handler nil nil (24 45 1 26 13 0 19 1 2 12 34 4 12 19 2 5 13 0 14 6 19 2 7 29) #126# #2# 47014) si::fset)) #2# 47014) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (swank::*io-interupt-level* si::*make-special boundp)) #2# 47247) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #127=#A(t (13) (swank::process-io-interrupt swank::connection "process-io-interrupt ~d ...~%" swank::*io-interupt-level* swank::log-event 1+ t swank::handle-requests #Y(nil nil nil (26 13 0 14 6 19 2 7 29) #127# #2# 47281) swank::invoke-or-queue-interrupt "process-io-interrupt ~d ... done ~%" #Y(swank::process-io-interrupt nil nil (24 45 1 26 15 2 14 3 19 2 4 11 3 16 5 48 3 34 8 12 19 1 9 44 1 15 10 14 3 19 2 4 29) #127# #2# 47281) si::fset)) #2# 47281) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #128=#A(t (9) (swank::deinstall-sigio-handler swank::connection "deinstall-sigio-handler...~%" swank::log-event swank::connection.socket-io swank-backend::remove-sigio-handlers "deinstall-sigio-handler...done~%" #Y(swank::deinstall-sigio-handler nil nil (24 45 1 26 15 2 19 1 3 13 0 19 1 4 12 19 1 5 15 6 19 1 3 29) #128# #2# 47606) si::fset)) #2# 47606) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #129=#A(t (18) (swank::install-fd-handler swank::connection swank::connection.socket-io t swank::handle-requests #Y(nil nil nil (26 13 0 14 3 19 2 4 29) #129# #2# 47811) swank-backend::add-fd-handler #:g2478 swank::dispatch-interrupt-event #Y(nil nil nil (26 13 1 19 1 8 29) #129# #2# 47811) swank::invoke-or-queue-interrupt #Y(nil nil nil (26 34 9 12 19 1 10 29) #129# #2# 47811) swank-backend::install-sigint-handler #:g2479 swank::singlethreaded-connection si::structure-set #Y(swank::install-fd-handler nil nil (24 45 1 26 13 0 19 1 2 12 34 5 12 19 2 6 10 0 45 7 34 11 12 19 1 12 45 13 13 1 15 14 9 12 13 0 19 4 15 43 1 43 1 13 0 14 3 19 2 4 29) #129# #2# 47811) si::fset)) #2# 47811) #Y(si::bytecodes nil nil (15 0 1 32 12 19 2 33 1 0 73 29) #130=#A(t (34) (swank::dispatch-interrupt-event swank::connection :emacs-interrupt swank::current-thread-id swank::dispatch-event #Y(nil nil nil (26 13 0 14 2 19 0 3 6 2 12 19 2 4 29) #130# #2# 48246) function swank::*emacs-connection* eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2484 #:g2485 #:g2486 0 swank::swank-error si::temp #Y(nil nil nil (24 45 17 26 10 0 51 2 35 1 0 29) #130# #2# 48246) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 20 26 11 21 73 39 6 13 0 19 1 22 29) #130# #2# 48246) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 25 12 13 5 19 2 26 29) #130# #2# 48246) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(swank::dispatch-interrupt-event nil nil (24 45 1 26 13 0 34 5 12 46 6 46 1 14 7 10 0 17 8 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 9 49 10 49 7 75 48 11 10 0 45 12 57 13 60 83 75 45 14 57 15 61 1 45 15 16 34 18 3 6 1 12 11 19 3 48 19 15 16 34 23 3 6 1 12 11 19 3 48 19 13 4 19 1 24 12 34 27 12 19 2 28 44 1 36 2 44 1 10 1 45 20 13 4 13 0 19 1 29 12 13 0 19 1 30 12 19 3 31 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #130# #2# 48246) si::fset)) #2# 48246) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #131=#A(t (10) (swank::deinstall-fd-handler swank::connection "deinstall-fd-handler~%" swank::log-event swank::connection.socket-io swank-backend::remove-fd-handlers swank::sconn.saved-sigint-handler swank-backend::install-sigint-handler #Y(swank::deinstall-fd-handler nil nil (24 45 1 26 15 2 19 1 3 13 0 19 1 4 12 19 1 5 13 0 19 1 6 12 19 1 7 29) #131# #2# 48403) si::fset)) #2# 48403) #Y(si::bytecodes nil nil (15 0 1 75 12 19 2 76 1 0 73 29) #132=#A(t (77) (swank::simple-serve-requests swank::connection swank::dispatch-interrupt-event #Y(nil nil nil (26 13 0 19 1 2 29) #132# #2# 48614) swank::invoke-or-queue-interrupt #Y(nil nil nil (26 34 3 12 19 1 4 29) #132# #2# 48614) #:g2504 #:g2505 0 :name swank::close-connection :function si::temp #Y(nil nil nil (27 45 12 10 0 51 2 35 1 0 29) #132# #2# 48614) :report-function stream "Close SLIME connection." format #Y(nil nil nil (24 45 15 26 13 0 15 16 19 2 17 29) #132# #2# 48614) si::make-restart si::*restart-clusters* *standard-input* swank::real-input-stream swank::stdin swank::make-repl-input-stream #:g2508 #:g2509 abort #Y(nil nil nil (27 45 12 10 0 51 2 35 1 0 29) #132# #2# 48614) #100# write-string #Y(nil nil nil (24 45 15 26 15 29 13 0 19 2 30 29) #132# #2# 48614) find-restart swank::*sldb-quit-restart* swank::simple-repl swank::v swank::force-user-output #Y(nil nil nil (25 40 2 77 46 35 26 19 0 36 35 4 0 29) #132# #2# 48614) apply #Y(nil nil nil (26 57 25 60 65 75 45 26 57 8 61 1 42 14 9 15 27 14 11 34 28 12 14 14 34 31 12 19 6 19 6 1 12 11 20 3 48 20 15 27 19 1 32 48 33 19 0 34 44 1 36 2 44 1 34 37 12 13 1 19 2 38 36 2 62 73 43 1 63 29) #132# #2# 48614) function swank::*emacs-connection* eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2512 #:g2513 #:g2514 swank::swank-error #Y(nil nil nil (24 45 12 26 10 0 51 2 35 1 0 29) #132# #2# 48614) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 52 26 11 53 73 39 6 13 0 19 1 54 29) #132# #2# 48614) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 57 12 13 5 19 2 58 29) #132# #2# 48614) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace t #Y(nil nil nil (26 77 14 63 72 2 29) #132# #2# 48614) #Y(nil nil nil (26 57 6 60 216 75 45 7 57 8 61 1 193 14 9 15 10 14 11 34 13 12 14 14 34 18 12 19 6 19 6 1 12 11 20 3 48 20 14 21 19 1 22 45 23 13 4 13 0 19 2 24 48 21 57 8 61 1 1 13 5 34 39 12 46 40 46 1 14 41 10 0 17 42 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 43 49 44 49 41 75 48 45 10 0 45 46 57 47 60 83 75 45 48 57 8 61 1 45 15 49 34 50 3 6 1 12 11 51 3 48 51 15 49 34 55 3 6 1 12 11 51 3 48 51 13 4 19 1 56 12 34 59 12 19 2 60 44 1 36 2 44 1 10 1 45 52 13 4 13 0 19 1 61 12 13 0 19 1 62 12 19 3 10 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 62 73 43 1 44 1 36 2 44 1 34 64 12 13 1 19 2 38 36 2 62 73 43 1 63 29) #132# #2# 48614) swank-backend::call-with-user-break-handler #Y(nil nil nil (26 34 5 12 34 65 12 19 2 66 29) #132# #2# 48614) #:g2516 #:g2517 #:g2518 #Y(nil nil nil (24 45 12 26 10 0 51 2 35 1 0 29) #132# #2# 48614) #Y(nil nil nil (24 45 52 26 11 53 73 39 6 13 0 19 1 54 29) #132# #2# 48614) #Y(nil nil nil (26 33 57 12 13 5 19 2 58 29) #132# #2# 48614) swank::safe-backtrace #Y(swank::simple-serve-requests nil nil (24 45 1 26 64 138 13 0 34 67 12 46 40 46 1 14 41 10 0 17 42 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 43 49 44 49 41 75 48 45 10 0 45 68 57 69 60 83 75 45 70 57 8 61 1 45 15 49 34 71 3 6 1 12 11 51 3 48 51 15 49 34 72 3 6 1 12 11 51 3 48 51 13 4 19 1 56 12 34 73 12 19 2 60 44 1 36 2 44 1 10 1 45 52 13 4 13 0 19 1 61 12 13 0 19 1 62 12 19 3 10 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 65 13 0 77 19 0 74 12 19 3 10 66 29) #132# #2# 48614) si::fset)) #2# 48614) #Y(si::bytecodes nil nil (15 0 15 1 77 77 19 4 2 1 0 73 29) #A(t (3) (swank::end-of-repl-input (end-of-file) clos::load-defclass)) #2# 49439) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #133=#A(t (36) (swank::simple-repl 0 t "~a> " *package* swank::package-string-for-prompt format force-output #:g2525 #:g2526 swank::end-of-repl-input si::temp #Y(nil nil nil (24 45 11 26 35 1 0 29) #133# #2# 49632) si::*handler-clusters* read swank::form list eval values - ** *** * // /// / ++ +++ + "; No values~&" swank::v "~s~&" #Y(nil nil nil (24 45 30 26 14 2 15 31 13 0 19 3 6 29) #133# #2# 49632) mapc #Y(swank::simple-repl nil nil (26 58 60 153 57 1 61 1 1 14 2 15 3 14 4 19 1 5 12 19 3 6 19 0 7 57 8 60 39 75 45 9 57 1 61 1 21 15 10 34 12 3 6 1 12 11 13 3 48 13 19 0 14 36 2 44 1 75 73 36 4 36 2 62 43 1 63 45 15 13 0 15 16 10 0 16 17 69 21 23 12 46 18 49 19 11 20 52 21 11 22 52 20 10 0 4 52 22 11 23 52 24 11 25 52 23 10 0 52 25 11 26 52 27 11 28 52 26 10 1 52 28 10 0 76 39 10 14 2 15 29 19 2 6 38 9 34 32 12 13 0 19 2 33 43 1 44 1 43 1 35 0 0 62 73 63 29) #133# #2# 49632) si::fset)) #2# 49632) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #134=#A(t (8) (swank::make-repl-input-stream swank::connection swank::stdin swank::repl-input-stream-read #Y(nil nil nil (26 13 1 13 0 19 2 3 29) #134# #2# 50155) swank-backend::make-input-stream #Y(swank::make-repl-input-stream nil nil (24 45 1 24 45 2 26 34 4 12 19 1 5 29) #134# #2# 50155) si::fset)) #2# 50155) #Y(si::bytecodes nil nil (15 0 1 39 12 19 2 40 1 0 73 29) #135=#A(t (41) (swank::repl-input-stream-read swank::connection swank::stdin 0 swank::connection.socket-io swank::socket swank::inputs swank-backend::wait-for-input swank::ready :interrupt eq swank-backend::check-slime-interrupts member #:g2534 #:g2535 :name swank::process-input :function si::temp #Y(nil nil nil (27 45 18 10 0 51 2 35 1 0 29) #135# #2# 50289) :report-function stream "Continue reading input." format #Y(nil nil nil (24 45 21 26 13 0 15 22 19 2 23 29) #135# #2# 50289) si::make-restart si::*restart-clusters* find-restart swank::*sldb-quit-restart* swank::connection.env t swank::handle-requests #Y(nil nil nil (26 13 9 14 30 19 2 31 29) #135# #2# 50289) swank::call-with-bindings #Y(nil nil nil (26 77 14 30 72 2 29) #135# #2# 50289) apply swank::read-non-blocking (null swank::ready) si::assert-failure #Y(swank::repl-input-stream-read nil nil (24 45 1 24 45 2 26 58 60 167 57 3 61 1 1 13 3 19 1 4 45 5 13 0 10 3 6 2 45 6 13 0 19 1 7 45 8 13 0 11 9 17 10 39 6 19 0 11 38 119 13 2 13 0 19 2 12 39 79 57 13 60 73 75 45 14 57 3 61 1 51 14 15 15 16 14 17 34 19 12 14 20 34 24 12 19 6 25 6 1 12 11 26 3 48 26 15 16 19 1 27 48 28 13 9 19 1 29 12 34 32 12 19 2 33 44 1 36 2 44 1 34 34 12 13 1 19 2 35 36 2 62 43 1 63 38 32 13 5 13 0 19 2 12 39 10 13 5 19 1 36 36 4 38 14 38 6 15 37 19 1 38 10 0 76 76 40 -10 43 3 35 0 0 62 73 63 29) #135# #2# 50289) si::fset)) #2# 50289) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #136=#A(t (20) (swank::read-non-blocking stream make-string-output-stream swank::str #:g2542 #:g2543 0 end-of-file si::temp #Y(nil nil nil (24 45 8 26 35 1 0 29) #136# #2# 51200) si::*handler-clusters* read-char-no-hang swank::c write-char swank::end-of-repl-input :stream error get-output-stream-string #Y(swank::read-non-blocking nil nil (24 45 1 26 19 0 2 45 3 57 4 60 80 75 45 5 57 6 61 1 57 15 7 34 9 3 6 1 12 11 10 3 48 10 58 60 37 57 6 61 1 1 13 6 19 1 11 45 12 10 0 76 39 5 75 73 36 2 13 0 13 6 19 2 13 43 1 35 0 0 62 73 63 36 2 44 1 15 14 14 15 13 4 19 3 16 36 2 62 43 1 63 10 0 16 17 43 1 29) #136# #2# 51200) si::fset)) #2# 51200) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*channels* si::*make-special boundp)) #2# 51486) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (swank::*channel-counter* si::*make-special boundp)) #2# 51580) #Y(si::bytecodes nil nil (15 0 77 15 1 14 2 1 4 12 1 5 7 3 12 1 6 6 3 12 77 19 4 7 29) #137=#A(t (8) (swank::channel (:readers (swank::channel-id) :name swank::id) :initfunction swank-backend::current-thread #Y(nil nil nil (26 19 0 3 29) #137# #2# 51610) (:readers (swank::channel-thread) :initform (swank-backend::current-thread) :initargs (:thread) :name swank::thread) (:initform nil :initargs (:name) :name swank::name) clos::load-defclass)) #2# 51610) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 1 20 12 14 21 19 6 22 29) #138=#A(t (23) (initialize-instance (:after) (swank::channel) (swank::ch &key) swank::ch (t) #139=#:g2573 #:g2575 #:g2574 (slot-value #139# 'swank::id) #:g2576 swank::id #:g2577 #:g2580 swank::*channel-counter* + #:g2578 (setf slot-value) slot-value swank::*channels* #Y(nil nil nil (24 45 4 28 5 10 0 45 6 10 0 45 10 1 11 45 12 8 1 45 13 14 14 13 0 19 2 15 52 14 43 1 45 16 13 0 13 2 13 1 33 17 18 3 43 1 43 2 13 0 1 11 17 18 12 10 1 3 12 11 19 3 52 19 73 43 1 29) #138# #2# 51784) t clos::install-method)) #2# 51784) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 20 12 14 18 19 6 21 29) #140=#A(t (22) (print-object (swank::channel t) (swank::c stream) swank::c stream #141=#:g2617 #:g2619 #:g2618 (slot-value #141# 'swank::id) #:g2621 #:g2620 (slot-value #141# 'swank::name) "~d ~a" swank::id slot-value swank::name format #Y(si::.print-unreadable-object-body. nil nil (26 10 1 45 5 13 1 15 12 13 0 1 13 17 14 12 13 0 1 15 17 14 12 19 4 16 43 1 29) #140# #2# 51946) t si::print-unreadable-object-function #Y(nil nil nil (24 45 3 24 45 4 26 30 1 17 13 2 13 1 14 18 77 32 0 12 19 5 19 43 1 29) #140# #2# 51946) clos::install-method)) #2# 51946) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #142=#A(t (6) (swank::find-channel swank::id swank::*channels* assoc #Y(swank::find-channel nil nil (24 45 1 26 13 0 14 2 19 2 3 5 73 29) #142# #2# 52112) si::fset)) #2# 52112) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 29) #A(t (6) (swank::channel-send :delete-methods t :lambda-list (swank::channel swank::selector swank::args) ensure-generic-function)) #2# 52172) #Y(si::bytecodes nil nil (15 0 1 16 12 14 17 9 3 19 4 18 1 0 73 29) #143=#A(t (19) (swank::define-channel-method #:g2623 #:g2622 #:g2624 si::dm-too-few-arguments swank::selector #:g2625 #:g2626 swank::channel swank::args swank::body defmethod swank::channel-send eql quote destructuring-bind #Y(swank::define-channel-method nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 0 45 7 10 0 76 39 6 13 5 19 1 4 10 0 4 12 10 0 5 51 0 22 45 8 10 1 45 9 10 5 45 10 15 11 15 12 13 2 15 5 15 13 15 14 10 5 6 2 6 2 6 2 12 1 9 6 3 12 15 15 13 1 15 9 10 0 7 4 6 4 73 29) #143# #2# 52225) t si::fset)) #2# 52225) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #144=#A(t (7) (swank::send-to-remote-channel swank::channel-id swank::msg :channel-send swank::send-to-emacs #Y(swank::send-to-remote-channel nil nil (24 45 1 24 45 2 26 14 3 13 1 10 0 6 3 12 19 1 4 29) #144# #2# 52431) si::fset)) #2# 52431) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*slime-features* si::*make-special boundp variable "The feature list that has been sent to Emacs." si::set-documentation)) #2# 52535) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #145=#A(t (5) (swank::send-oob-to-emacs swank::object swank::send-to-emacs #Y(swank::send-oob-to-emacs nil nil (24 45 1 26 13 0 19 1 2 29) #145# #2# 52624) si::fset)) #2# 52624) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #146=#A(t (6) (swank::force-user-output swank::*emacs-connection* swank::connection.user-io force-output #Y(swank::force-user-output nil nil (26 14 1 19 1 2 12 19 1 3 29) #146# #2# 52688) si::fset)) #2# 52688) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::force-user-output swank::*pre-reply-hook* adjoin)) #2# 52816) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #147=#A(t (6) (swank::clear-user-input swank::*emacs-connection* swank::connection.user-input clear-input #Y(swank::clear-user-input nil nil (26 14 1 19 1 2 12 19 1 3 29) #147# #2# 52866) si::fset)) #2# 52866) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (swank::*tag-counter* si::*make-special boundp)) #2# 52996) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #148=#A(t (7) (swank::make-tag swank::*tag-counter* 1+ expt mod #Y(swank::make-tag nil nil (26 11 1 16 2 12 9 2 8 22 17 3 17 4 52 1 73 29) #148# #2# 53052) si::fset)) #2# 53052) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 15 0 15 18 15 19 19 3 20 1 0 73 29) #149=#A(t (21) (swank::y-or-n-p-in-emacs swank::format-string swank::arguments swank::make-tag format apply swank::question swank::tag force-output :y-or-n-p swank::current-thread-id swank::send-to-emacs :emacs-return swank::result swank::wait-for-event third #Y(swank::y-or-n-p-in-emacs nil nil (24 45 1 27 45 2 19 0 3 12 33 4 12 77 13 1 13 0 19 4 5 12 46 6 46 7 19 0 8 14 9 19 0 10 12 13 0 10 1 6 4 12 19 1 11 14 12 13 0 1 13 6 3 12 19 1 14 16 15 43 2 29) #149# #2# 53137) si::fset function "Like y-or-n-p, but ask in the Emacs minibuffer." si::set-documentation)) #2# 53137) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #150=#A(t (24) (swank::read-from-minibuffer-in-emacs swank::prompt swank::initial-value #:g2632 string typep si::do-check-type #:g2634 (or null string) swank::make-tag swank::tag force-output :read-from-minibuffer swank::current-thread-id swank::send-to-emacs :emacs-return swank::result swank::wait-for-event third #Y(swank::read-from-minibuffer-in-emacs nil nil (24 45 1 25 40 2 77 46 2 26 10 1 45 3 13 0 15 4 19 2 5 76 39 13 13 0 15 4 77 15 1 19 4 6 51 2 43 1 10 0 45 7 13 0 15 8 19 2 5 76 39 13 13 0 15 8 77 15 2 19 4 6 51 1 43 1 19 0 9 45 10 19 0 11 14 12 19 0 13 12 13 0 13 2 10 1 6 5 12 19 1 14 14 15 13 0 1 16 6 3 12 19 1 17 16 18 43 1 29) #150# #2# 53493) si::fset function "Ask user a question in Emacs' minibuffer. Returns \"\" when user
entered nothing, returns NIL when user pressed C-g." si::set-documentation)) #2# 53493) #Y(si::bytecodes nil nil (1 26 16 27 78 13 15 0 1 24 12 19 2 25 15 0 15 28 15 29 19 3 30 1 0 73 29) #151=#A(t (31) (swank::process-form-for-emacs swank::form #:g2637 string typep "~S" format cons "(~A . ~A)" character "?~C" symbol symbol-package 0 eq ":" symbol-name string-downcase concatenate number *print-base* princ-to-string (string cons character symbol number) si::etypecase-error #Y(swank::process-form-for-emacs nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 11 77 15 5 13 1 19 3 6 38 121 13 0 15 7 19 2 4 39 25 77 15 8 10 1 4 12 19 1 0 12 10 1 5 12 19 1 0 12 19 4 6 38 88 13 0 15 9 19 2 4 39 11 77 15 10 13 1 19 3 6 38 69 13 0 15 11 19 2 4 39 33 15 3 10 1 16 12 12 1 13 17 14 73 39 4 1 15 73 12 10 1 16 16 12 19 1 17 12 19 3 18 38 28 13 0 15 19 19 2 4 39 13 8 10 48 20 10 1 16 21 44 1 38 7 13 0 1 22 17 23 43 1 29) #151# #2# 54010) si::fset "KEYWORD" find-package function "Returns a string which emacs will read as equivalent to
FORM. FORM can contain lists, strings, characters, symbols and
numbers.

Characters are converted emacs' ?<char> notaion, strings are left
as they are (except for espacing any nested \" chars, numbers are
printed in base 10 and symbols are printed as their symbol-name
converted to lower case." si::set-documentation)) #2# 54010) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 15 0 15 38 15 39 19 3 40 1 0 73 29) #152=#A(t (41) (swank::eval-in-emacs swank::form swank::nowait :eval-no-wait swank::process-form-for-emacs swank::send-to-emacs force-output swank::make-tag swank::tag :eval swank::current-thread-id :emacs-return swank::result swank::wait-for-event caddr swank::value #:|tmp-2649| #:|op-2647| #:|rand-2648| :ok #:g2650 #:g2651 si::dm-too-few-arguments si::dm-too-many-arguments :error #:g2652 #:g2653 swank::kind swank::data "~a: ~{~a~}" error :abort #:g2654 #:g2655 abort #61# #Y(swank::eval-in-emacs nil nil (24 45 1 25 40 2 77 46 2 26 10 0 39 16 14 3 13 1 19 1 4 6 2 12 19 1 5 38 199 19 0 6 19 0 7 45 8 14 9 19 0 10 12 13 0 13 2 19 1 4 6 4 12 19 1 5 14 11 13 0 1 12 6 3 12 19 1 13 16 14 45 15 10 0 45 16 10 0 4 45 17 10 1 5 45 18 10 1 42 19 47 10 0 45 20 10 0 45 21 10 0 76 39 6 13 1 19 1 22 10 0 4 12 10 0 5 51 0 22 45 15 10 1 39 6 13 2 19 1 23 10 0 73 43 3 38 85 42 24 48 10 0 45 25 10 0 45 26 10 0 76 39 6 13 1 19 1 22 10 0 4 12 10 0 5 51 0 22 45 27 10 1 45 28 15 29 13 1 13 0 19 3 30 43 4 38 35 42 31 25 10 0 45 32 10 0 45 33 10 0 39 6 13 1 19 1 23 19 0 34 43 2 38 8 15 35 13 2 19 2 30 43 3 43 1 43 1 29) #152# #2# 54982) si::fset function "Eval FORM in Emacs.
`slime-enable-evaluate-in-emacs' should be set to T on the Emacs side." si::set-documentation)) #2# 54982) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*swank-wire-protocol-version* si::*make-special boundp variable "The version of the swank/slime communication protocol." si::set-documentation)) #2# 55624) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 15 0 15 45 15 46 19 3 47 15 0 1 0 16 48 12 19 2 49 29) #153=#A(t (50) (swank::connection-info swank::*emacs-connection* swank::c *features* swank::*slime-features* :pid swank-backend::getpid :style swank::connection.communication-style :encoding :coding-systems ("utf-8-unix" "iso-latin-1-unix") #:loop-list2659 swank::cs #:loop-list-head2660 #:loop-list-tail2661 0 swank-backend::find-external-format rplacd :lisp-implementation :type lisp-implementation-type :name swank-backend::lisp-implementation-type-name :version lisp-implementation-version :program swank-backend::lisp-implementation-program :machine :instance machine-instance machine-type machine-version :features swank::features-for-emacs :modules *modules* :package *package* package-name :prompt swank::package-string-for-prompt swank::*swank-wire-protocol-version* #Y(swank::connection-info nil nil (26 11 1 45 2 11 3 52 4 14 5 19 0 6 12 14 7 13 0 19 1 8 12 14 9 14 10 58 60 73 77 15 11 46 12 46 13 75 6 1 45 14 10 0 45 15 57 16 61 2 2 39 10 4 4 51 3 10 4 5 51 4 13 3 19 1 17 39 11 13 1 10 3 6 1 51 1 17 18 10 4 2 39 4 35 0 1 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 6 2 12 14 19 14 20 19 0 21 12 14 22 19 0 23 12 14 24 19 0 25 12 14 26 19 0 27 6 8 12 14 28 14 29 19 0 30 12 14 20 19 0 31 12 14 24 19 0 32 6 6 12 14 33 19 0 34 12 14 35 14 36 14 37 14 22 11 38 16 39 12 14 40 14 38 19 1 41 6 4 12 14 24 11 42 6 18 73 43 1 29) #153# #2# 55730) si::fset function "Return a key-value list of the form: 
(&key PID STYLE LISP-IMPLEMENTATION MACHINE FEATURES PACKAGE VERSION)
PID: is the process-id of Lisp process (or nil, depending on the STYLE)
STYLE: the communication style
LISP-IMPLEMENTATION: a list (&key TYPE NAME VERSION)
FEATURES: a list of keywords
PACKAGE: a list (&key NAME PROMPT)
VERSION: the protocol version" si::set-documentation symbol-package export)) #2# 55730) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #154=#A(t (8) (swank::debug-on-swank-error (eq swank::*debug-on-swank-protocol-error* swank-backend::*debug-swank-backend*) si::assert-failure swank::*debug-on-swank-protocol-error* swank-backend::*debug-swank-backend* eq #Y(swank::debug-on-swank-error nil nil (26 38 6 15 1 19 1 2 14 3 11 4 17 5 76 40 -13 11 3 73 29) #154# #2# 57076) si::fset)) #2# 57076) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #155=#A(t (6) (#156=(setf swank::debug-on-swank-error) swank::new-value swank::*debug-on-swank-protocol-error* swank-backend::*debug-swank-backend* #Y(#156# nil nil (24 45 1 26 10 0 52 2 10 0 52 3 73 29) #155# #2# 57217) si::fset)) #2# 57217) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #157=#A(t (8) (swank::toggle-debug-on-swank-error swank::debug-on-swank-error #:g2667 (setf swank::debug-on-swank-error) #Y(swank::toggle-debug-on-swank-error nil nil (26 19 0 1 76 45 2 13 0 33 3 18 1 43 1 29) #157# #2# 57362) si::fset symbol-package export)) #2# 57362) #Y(si::bytecodes nil nil (1 0 16 1 1 0 45 2 1 3 45 4 1 5 45 6 13 0 13 2 13 1 33 7 18 3 43 1 43 2 29) #A(t (8) (swank::*buffer-package* si::*make-special #:g2668 variable #:g2669 "Package corresponding to slime-buffer-package.  

EVAL-FOR-EMACS binds *buffer-package*.  Strings originating from a slime
buffer are best read in this package.  See also FROM-STRING and TO-STRING." #:g2670 (setf documentation))) #2# 57472) #Y(si::bytecodes nil nil (1 0 16 1 1 0 45 2 1 3 45 4 1 5 45 6 13 0 13 2 13 1 33 7 18 3 43 1 43 2 29) #A(t (8) (swank::*buffer-readtable* si::*make-special #:g2671 variable #:g2672 "Readtable associated with the current buffer" #:g2673 (setf documentation))) #2# 57754) #Y(si::bytecodes nil nil (15 0 1 12 12 14 13 9 2 19 4 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #158=#A(t (18) (swank::with-buffer-syntax #:g2675 #:g2674 #:g2676 si::dm-too-few-arguments #:g2677 #:g2678 package swank::body si::dm-too-many-arguments swank::call-with-buffer-syntax lambda #Y(swank::with-buffer-syntax nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 2 75 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 13 1 15 11 77 10 0 7 3 6 3 73 29) #158# #2# 57845) t si::fset function "Execute BODY with appropriate *package* and *readtable* bindings.

This should be used for code that is conceptionally executed in an
Emacs buffer." si::set-documentation)) #2# 57845) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #159=#A(t (12) (swank::call-with-buffer-syntax package swank::fun swank::guess-buffer-package swank::*buffer-package* *package* *readtable* swank::*buffer-readtable* eq swank-backend::call-with-syntax-hooks #Y(swank::call-with-buffer-syntax nil nil (24 45 1 24 45 2 26 10 1 39 8 13 1 19 1 3 38 3 11 4 48 5 14 6 11 7 17 8 39 8 13 0 19 1 9 38 12 11 7 48 6 13 0 19 1 9 44 1 44 1 29) #159# #2# 58125) si::fset)) #2# 58125) #Y(si::bytecodes nil nil (15 0 1 37 12 14 38 9 2 19 4 39 15 0 15 40 15 41 19 3 42 1 0 73 29) #160=#A(t (43) (swank::without-printing-errors #:g2680 #:g2679 #:g2681 si::dm-too-few-arguments #:g2682 #:g2683 :object si::search-keyword #:g2684 si::missing-keyword eq swank::object :stream #:g2685 stream :msg #:g2686 #161="<<error printing object>>" swank::msg swank::body (:msg :stream :object) si::check-keyword handler-case progn serious-condition "STREAM+" gensym swank::gstream let print-unreadable-object (:type t :identity t) write-string with-output-to-string (swank::s) (swank::s :type t :identity t) swank::s #Y(swank::without-printing-errors nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 13 0 15 7 19 2 8 45 9 13 0 1 10 17 11 39 4 75 38 3 10 0 45 12 13 2 15 13 19 2 8 45 14 13 0 1 10 17 11 39 4 75 38 3 10 0 45 15 13 4 15 16 19 2 8 45 17 13 0 1 10 17 11 39 5 1 18 38 3 10 0 45 19 10 8 45 20 13 7 15 21 19 2 22 15 23 15 24 10 0 7 2 12 15 25 77 10 3 39 3 10 5 39 46 15 26 19 1 27 45 28 15 29 13 0 10 4 6 2 6 1 12 15 30 13 6 13 0 1 31 7 3 12 15 32 13 2 10 0 6 3 6 3 6 3 43 1 38 48 10 3 39 11 15 32 13 1 10 3 6 3 38 34 10 5 39 28 15 33 15 34 15 30 13 5 1 35 7 2 12 15 32 13 1 1 36 6 3 6 3 6 3 38 3 10 1 6 3 6 3 73 29) #160# #2# 58588) t si::fset function "Catches errors during evaluation of BODY and prints MSG instead." si::set-documentation)) #2# 58588) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 15 0 15 23 15 24 19 3 25 1 0 73 29) #162=#A(t (26) (swank::to-string swank::object *print-readably* #:g2690 #:g2691 0 serious-condition si::temp #Y(nil nil nil (24 45 7 26 35 1 0 29) #162# #2# 59517) si::*handler-clusters* prin1-to-string make-string-output-stream swank::s #161# write-string #Y(si::.print-unreadable-object-body. nil nil (26 15 13 13 0 19 2 14 29) #162# #2# 59517) t si::print-unreadable-object-function get-output-stream-string #Y(nil nil nil (26 75 48 2 57 3 60 67 75 45 4 57 5 61 1 22 15 6 34 8 3 6 1 12 11 9 3 48 9 10 3 16 10 36 2 44 1 19 0 11 45 12 30 1 15 13 5 13 1 14 16 14 16 32 0 12 19 5 17 43 1 10 0 16 18 43 1 36 2 62 73 43 1 63 44 1 29) #162# #2# 59517) swank::call-with-buffer-syntax #Y(swank::to-string nil nil (24 45 1 26 77 34 19 12 19 2 20 29) #162# #2# 59517) si::fset function "Write OBJECT in the *BUFFER-PACKAGE*.
The result may not be readable. Handles problems with PRINT-OBJECT methods
gracefully." si::set-documentation)) #2# 59517) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 1 0 73 29) #163=#A(t (11) (swank::from-string string *read-suppress* read-from-string #Y(nil nil nil (26 75 48 2 13 0 19 1 3 12 72 1 44 1 29) #163# #2# 59838) swank::call-with-buffer-syntax #Y(swank::from-string nil nil (24 45 1 26 77 34 4 12 19 2 5 29) #163# #2# 59838) si::fset function "Read string in the *BUFFER-PACKAGE*" si::set-documentation)) #2# 59838) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #164=#A(t (12) (swank::parse-string string package *read-suppress* read-from-string #Y(nil nil nil (26 75 48 3 13 1 19 1 4 44 1 29) #164# #2# 60015) swank::call-with-buffer-syntax #Y(swank::parse-string nil nil (24 45 1 24 45 2 26 13 0 34 5 12 19 2 6 29) #164# #2# 60015) si::fset function "Read STRING in PACKAGE." si::set-documentation)) #2# 60015) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #165=#A(t (19) (swank::tokenize-symbol string #\: position swank::pos subseq :from-end t 1+ count = swank::internp symbol package #Y(swank::tokenize-symbol nil nil (24 45 1 26 15 2 13 0 19 2 3 45 4 10 0 39 12 13 1 9 0 13 0 19 3 5 38 3 75 73 12 43 1 15 2 13 0 14 6 14 7 19 4 3 45 4 10 0 39 13 13 1 10 0 16 8 12 19 2 5 38 4 10 1 73 12 43 1 15 2 13 0 19 2 9 12 9 1 19 2 10 76 12 46 11 46 12 46 13 13 1 13 0 13 2 72 3 43 3 29) #165# #2# 60187) si::fset function "STRING is interpreted as the string representation of a symbol
and is tokenized accordingly. The result is returned in three
values: The package identifier part, the actual symbol identifier
part, and a flag if the STRING represents a symbol that is
internal to the package identifier part. (Notice that the flag is
also true with an empty package identifier part, as the STRING is
considered to represent a symbol internal to some current package.)" si::set-documentation)) #2# 60187) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 15 0 15 29 15 30 19 3 31 1 0 73 29) #166=#A(t (32) (swank::tokenize-symbol-thoroughly string length :element-type character :fill-pointer make-array swank::internp swank::vertical swank::backslash swank::token package #:loop-across-list2695 #:loop-across-index-2694 #:loop-across-vector-2693 char 0 >= aref 1+ vector-push-extend #\\ char= t #\| #\: swank::casify-char #Y(swank::tokenize-symbol-thoroughly nil nil (24 45 1 26 57 0 60 245 77 10 1 16 2 12 14 3 15 4 14 5 9 0 19 5 6 12 77 77 77 46 7 46 8 46 9 46 10 46 11 77 13 6 9 0 9 0 46 12 46 13 46 14 46 15 57 16 61 2 8 165 10 2 16 2 51 4 13 3 13 4 19 2 17 39 4 35 0 1 13 2 13 3 19 2 18 51 1 10 3 16 19 51 3 10 7 39 13 13 1 13 6 19 2 20 75 51 7 38 113 13 1 15 21 19 2 22 39 7 11 23 51 7 38 98 13 1 15 24 19 2 22 39 8 10 8 76 51 8 38 82 10 8 39 10 13 1 13 6 19 2 20 38 69 13 1 15 25 19 2 22 39 49 10 5 39 3 10 9 39 7 75 73 36 10 38 33 10 5 39 7 11 23 51 9 38 23 10 6 51 5 10 11 16 2 12 14 3 15 4 14 5 9 0 19 5 6 51 6 38 12 13 1 19 1 26 12 13 6 19 2 20 35 0 0 62 43 4 10 3 76 73 39 17 13 1 13 0 10 0 76 73 40 4 10 4 73 12 72 3 43 5 63 29) #166# #2# 61061) si::fset function "This version of TOKENIZE-SYMBOL handles escape characters." si::set-documentation)) #2# 61061) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #167=#A(t (12) (swank::untokenize-symbol package-name swank::internal-p symbol-name "::" swank::cat ":" #Y(swank::untokenize-symbol nil nil (24 45 1 24 45 2 24 45 3 26 10 2 76 39 6 10 0 73 38 25 10 1 39 12 13 2 15 4 13 0 19 3 5 38 10 13 2 15 6 13 0 19 3 5 29) #167# #2# 62428) si::fset function "The inverse of TOKENIZE-SYMBOL.

  (untokenize-symbol \"quux\" nil \"foo\") ==> \"quux:foo\"
  (untokenize-symbol \"quux\" t \"foo\")   ==> \"quux::foo\"
  (untokenize-symbol nil nil \"foo\")    ==> \"foo\"
" si::set-documentation)) #2# 62428) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #168=#A(t (19) (swank::casify-char char *readtable* readtable-case #:g2697 :preserve :upcase char-upcase :downcase char-downcase :invert upper-case-p (:preserve :upcase :downcase :invert) si::ecase-error #Y(swank::casify-char nil nil (24 45 1 26 11 2 16 3 45 4 10 0 42 5 6 10 1 73 38 46 42 6 7 10 1 16 7 38 37 42 8 7 10 1 16 9 38 28 42 10 19 10 1 16 11 39 7 10 1 16 9 38 5 10 1 16 7 38 7 13 0 1 12 17 13 43 1 29) #168# #2# 62868) si::fset function "Convert CHAR accoring to readtable-case." si::set-documentation)) #2# 62868) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #169=#A(t (11) (swank::find-symbol-with-status symbol-name swank::status *package* package find-symbol swank::flag symbol eq #Y(swank::find-symbol-with-status nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 13 2 13 0 19 2 5 47 1 6 45 7 10 1 39 7 13 1 10 3 17 8 39 9 13 0 13 1 72 2 38 5 77 77 72 2 43 2 29) #169# #2# 63196) si::fset)) #2# 63196) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 15 19 15 20 19 3 21 1 0 73 29) #170=#A(t (22) (swank::parse-symbol string *package* package swank::tokenize-symbol-thoroughly swank::internalp swank::pname swank::sname "" string= swank::keyword-package find-package find-symbol :external swank::find-symbol-with-status swank::flag symbol #Y(swank::parse-symbol nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 19 1 4 47 2 5 47 1 6 45 7 10 0 73 39 81 13 1 15 8 19 2 9 39 5 11 10 38 13 10 1 39 7 10 1 16 11 38 3 10 3 45 3 10 0 39 42 10 3 39 10 13 1 13 0 19 2 12 38 10 13 1 15 13 13 0 19 3 14 47 1 15 45 16 13 0 13 1 13 3 13 2 72 4 43 2 38 7 77 77 77 77 72 4 43 1 43 3 29) #170# #2# 63485) si::fset function "Find the symbol named STRING.
Return the symbol and a flag indicating whether the symbols was found." si::set-documentation)) #2# 63485) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #171=#A(t (11) (swank::parse-symbol-or-lose string *package* package swank::parse-symbol swank::status symbol "Unknown symbol: ~A [in ~A]" error #Y(swank::parse-symbol-or-lose nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 47 1 5 45 6 10 1 39 9 13 0 13 1 72 2 38 10 15 7 13 3 13 2 19 3 8 43 2 29) #171# #2# 64263) si::fset)) #2# 64263) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #172=#A(t (19) (swank::parse-package string #:g2701 #:g2702 0 error si::temp #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #172# #2# 64515) si::*handler-clusters* swank::*swank-io-package* *package* read-from-string find-package condition #Y(swank::parse-package nil nil (24 45 1 26 57 2 60 57 75 45 3 57 4 61 1 31 15 5 34 7 3 6 1 12 11 8 3 48 8 11 9 48 10 13 3 19 1 11 44 1 16 12 36 2 44 1 10 1 45 13 77 13 0 72 2 43 1 36 2 62 73 43 1 63 29) #172# #2# 64515) si::fset function "Find the package named STRING.
Return the package or nil." si::set-documentation)) #2# 64515) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #173=#A(t (10) (swank::unparse-name string make-symbol prin1-to-string subseq #Y(swank::unparse-name nil nil (24 45 1 26 10 0 16 2 16 3 12 9 2 19 2 4 29) #173# #2# 64798) si::fset function "Print the name STRING according to the current printer settings." si::set-documentation)) #2# 64798) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 1 0 73 29) #174=#A(t (13) (swank::guess-package string find-package swank::parse-package #\! find #\- substitute #Y(swank::guess-package nil nil (24 45 1 26 10 0 73 39 39 10 0 16 2 73 40 32 13 0 19 1 3 73 40 24 15 4 13 0 19 2 5 73 39 14 15 6 15 4 13 0 19 3 7 12 19 1 0 29) #174# #2# 65005) si::fset function "Guess which package corresponds to STRING.
Return nil if no package matches." si::set-documentation)) #2# 65005) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 6 19 0 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*readtable-alist* si::*make-special boundp swank-backend::default-readtable-alist variable "An alist mapping package names to readtables." si::set-documentation)) #2# 65313) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #175=#A(t (11) (swank::guess-buffer-readtable package-name swank::guess-package package swank::*readtable-alist* :test string= assoc *readtable* #Y(swank::guess-buffer-readtable nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 39 17 10 0 16 1 12 14 4 14 5 33 6 12 19 4 7 5 73 40 4 11 8 73 43 1 29) #175# #2# 65420) si::fset)) #2# 65420) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*pending-continuations* si::*make-special boundp variable "List of continuations for Emacs. (thread local)" si::set-documentation)) #2# 65677) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 15 6 15 7 19 3 8 1 0 73 29) #176=#A(t (9) (swank::guess-buffer-package string swank::guess-package *package* #Y(swank::guess-buffer-package nil nil (24 45 1 26 10 0 39 6 13 0 19 1 2 73 40 4 11 3 73 29) #176# #2# 65792) si::fset function "Return a package for STRING. 
Fall back to the the current if no such package exists." si::set-documentation)) #2# 65792) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 15 0 15 35 15 36 19 3 37 1 0 73 29) #177=#A(t (38) (swank::eval-for-emacs swank::form swank::buffer-package swank::id condition swank::result swank::ok swank::guess-buffer-package swank::guess-buffer-readtable swank::*pending-continuations* swank::*buffer-readtable* swank::*buffer-package* #:g2709 package typep si::do-check-type #:g2711 readtable t swank::c #Y(nil nil nil (24 45 19 26 10 0 51 3 73 29) #177# #2# 65986) si::*handler-clusters* swank-backend::check-slime-interrupts swank::*slime-interrupts-enabled* eval swank::*pre-reply-hook* swank::run-hook :return swank-backend::current-thread :ok :abort prin1-to-string swank::send-to-emacs #Y(swank::eval-for-emacs nil nil (24 45 1 24 45 2 24 45 3 26 77 77 77 46 4 46 5 46 6 64 129 13 4 19 1 7 12 13 4 19 1 8 12 13 3 11 9 3 12 49 9 49 10 49 11 11 11 45 12 13 0 15 13 19 2 14 76 39 13 13 0 15 13 77 15 11 19 4 15 52 11 43 1 11 10 45 16 13 0 15 17 19 2 14 76 39 13 13 0 15 17 77 15 10 19 4 15 52 10 43 1 15 18 34 20 3 6 1 12 11 21 3 48 21 19 0 22 11 18 48 23 10 5 16 24 44 1 69 19 0 22 70 51 1 44 1 14 25 19 1 26 11 18 51 0 73 44 3 65 14 27 19 0 28 12 10 0 39 10 14 29 10 1 6 2 73 38 10 14 30 10 2 16 31 6 2 73 12 10 3 6 4 12 19 1 32 66 43 3 29) #177# #2# 65986) si::fset function "Bind *BUFFER-PACKAGE* to BUFFER-PACKAGE and evaluate FORM.
Return the result to the continuation ID.
Errors are trapped and invoke our debugger." si::set-documentation)) #2# 65986) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*echo-area-prefix* si::*make-special boundp "=> " variable "A prefix that `format-values-for-echo-area' should use." si::set-documentation)) #2# 67133) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #178=#A(t (15) (swank::format-values-for-echo-area values *print-readably* "; No value" integerp swank::i "~A~D (~a bit~:p, #x~X, #o~O, #b~B)" swank::*echo-area-prefix* integer-length format "~a~{~S~^, ~}" #Y(nil nil nil (26 75 48 2 10 0 76 39 6 1 3 73 38 54 10 0 4 16 4 39 5 10 0 5 76 39 31 10 0 4 45 5 77 15 6 14 7 13 0 10 0 16 8 12 13 0 13 0 13 0 19 8 9 43 1 38 11 77 15 10 14 7 13 0 19 4 9 44 1 29) #178# #2# 67231) swank::call-with-buffer-syntax #Y(swank::format-values-for-echo-area nil nil (24 45 1 26 77 34 11 12 19 2 12 29) #178# #2# 67231) si::fset)) #2# 67231) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 2 19 4 11 1 0 73 29) #179=#A(t (12) (swank::values-to-string #:g2715 #:g2714 #:g2716 si::dm-too-few-arguments values si::dm-too-many-arguments swank::format-values-for-echo-area multiple-value-list #Y(swank::values-to-string nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 15 7 15 8 10 0 6 2 6 2 73 29) #179# #2# 67721) t si::fset)) #2# 67721) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 1 0 16 15 12 19 2 16 29) #180=#A(t (17) (swank::interactive-eval string "Retry SLIME interactive evaluation request." list swank::from-string eval values finish-output swank::format-values-for-echo-area #Y(nil nil nil (26 15 3 13 0 19 1 4 16 5 69 21 23 45 6 19 0 7 13 0 19 1 8 43 1 29) #180# #2# 67825) swank::call-with-retry-restart #Y(nil nil nil (26 15 2 34 9 12 19 2 10 29) #180# #2# 67825) swank::call-with-buffer-syntax #Y(swank::interactive-eval nil nil (24 45 1 26 77 34 11 12 19 2 12 29) #180# #2# 67825) si::fset symbol-package export)) #2# 67825) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 1 0 16 19 12 19 2 20 29) #181=#A(t (21) (swank::eval-and-grab-output string "Retry SLIME evaluation request." make-string-output-stream swank::s *standard-output* list swank::from-string eval values get-output-stream-string "~{~S~^~%~}" format #Y(nil nil nil (26 19 0 3 45 4 10 0 48 5 15 6 13 1 19 1 7 16 8 69 21 23 45 9 10 1 16 10 12 77 15 11 13 0 19 3 12 6 2 73 43 2 44 1 29) #181# #2# 68119) swank::call-with-retry-restart #Y(nil nil nil (26 15 2 34 13 12 19 2 14 29) #181# #2# 68119) swank::call-with-buffer-syntax #Y(swank::eval-and-grab-output nil nil (24 45 1 26 77 34 15 12 19 2 16 29) #181# #2# 68119) si::fset symbol-package export)) #2# 68119) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #182=#A(t (18) (swank::eval-region string make-string-input-stream stream values - 0 read swank::form eq finish-output list eval #Y(swank::eval-region nil nil (24 45 1 26 13 0 9 0 77 19 3 2 45 3 77 77 46 4 49 5 58 60 61 57 6 61 1 1 13 3 77 13 3 19 3 7 45 8 13 0 10 4 17 9 39 12 19 0 10 13 3 14 5 72 2 36 2 10 0 52 5 15 11 10 0 16 12 69 21 23 51 3 19 0 10 43 1 35 0 0 62 73 63 43 1 44 1 43 1 29) #182# #2# 68511) si::fset function "Evaluate STRING.
Return the results of the last form as a list and as secondary value the 
last form." si::set-documentation)) #2# 68511) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 1 0 16 11 12 19 2 12 29) #183=#A(t (13) (swank::interactive-eval-region string "Retry SLIME interactive evaluation request." swank::eval-region swank::format-values-for-echo-area #Y(nil nil nil (26 13 0 19 1 3 12 19 1 4 29) #183# #2# 68989) swank::call-with-retry-restart #Y(nil nil nil (26 15 2 34 5 12 19 2 6 29) #183# #2# 68989) swank::call-with-buffer-syntax #Y(swank::interactive-eval-region nil nil (24 45 1 26 77 34 7 12 19 2 8 29) #183# #2# 68989) si::fset symbol-package export)) #2# 68989) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 15 0 1 0 16 25 12 19 2 26 29) #184=#A(t (27) (swank::re-evaluate-defvar swank::form "Retry SLIME evaluation request." read-from-string #:g2721 #:g2722 si::dm-too-few-arguments swank::dv swank::name swank::value swank::doc si::dm-too-many-arguments (eq swank::dv 'defvar) si::assert-failure defvar eq makunbound eval prin1-to-string #Y(nil nil nil (26 13 0 19 1 3 45 1 10 0 45 4 10 0 45 5 10 0 76 39 6 13 1 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 2 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 9 10 3 39 13 10 3 4 12 10 3 5 51 3 22 38 2 75 45 10 10 4 39 6 13 5 19 1 11 38 6 15 12 19 1 13 13 3 1 14 17 15 76 40 -13 10 2 16 16 10 6 16 17 16 18 43 6 43 1 29) #184# #2# 69203) swank::call-with-retry-restart #Y(nil nil nil (26 15 2 34 19 12 19 2 20 29) #184# #2# 69203) swank::call-with-buffer-syntax #Y(swank::re-evaluate-defvar nil nil (24 45 1 26 77 34 21 12 19 2 22 29) #184# #2# 69203) si::fset symbol-package export)) #2# 69203) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*swank-pprint-bindings* si::*make-special boundp ((*print-pretty* . t) (*print-level*) (*print-length*) (*print-circle* . t) (*print-gensym* . t) (*print-readably*)) variable "A list of variables bindings during pretty printing.
Used by pprint-eval." si::set-documentation)) #2# 69597) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #185=#A(t (20) (swank::swank-pprint values swank::*swank-pprint-bindings* "; No value" make-string-output-stream *standard-output* si::%dolist-var swank::o pprint terpri get-output-stream-string #Y(nil nil nil (26 10 0 76 39 6 1 3 73 38 45 19 0 4 48 5 10 0 45 6 75 45 7 38 19 10 1 4 51 0 13 0 19 1 8 19 0 9 10 1 5 51 1 10 1 40 -21 43 2 11 5 16 10 44 1 29) #185# #2# 69889) swank::call-with-bindings #Y(nil nil nil (26 14 2 34 11 12 19 2 12 29) #185# #2# 69889) swank::call-with-buffer-syntax #Y(swank::swank-pprint nil nil (24 45 1 26 77 34 13 12 19 2 14 29) #185# #2# 69889) si::fset function "Bind some printer variables and pretty print each object in VALUES." si::set-documentation)) #2# 69889) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 1 0 16 17 12 19 2 18 29) #186=#A(t (19) (swank::pprint-eval string make-string-output-stream swank::s *trace-output* *standard-output* list read-from-string eval values get-output-stream-string swank::swank-pprint swank::cat #Y(nil nil nil (26 19 0 2 45 3 13 0 13 0 49 4 49 5 15 6 13 1 19 1 7 16 8 69 21 23 44 2 45 9 10 1 16 10 12 13 0 19 1 11 12 19 2 12 43 2 29) #186# #2# 70269) swank::call-with-buffer-syntax #Y(swank::pprint-eval nil nil (24 45 1 26 77 34 13 12 19 2 14 29) #186# #2# 70269) si::fset symbol-package export)) #2# 70269) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 15 0 1 0 16 16 12 19 2 17 29) #187=#A(t (18) (swank::set-package swank::name swank::guess-package swank::p (packagep swank::p) "Package ~a doesn't exist." si::assert-failure packagep *package* package-name swank::package-string-for-prompt #Y(swank::set-package nil nil (24 45 1 26 13 0 19 1 2 45 3 38 12 15 4 77 77 15 5 13 1 19 5 6 10 0 16 7 76 40 -17 10 0 52 8 10 0 16 9 12 13 0 19 1 10 6 2 73 43 1 29) #187# #2# 70631) si::fset function "Set *package* to the package named NAME.
Return the full package-name and the string to use in the prompt." si::set-documentation symbol-package export)) #2# 70631) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #188=#A(t (20) (swank::cat swank::strings make-string-output-stream swank::out si::%dolist-var swank::s #:g2726 string typep write-string character write-char (string character) si::etypecase-error get-output-stream-string #Y(swank::cat nil nil (27 45 1 19 0 2 45 3 10 1 45 4 75 45 5 38 59 10 1 4 51 0 10 0 45 6 13 0 15 7 19 2 8 39 10 13 1 13 3 19 2 9 38 25 13 0 15 10 19 2 8 39 10 13 1 13 3 19 2 11 38 7 13 0 1 12 17 13 43 1 10 1 5 51 1 10 1 40 -61 43 2 10 0 16 14 43 1 29) #188# #2# 70963) si::fset function "Concatenate all arguments and make the result a string." si::set-documentation)) #2# 70963) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #189=#A(t (11) (swank::truncate-string string swank::width swank::ellipsis length swank::len < subseq swank::cat #Y(swank::truncate-string nil nil (24 45 1 24 45 2 25 40 2 77 46 3 26 10 2 16 4 45 5 13 0 13 2 19 2 6 39 6 10 3 73 38 31 10 1 39 18 13 3 9 0 13 2 19 3 7 12 13 1 19 2 8 38 10 13 3 9 0 13 2 19 3 7 43 1 29) #189# #2# 71214) si::fset)) #2# 71214) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 15 0 15 2 15 27 19 3 28 1 0 73 29) #190=#A(t (29) (swank::call/truncated-output-to-string length function ".." swank::ellipsis + make-string fill-pointer swank::buffer swank::buffer-full string - swank::free min count :start1 :end2 replace #:g2734 > #Y(swank::write-output nil nil (24 45 10 26 13 6 13 3 19 2 11 45 12 13 0 10 1 16 1 12 19 2 13 45 14 13 4 13 2 14 15 13 5 14 16 13 0 19 6 17 10 0 45 18 13 6 13 0 19 2 5 51 6 43 1 10 2 16 1 12 13 1 19 2 19 73 39 17 13 4 13 6 14 15 13 5 19 4 17 10 4 73 36 3 43 2 29) #190# #2# 71443) swank-backend::make-output-stream stream finish-output subseq #Y(swank::call/truncated-output-to-string nil nil (24 45 1 24 45 2 25 40 3 15 3 46 4 26 13 2 10 0 16 1 12 19 2 5 12 19 1 6 12 9 0 46 7 46 8 57 9 60 38 30 1 20 32 0 12 19 1 21 45 22 13 6 13 0 20 1 23 13 0 19 1 23 13 3 9 0 13 4 19 3 24 43 1 43 1 63 43 2 29) #190# #2# 71443) si::fset "Call FUNCTION with a new stream, return the output written to the stream.
If FUNCTION tries to write more than LENGTH characters, it will be
aborted and return immediately with the output written so far." si::set-documentation)) #2# 71443) #Y(si::bytecodes nil nil (15 0 1 24 12 14 25 9 2 19 4 26 1 0 73 29) #191=#A(t (27) (swank::with-string-stream #:g2736 #:g2735 #:g2737 si::dm-too-few-arguments #:g2738 #:g2739 swank::var :length si::search-keyword #:g2740 si::missing-keyword eq length :bindings #:g2741 swank::bindings swank::body (:bindings :length) si::check-keyword with-output-to-string swank::call/truncated-output-to-string lambda swank::with-bindings #Y(swank::with-string-stream nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 13 1 15 8 19 2 9 45 10 13 0 1 11 17 12 39 4 75 38 3 10 0 45 13 13 3 15 14 19 2 9 45 15 13 0 1 11 17 12 39 4 75 38 3 10 0 45 16 10 7 45 17 13 6 15 18 19 2 19 10 1 76 39 4 10 3 76 39 15 15 20 10 5 6 1 12 10 0 7 3 73 38 48 10 1 76 39 21 15 21 13 3 15 22 10 5 6 1 12 10 0 7 3 6 3 73 38 23 15 23 13 1 15 0 13 5 14 8 10 3 6 3 12 10 0 7 3 6 3 73 29) #191# #2# 72515) t si::fset)) #2# 72515) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 15 0 15 27 15 28 19 3 29 1 0 73 29) #192=#A(t (30) (swank::to-line swank::object swank::width #:g2745 #:g2746 0 serious-condition si::temp #Y(nil nil nil (24 45 7 26 35 1 0 29) #192# #2# 72962) si::*handler-clusters* stream :stream :right-margin :lines write #Y(nil nil nil (24 45 10 26 13 6 14 11 13 0 14 12 13 4 14 13 9 1 19 7 14 29) #192# #2# 72962) swank::call/truncated-output-to-string make-string-output-stream swank::s #161# write-string #Y(si::.print-unreadable-object-body. nil nil (26 15 19 13 0 19 2 20 29) #192# #2# 72962) t si::print-unreadable-object-function get-output-stream-string #Y(swank::to-line nil nil (24 45 1 25 40 2 77 46 2 26 10 0 40 3 8 512 45 2 57 3 60 71 75 45 4 57 5 61 1 26 15 6 34 8 3 6 1 12 11 9 3 48 9 13 3 34 15 12 19 2 16 36 2 44 1 19 0 17 45 18 30 1 21 13 7 13 1 14 22 14 22 32 0 12 19 5 23 43 1 10 0 16 24 43 1 36 2 62 73 43 1 63 43 1 29) #192# #2# 72962) si::fset function "Print OBJECT to a single line. Return the string." si::set-documentation)) #2# 72962) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 15 0 15 27 15 28 19 3 29 1 0 73 29) #193=#A(t (30) (swank::escape-string string stream (nil :map :length) length ((#\" . "\\\"") (#\\ . "\\\\")) map array-dimension-limit swank::limit #\" write-char #:loop-across-list2753 #:loop-across-index-2752 #:loop-across-vector-2751 swank::c swank::i 0 >= aref 1+ = "..." write-string assoc swank::probe #Y(swank::escape-string nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 3 15 5 46 6 10 1 40 3 11 7 45 8 15 9 13 3 19 2 10 58 60 154 77 13 5 9 0 9 0 46 11 46 12 46 13 46 14 8 0 45 15 57 16 61 2 35 123 10 3 16 4 51 5 13 4 13 5 19 2 17 39 4 35 0 1 13 3 13 4 19 2 18 51 2 10 4 16 19 51 4 13 1 13 7 19 2 20 39 12 15 21 13 10 19 2 22 75 73 36 6 13 2 13 8 19 2 23 45 24 10 0 39 12 10 0 5 12 13 11 19 2 22 38 8 13 3 13 11 19 2 10 43 1 13 4 13 5 19 2 17 39 4 35 0 1 13 3 13 4 19 2 18 51 2 10 4 16 19 51 4 10 1 16 19 51 1 35 0 0 62 43 1 43 4 63 15 9 13 3 19 2 10 43 1 29) #193# #2# 73274) si::fset function "Write STRING to STREAM surronded by double-quotes.
LENGTH -- if non-nil truncate output after LENGTH chars.
MAP -- rewrite the chars in STRING according to this alist." si::set-documentation)) #2# 73274) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*canonical-package-nicknames* si::*make-special boundp ((:common-lisp-user . :cl-user)) variable "Canonical package names to use instead of shortest name/nickname." si::set-documentation)) #2# 74009) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*auto-abbreviate-dotted-packages* si::*make-special boundp t variable "Abbreviate dotted package names to their last component if T." si::set-documentation)) #2# 74261) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 1 0 73 29) #194=#A(t (11) (swank::package-string-for-prompt package swank::canonical-package-nickname swank::auto-abbreviated-package-name swank::shortest-package-nickname swank::unparse-name #Y(swank::package-string-for-prompt nil nil (24 45 1 26 13 0 19 1 2 73 40 14 13 0 19 1 3 73 40 6 13 0 19 1 4 12 19 1 5 29) #194# #2# 74376) si::fset function "Return the shortest nickname (or canonical name) of PACKAGE." si::set-documentation)) #2# 74376) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #195=#A(t (14) (swank::canonical-package-nickname package package-name swank::*canonical-package-nicknames* :test string= assoc swank::name string #Y(swank::canonical-package-nickname nil nil (24 45 1 26 10 0 16 2 12 14 3 14 4 33 5 12 19 4 6 5 45 7 10 0 73 39 5 10 0 16 8 43 1 29) #195# #2# 74645) si::fset function "Return the canonical package nickname, if any, of PACKAGE." si::set-documentation)) #2# 74645) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 15 19 15 20 19 3 21 1 0 73 29) #196=#A(t (22) (swank::auto-abbreviated-package-name package swank::*auto-abbreviate-dotted-packages* package-name swank::offset 0 #\. :end :from-end t position swank::last-dot-pos 1+ subseq swank::name digit-char-p notevery #Y(swank::auto-abbreviated-package-name nil nil (24 45 1 26 11 2 73 39 101 58 60 98 10 1 16 3 45 3 75 45 4 57 5 61 2 2 76 15 6 13 2 14 7 13 1 14 8 14 9 19 6 10 45 11 10 0 76 39 5 75 73 36 4 13 3 10 0 16 12 12 13 2 19 3 13 45 14 33 15 12 13 0 19 2 16 39 15 13 4 10 1 16 12 12 19 2 13 36 5 38 5 10 1 51 3 43 1 43 1 35 0 0 62 73 43 1 43 1 63 29) #196# #2# 74916) si::fset function "Return an abbreviated 'name' for PACKAGE. 

N.B. this is not an actual package name or nickname." si::set-documentation)) #2# 74916) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #197=#A(t (15) (swank::shortest-package-nickname package package-name package-nicknames #:loop-list2755 swank::name swank::shortest 0 length < #Y(swank::shortest-package-nickname nil nil (24 45 1 26 58 60 104 77 10 1 16 2 12 10 1 16 3 3 12 46 4 46 5 75 45 6 57 7 61 2 24 67 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 10 2 51 1 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 10 2 16 8 12 10 1 16 8 12 19 2 9 39 5 10 2 38 3 10 1 51 1 35 0 0 10 1 73 36 4 62 73 43 1 43 2 63 29) #197# #2# 75866) si::fset function "Return the shortest nickname of PACKAGE." si::set-documentation)) #2# 75866) #Y(si::bytecodes nil nil (15 0 1 51 12 19 2 52 15 0 15 23 15 53 19 3 54 15 0 1 0 16 55 12 19 2 56 29) #198=#A(t (57) (swank::ed-in-emacs swank::what swank::filename probe-file swank-backend::pathname-to-filename #Y(swank::canonicalize-filename nil nil (24 45 2 26 10 0 16 3 73 40 4 10 0 73 12 19 1 4 29) #198# #2# 76241) #:g2761 null typep #199=(or string pathname) :filename #200=(cons (or string pathname) *) #201=(or symbol cons) :function-name prin1-to-string (null #199# #200# #201#) si::etypecase-error swank::target swank::*emacs-connection* :ed swank::send-oob-to-emacs swank::default-connection #Y(nil nil nil (26 14 19 10 0 6 2 12 19 1 20 29) #198# #2# 76241) function swank::connection eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2762 #:g2763 #:g2764 0 swank::swank-error si::temp #Y(nil nil nil (24 45 34 26 10 0 51 2 35 1 0 29) #198# #2# 76241) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 37 26 11 38 73 39 6 13 0 19 1 39 29) #198# #2# 76241) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 42 12 13 5 19 2 43 29) #198# #2# 76241) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection "No connection" error #Y(swank::ed-in-emacs nil nil (25 40 2 77 46 1 26 30 1 5 10 1 45 6 13 0 15 7 19 2 8 39 4 75 38 74 13 0 15 9 19 2 8 39 13 14 10 13 2 32 1 18 1 6 2 38 53 13 0 15 11 19 2 8 39 19 14 10 10 2 4 12 32 1 18 1 12 10 2 5 7 3 38 26 13 0 15 12 19 2 8 39 11 14 13 10 2 16 14 6 2 38 7 13 0 1 15 17 16 43 1 45 17 11 18 39 13 14 19 10 0 6 2 12 19 1 20 38 151 19 0 21 39 141 19 0 21 12 34 22 12 46 23 46 24 14 18 10 0 17 25 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 26 49 27 49 18 75 48 28 10 0 45 29 57 30 60 83 75 45 31 57 32 61 1 45 15 33 34 35 3 6 1 12 11 36 3 48 36 15 33 34 40 3 6 1 12 11 36 3 48 36 13 4 19 1 41 12 34 44 12 19 2 45 44 1 36 2 44 1 10 1 45 37 13 4 13 0 19 1 46 12 13 0 19 1 47 12 19 3 48 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 38 6 15 49 19 1 50 43 1 43 1 29) #198# #2# 76241) si::fset "Edit WHAT in Emacs.

WHAT can be:
  A pathname or a string,
  A list (PATHNAME-OR-STRING &key LINE COLUMN POSITION),
  A function name (symbol or cons),
  NIL. " si::set-documentation symbol-package export)) #2# 76241) #Y(si::bytecodes nil nil (15 0 1 47 12 19 2 48 15 0 15 21 15 49 19 3 50 15 0 1 0 16 51 12 19 2 52 29) #202=#A(t (53) (swank::inspect-in-emacs swank::what (nil :wait) swank::wait swank::make-tag swank::current-thread-id swank::thread swank::tag swank::reset-inspector :inspect swank::inspect-object swank::send-oob-to-emacs #Y(nil nil nil (26 19 0 8 14 9 13 3 19 1 10 12 13 1 10 0 6 4 12 19 1 11 29) #202# #2# 77221) swank::call-with-buffer-syntax :emacs-return swank::result swank::wait-for-event #Y(swank::send-it nil nil (26 10 0 73 39 4 19 0 4 12 10 0 73 39 4 19 0 5 12 46 6 46 7 77 34 12 12 19 2 13 10 2 73 39 13 14 14 13 0 1 15 6 3 12 19 1 16 43 2 29) #202# #2# 77221) swank::*emacs-connection* swank::default-connection #Y(nil nil nil (26 32 0 18 0 29) #202# #2# 77221) function swank::connection eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g2770 #:g2771 #:g2772 0 swank::swank-error si::temp #Y(nil nil nil (24 45 32 26 10 0 51 2 35 1 0 29) #202# #2# 77221) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 35 26 11 36 73 39 6 13 0 19 1 37 29) #202# #2# 77221) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 40 12 13 5 19 2 41 29) #202# #2# 77221) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(swank::inspect-in-emacs nil nil (24 45 1 28 2 22 40 2 77 46 3 30 1 17 11 18 39 7 32 0 18 0 38 144 19 0 19 39 139 19 0 19 12 34 20 12 46 21 46 22 14 18 10 0 17 23 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 24 49 25 49 18 75 48 26 10 0 45 27 57 28 60 83 75 45 29 57 30 61 1 45 15 31 34 33 3 6 1 12 11 34 3 48 34 15 31 34 38 3 6 1 12 11 34 3 48 34 13 4 19 1 39 12 34 42 12 19 2 43 44 1 36 2 44 1 10 1 45 35 13 4 13 0 19 1 44 12 13 0 19 1 45 12 19 3 46 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 10 2 73 43 1 29) #202# #2# 77221) si::fset "Inspect WHAT in Emacs. If WAIT is true (default NIL) blocks until the
inspector has been closed in Emacs." si::set-documentation symbol-package export)) #2# 77221) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 15 0 1 0 16 14 12 19 2 15 29) #203=#A(t (16) (swank::value-for-editing swank::form read-from-string eval swank::value *print-length* prin1-to-string #Y(nil nil nil (26 13 0 19 1 2 16 3 45 4 75 48 5 10 0 16 6 43 1 44 1 29) #203# #2# 78020) swank::call-with-buffer-syntax #Y(swank::value-for-editing nil nil (24 45 1 26 77 34 7 12 19 2 8 29) #203# #2# 78020) si::fset function "Return a readable value of FORM for editing in Emacs.
FORM is expected, but not required, to be SETF'able." si::set-documentation symbol-package export)) #2# 78020) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 15 0 1 0 16 17 12 19 2 18 29) #204=#A(t (19) (swank::commit-edited-value swank::form swank::value setf read-from-string string "`" concatenate eval t #Y(nil nil nil (26 15 3 13 1 19 1 4 12 15 5 15 6 13 0 19 3 7 12 19 1 4 6 3 16 8 11 9 73 29) #204# #2# 78387) swank::call-with-buffer-syntax #Y(swank::commit-edited-value nil nil (24 45 1 24 45 2 26 77 34 10 12 19 2 11 29) #204# #2# 78387) si::fset function "Set the value of a setf'able FORM to VALUE.
FORM and VALUE are both strings from Emacs." si::set-documentation symbol-package export)) #2# 78387) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 1 0 73 29) #205=#A(t (13) (swank::background-message swank::format-string swank::args swank::*emacs-connection* :background-message format apply swank::send-to-emacs #Y(swank::background-message nil nil (24 45 1 27 45 2 11 3 73 39 20 14 4 33 5 12 77 13 1 13 0 19 4 6 6 2 12 19 1 7 29) #205# #2# 78676) si::fset function "Display a message in Emacs' echo area.

Use this function for informative messages only.  The message may even
be dropped if we are too busy with other things." si::set-documentation)) #2# 78676) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #206=#A(t (19) (swank::sleep-for swank::seconds get-internal-real-time swank::start internal-time-units-per-second * + swank::end 0 swank::now < - / sleep #Y(swank::sleep-for nil nil (24 45 1 26 19 0 2 45 3 13 0 13 1 14 4 19 2 5 12 19 2 6 45 7 58 60 49 57 8 61 1 1 19 0 2 45 9 13 3 13 0 19 2 10 39 7 75 73 36 2 38 16 13 3 13 0 19 2 11 12 14 4 19 2 12 16 13 43 1 35 0 0 62 73 63 43 2 29) #206# #2# 79038) si::fset function "Sleep for at least SECONDS seconds.
This is just like cl:sleep but guarantees to sleep
at least SECONDS." si::set-documentation)) #2# 79038) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 15 0 15 7 15 33 19 3 34 1 0 73 29) #207=#A(t (35) (swank::invoke-slime-debugger condition swank::*slime-interrupts-enabled* swank::*emacs-connection* swank::debug-in-emacs swank::default-connection #Y(nil nil nil (26 13 0 19 1 4 29) #207# #2# 79549) function swank::connection eq swank::*send-counter* swank-backend::*pending-slime-interrupts* #:g2780 #:g2781 #:g2782 0 swank::swank-error si::temp #Y(nil nil nil (24 45 17 26 10 0 51 2 35 1 0 29) #207# #2# 79549) si::*handler-clusters* swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 1 26 11 20 73 39 6 13 0 19 1 21 29) #207# #2# 79549) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 24 12 13 5 19 2 25 29) #207# #2# 79549) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(swank::invoke-slime-debugger nil nil (24 45 1 26 75 48 2 11 3 39 8 13 0 19 1 4 38 145 19 0 5 73 39 139 19 0 5 12 34 6 12 46 7 46 8 14 3 10 0 17 9 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 10 49 11 49 3 75 48 2 10 0 45 12 57 13 60 83 75 45 14 57 15 61 1 45 15 16 34 18 3 6 1 12 11 19 3 48 19 15 16 34 22 3 6 1 12 11 19 3 48 19 13 4 19 1 23 12 34 26 12 19 2 27 44 1 36 2 44 1 10 1 45 1 13 4 13 0 19 1 28 12 13 0 19 1 29 12 19 3 30 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 44 1 29) #207# #2# 79549) si::fset "Sends a message to Emacs declaring that the debugger has been entered,
then waits to handle further requests from Emacs. Eventually returns
after Emacs causes a restart to be invoked." si::set-documentation)) #2# 79549) #Y(si::bytecodes nil nil (15 0 15 1 77 77 19 4 2 1 0 73 29) #A(t (3) (swank::invoke-default-debugger (condition) clos::load-defclass)) #2# 80035) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #208=#A(t (18) (swank::swank-debugger-hook condition swank::hook #:g2787 #:g2788 0 swank::invoke-default-debugger si::temp #Y(nil nil nil (24 45 7 26 35 1 0 29) #208# #2# 80087) si::*handler-clusters* swank::invoke-slime-debugger #Y(nil nil nil (26 13 4 19 1 10 29) #208# #2# 80087) swank-backend::call-with-debugger-hook #Y(swank::swank-debugger-hook nil nil (24 45 1 24 45 2 26 57 3 60 47 75 45 4 57 5 61 1 27 15 6 34 8 3 6 1 12 11 9 3 48 9 33 0 12 34 11 12 19 2 12 36 2 44 1 13 4 19 1 6 36 2 62 73 43 1 63 29) #208# #2# 80087) si::fset function "Debugger function for binding *DEBUGGER-HOOK*." si::set-documentation)) #2# 80087) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #209=#A(t (7) (swank::invoke-default-debugger condition invoke-debugger #Y(nil nil nil (26 10 0 16 2 29) #209# #2# 80442) swank-backend::call-with-debugger-hook #Y(swank::invoke-default-debugger nil nil (24 45 1 26 77 34 3 12 19 2 4 29) #209# #2# 80442) si::fset)) #2# 80442) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*global-debugger* si::*make-special boundp t variable "Non-nil means the Swank debugger hook will be installed globally." si::set-documentation)) #2# 80562) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::install-debugger swank::*new-connection-hook* adjoin)) #2# 80667) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #210=#A(t (7) (swank::install-debugger swank::connection swank::*global-debugger* swank::swank-debugger-hook swank-backend::install-debugger-globally #Y(swank::install-debugger nil nil (24 45 1 26 11 2 73 39 7 33 3 12 19 1 4 29) #210# #2# 80721) si::fset)) #2# 80721) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*swank-debugger-condition* si::*make-special boundp variable "The condition being debugged." si::set-documentation)) #2# 80876) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*sldb-level* si::*make-special boundp variable "The current level of recursive debugging." si::set-documentation)) #2# 81046) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 20 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*sldb-initial-frames* si::*make-special boundp variable "The initial number of backtrace frames to send to Emacs." si::set-documentation)) #2# 81120) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*sldb-restarts* si::*make-special boundp variable "The list of currenlty active restarts." si::set-documentation)) #2# 81219) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*sldb-stepping-p* si::*make-special boundp variable "True during execution of a step command." si::set-documentation)) #2# 81295) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #211=#A(t (20) (swank::debug-in-emacs condition compute-restarts swank::*sldb-quit-restart* find-restart swank::*buffer-package* boundp symbol-value *package* swank::*sldb-level* 1+ swank::*sldb-stepping-p* swank::*sldb-restarts* swank::*swank-debugger-condition* swank::force-user-output swank::sldb-loop #Y(nil nil nil (26 14 9 19 1 15 29) #211# #2# 81375) swank-backend::call-with-debugging-environment #Y(swank::debug-in-emacs nil nil (24 45 1 26 13 0 13 0 19 1 2 12 11 3 73 39 6 14 3 19 1 4 12 1 5 16 6 39 5 1 5 16 7 73 40 4 11 8 73 12 11 9 16 10 12 77 49 11 49 9 49 8 49 3 49 12 49 13 19 0 14 34 16 12 19 1 17 44 6 29) #211# #2# 81375) si::fset)) #2# 81375) #Y(si::bytecodes nil nil (15 0 1 58 12 19 2 59 1 0 73 29) #212=#A(t (60) (swank::sldb-loop swank::level 0 #:g2838 #:g2839 :name abort :function si::temp #Y(nil nil nil (27 45 8 10 0 51 2 35 1 0 29) #212# #2# 81991) :report-function stream "Return to sldb level ~D." format #Y(nil nil nil (24 45 11 26 13 0 15 12 13 5 19 3 13 29) #212# #2# 81991) si::make-restart si::*restart-clusters* :debug swank::current-thread-id swank::*sldb-initial-frames* swank::debugger-info-for-emacs swank::send-to-emacs :debug-activate #:g2843 #:g2844 swank-backend::sldb-condition #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #212# #2# 81991) si::*handler-clusters* or (:emacs-rex . swank::_) :sldb-return 1+ swank::wait-for-event #:|tmp-2848| #:|op-2846| #:|rand-2847| :emacs-rex #:g2849 #:g2850 swank::args swank::eval-for-emacs apply #:g2851 #:g2852 si::dm-too-few-arguments swank::_ si::dm-too-many-arguments #61# error swank::c swank::handle-sldb-condition t #Y(nil nil nil (26 77 14 51 72 2 29) #212# #2# 81991) :debug-return swank::*sldb-stepping-p* > swank-backend::current-thread swank::send-event #Y(swank::sldb-loop nil nil (24 45 1 26 64 281 57 2 61 1 1 57 3 60 266 75 45 4 57 2 61 1 244 14 5 15 6 14 7 34 9 12 14 10 34 14 12 19 6 15 6 1 12 11 16 3 48 16 14 17 19 0 18 12 13 4 9 0 14 19 19 2 20 7 4 12 19 1 21 14 22 19 0 18 12 13 4 75 6 4 12 19 1 21 58 60 176 57 2 61 1 1 57 23 60 161 75 45 24 57 2 61 1 136 15 25 34 26 3 6 1 12 11 27 3 48 27 15 28 15 29 14 30 10 9 16 31 6 2 6 3 12 19 1 32 45 33 10 0 4 45 34 10 1 5 45 35 10 1 42 36 25 10 0 45 37 10 0 45 38 10 0 45 39 33 40 12 13 0 19 2 41 43 3 38 58 42 30 48 10 0 45 42 10 0 45 43 10 0 76 39 6 13 1 19 1 44 10 0 4 12 10 0 5 51 0 22 45 45 10 1 39 6 13 2 19 1 46 75 73 36 10 43 3 38 8 15 47 13 2 19 2 48 43 3 36 2 44 1 10 1 45 49 13 0 19 1 50 43 1 36 2 62 43 1 63 35 0 0 62 73 63 36 2 44 1 34 52 12 13 1 19 2 41 36 2 62 43 1 63 35 0 0 62 73 65 14 53 19 0 18 12 13 0 11 54 6 4 12 19 1 21 14 30 10 0 16 31 6 2 12 14 51 19 2 32 13 0 9 1 19 2 55 39 15 19 0 56 12 14 30 10 0 6 2 12 19 2 57 66 29) #212# #2# 81991) si::fset)) #2# 81991) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 1 0 73 29) #213=#A(t (13) (swank::handle-sldb-condition condition swank-backend::original-condition swank::real-condition :debug-condition swank::current-thread-id princ-to-string swank::send-to-emacs #Y(swank::handle-sldb-condition nil nil (24 45 1 26 13 0 19 1 2 45 3 14 4 19 0 5 12 10 0 16 6 6 3 12 19 1 7 43 1 29) #213# #2# 83080) si::fset function "Handle an internal debugger condition.
Rather than recursively debug the debugger (a dangerous idea!), these
conditions are simply reported." si::set-documentation)) #2# 83080) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #214=#A(t (9) (swank::condition-message condition t *print-circle* *print-right-margin* *print-pretty* swank-backend::format-sldb-condition #Y(swank::condition-message nil nil (24 45 1 26 14 2 9 65 14 2 49 3 49 4 49 5 13 0 19 1 6 44 3 29) #214# #2# 83467) si::fset)) #2# 83467) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 33 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*sldb-condition-printer* si::*make-special boundp swank::condition-message variable "Function called to print a condition to an SLDB buffer." si::set-documentation)) #2# 83640) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #215=#A(t (25) (swank::safe-condition-message condition #:g2859 #:g2860 0 error si::temp #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #215# #2# 83758) si::*handler-clusters* swank::*sldb-condition-printer* cond "Unable to display error condition~@[: ~A~]" #:g2862 #:g2863 #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #215# #2# 83758) princ-to-string format ash "..." swank::truncate-string #Y(swank::safe-condition-message nil nil (24 45 1 26 57 2 60 104 75 45 3 57 4 61 1 25 15 5 34 7 3 6 1 12 11 8 3 48 8 14 9 13 3 20 1 23 36 2 44 1 10 1 45 10 77 15 11 57 12 60 48 75 45 13 57 4 61 1 22 15 5 34 14 3 6 1 12 11 8 3 48 8 10 3 16 15 36 2 44 1 10 1 45 1 77 13 0 72 2 43 1 36 2 62 73 43 1 63 12 19 3 16 43 1 36 2 62 73 43 1 63 12 9 1 8 16 17 17 12 15 18 19 3 19 29) #215# #2# 83758) si::fset function "Safely print condition to a string, handling any errors during
printing." si::set-documentation)) #2# 83758) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #216=#A(t (9) (swank::debugger-condition-for-emacs swank::*swank-debugger-condition* swank::safe-condition-message "   [Condition of type ~S]" type-of format swank-backend::condition-extras #Y(swank::debugger-condition-for-emacs nil nil (26 14 1 19 1 2 12 77 15 3 11 1 16 4 12 19 3 5 12 14 1 19 1 6 6 3 73 29) #216# #2# 84258) si::fset)) #2# 84258) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 15 0 15 33 15 34 19 3 35 1 0 73 29) #217=#A(t (36) (swank::format-restarts-for-emacs most-positive-fixnum *print-right-margin* swank::*sldb-restarts* #:loop-list2872 restart #:loop-list-head2873 #:loop-list-tail2874 0 "~:[~;*~]~a" swank::*sldb-quit-restart* eq restart-name format make-string-output-stream stream #:g2876 #:g2877 serious-condition si::temp #Y(nil nil nil (24 45 19 26 35 1 0 29) #217# #2# 84522) si::*handler-clusters* princ #:stream+2875 "<<error printing restart>>" write-string #Y(si::.print-unreadable-object-body. nil nil (26 15 24 13 0 19 2 25 29) #217# #2# 84522) t si::print-unreadable-object-function get-output-stream-string rplacd #Y(swank::format-restarts-for-emacs nil nil (26 11 1 48 2 58 60 165 77 14 3 46 4 46 5 75 6 1 45 6 10 0 45 7 57 8 61 2 2 130 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 77 15 9 13 3 11 10 17 11 12 13 3 19 1 12 12 19 4 13 12 19 0 14 45 15 57 16 60 64 75 45 17 57 8 61 1 25 15 18 34 20 3 6 1 12 11 21 3 48 21 13 7 13 3 19 2 22 36 2 44 1 10 3 45 23 30 1 26 13 9 13 1 14 27 14 27 32 0 12 19 5 28 43 1 43 1 36 2 62 43 1 63 10 0 16 29 43 1 6 2 6 1 51 1 17 30 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 44 1 29) #217# #2# 84522) si::fset function "Return a list of restarts for *swank-debugger-condition* in a
format suitable for Emacs." si::set-documentation)) #2# 84522) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 15 0 1 0 16 10 12 19 2 11 29) #218=#A(t (12) (swank::sldb-break-with-default-debugger swank::dont-unwind swank::*swank-debugger-condition* swank::invoke-default-debugger signal #Y(swank::sldb-break-with-default-debugger nil nil (24 45 1 26 10 0 39 8 14 2 19 1 3 38 6 15 3 19 1 4 29) #218# #2# 85211) si::fset function "Invoke the default debugger." si::set-documentation symbol-package export)) #2# 85211) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 15 0 15 22 15 23 19 3 24 15 0 1 0 16 25 12 19 2 26 29) #219=#A(t (27) (swank::backtrace swank::start swank::end swank-backend::compute-backtrace #:loop-list2883 swank::frame swank::i #:loop-list-head2884 #:loop-list-tail2885 0 swank::frame-to-string swank-backend::frame-restartable-p #:g2886 nil t ((:restartable t)) (nil t) si::ecase-error rplacd 1+ #Y(swank::backtrace nil nil (24 45 1 24 45 2 26 58 60 141 77 13 2 13 1 19 2 3 12 46 4 46 5 10 4 45 6 75 6 1 45 7 10 0 45 8 57 9 61 2 20 94 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 1 13 3 13 4 19 1 10 12 13 4 19 1 11 45 12 10 0 42 13 4 75 38 14 42 14 5 1 15 38 7 13 0 1 16 17 17 43 1 7 3 6 1 51 1 17 18 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 10 3 16 19 51 3 35 0 0 10 2 5 73 36 6 62 73 43 2 43 1 43 2 63 29) #219# #2# 85481) si::fset function "Return a list ((I FRAME PLIST) ...) of frames from START to END.

I is an integer, and can be used to reference the corresponding frame
from Emacs; FRAME is a string representation of an implementation's
frame." si::set-documentation symbol-package export)) #2# 85481) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #220=#A(t (23) (swank::frame-to-string swank::frame swank::*backtrace-printer-bindings* *print-lines* *print-right-margin* * stream #:g2890 #:g2891 0 serious-condition si::temp #Y(nil nil nil (24 45 11 26 35 1 0 29) #220# #2# 85997) si::*handler-clusters* swank-backend::print-frame "[error printing frame]" format #Y(nil nil nil (24 45 6 26 57 7 60 47 75 45 8 57 9 61 1 25 15 10 34 12 3 6 1 12 11 13 3 48 13 13 4 13 3 19 2 14 36 2 44 1 13 3 15 15 19 2 16 36 2 62 73 43 1 63 29) #220# #2# 85997) swank::call/truncated-output-to-string #Y(nil nil nil (26 11 3 73 40 4 8 1 73 12 11 4 73 40 4 8 100 73 12 19 2 5 12 34 17 12 19 2 18 29) #220# #2# 85997) swank::call-with-bindings #Y(swank::frame-to-string nil nil (24 45 1 26 14 2 34 19 12 19 2 20 29) #220# #2# 85997) si::fset)) #2# 85997) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 15 0 1 0 16 12 12 19 2 13 29) #221=#A(t (14) (swank::debugger-info-for-emacs swank::start swank::end swank::debugger-condition-for-emacs swank::format-restarts-for-emacs swank::backtrace swank::*pending-continuations* #Y(swank::debugger-info-for-emacs nil nil (24 45 1 24 45 2 26 19 0 3 12 19 0 4 12 13 1 13 0 19 2 5 12 11 6 6 4 73 29) #221# #2# 86368) si::fset function "Return debugger state, with stack frames from START to END.
The result is a list:
  (condition ({restart}*) ({stack-frame}*) (cont*))
where
  condition   ::= (description type [extra])
  restart     ::= (name description)
  stack-frame ::= (number description [plist])
  extra       ::= (:references and other random things)
  cont        ::= continutation
  plist       ::= (:restartable {nil | t | :unknown})

condition---a pair of strings: message, and type.  If show-source is
not nil it is a frame number for which the source should be displayed.

restart---a pair of strings: restart name, and description.

stack-frame---a number from zero (the top), and a printed
representation of the frame's call.

continutation---the id of a pending Emacs continuation.

Below is an example return value. In this case the condition was a
division by zero (multi-line description), and only one frame is being
fetched (start=0, end=1).

 ((\"Arithmetic error DIVISION-BY-ZERO signalled.
Operation was KERNEL::DIVISION, operands (1 0).\"
   \"[Condition of type DIVISION-BY-ZERO]\")
  ((\"ABORT\" \"Return to Slime toplevel.\")
   (\"ABORT\" \"Return to Top-Level.\"))
  ((0 \"(KERNEL::INTEGER-/-INTEGER 1 0)\" (:restartable nil)))
  (4))" si::set-documentation symbol-package export)) #2# 86368) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #222=#A(t (6) (swank::nth-restart swank::index swank::*sldb-restarts* nth #Y(swank::nth-restart nil nil (24 45 1 26 13 0 11 2 17 3 29) #222# #2# 87831) si::fset)) #2# 87831) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 1 0 16 7 12 19 2 8 29) #223=#A(t (9) (swank::invoke-nth-restart swank::index swank::nth-restart restart invoke-restart-interactively #Y(swank::invoke-nth-restart nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 73 39 5 10 0 16 4 43 1 29) #223# #2# 87893) si::fset symbol-package export)) #2# 87893) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 1 0 16 9 12 19 2 10 29) #224=#A(t (11) (swank::sldb-abort abort swank::*sldb-restarts* :key restart-name find invoke-restart #Y(swank::sldb-abort nil nil (26 15 1 14 2 14 3 33 4 12 19 4 5 12 19 1 6 29) #224# #2# 88044) si::fset symbol-package export)) #2# 88044) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 1 0 16 4 12 19 2 5 29) #225=#A(t (6) (swank::sldb-continue continue #Y(swank::sldb-continue nil nil (26 19 0 1 29) #225# #2# 88145) si::fset symbol-package export)) #2# 88145) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #226=#A(t (16) (swank::coerce-to-condition swank::datum swank::args #:g2894 string typep simple-error :format-control :format-arguments make-condition symbol apply (string symbol) si::etypecase-error #Y(swank::coerce-to-condition nil nil (24 45 1 24 45 2 26 10 1 45 3 13 0 15 4 19 2 5 39 16 15 6 14 7 13 2 14 8 13 1 19 5 9 38 28 13 0 15 10 19 2 5 39 13 33 9 12 13 2 13 1 19 3 11 38 7 13 0 1 12 17 13 43 1 29) #226# #2# 88193) si::fset)) #2# 88193) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 15 0 1 0 16 26 12 19 2 27 29) #227=#A(t (28) (swank::simple-break "Interrupt from Emacs" swank::datum swank::args #:g2899 #:g2900 0 :name continue :function si::temp #Y(nil nil nil (27 45 10 10 0 51 2 35 1 0 29) #227# #2# 88428) :report-function stream "Continue from break." format #Y(nil nil nil (24 45 13 26 13 0 15 14 19 2 15 29) #227# #2# 88428) si::make-restart si::*restart-clusters* swank::coerce-to-condition swank::invoke-slime-debugger t #Y(nil nil nil (26 77 14 21 72 2 29) #227# #2# 88428) apply #Y(swank::simple-break nil nil (25 40 3 15 1 46 2 27 45 3 57 4 60 64 75 45 5 57 6 61 1 41 14 7 15 8 14 9 34 11 12 14 12 34 16 12 19 6 17 6 1 12 11 18 3 48 18 13 4 13 3 19 2 19 12 19 1 20 36 2 44 1 34 22 12 13 1 19 2 23 36 2 62 73 43 1 63 29) #227# #2# 88428) si::fset symbol-package export)) #2# 88428) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 15 0 1 0 16 14 12 19 2 15 29) #228=#A(t (16) (swank::throw-to-toplevel swank::*sldb-quit-restart* find-restart compute-restarts last restart invoke-restart "Restart not active [~s]" format #Y(swank::throw-to-toplevel nil nil (26 11 1 39 6 14 1 19 1 2 40 9 19 0 3 12 19 1 4 4 45 5 10 0 39 8 13 0 19 1 6 38 9 77 15 7 14 1 19 3 8 43 1 29) #228# #2# 88633) si::fset function "Invoke the ABORT-REQUEST restart abort an RPC from Emacs.
If we are not evaluating an RPC then ABORT instead." si::set-documentation symbol-package export)) #2# 88633) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #229=#A(t (13) (swank::invoke-nth-restart-for-emacs swank::sldb-level swank::n swank::*sldb-level* = swank::invoke-nth-restart #Y(swank::invoke-nth-restart-for-emacs nil nil (24 45 1 24 45 2 26 13 1 14 3 19 2 4 73 39 6 13 0 19 1 5 29) #229# #2# 89129) si::fset function "Invoke the Nth available restart.
SLDB-LEVEL is the debug level when the request was made. If this
has changed, ignore the request." si::set-documentation symbol-package export)) #2# 89129) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #230=#A(t (6) (swank::wrap-sldb-vars swank::form let swank::*sldb-level* #Y(swank::wrap-sldb-vars nil nil (24 45 1 26 15 2 15 3 11 3 6 2 6 1 12 10 0 6 3 73 29) #230# #2# 89395) si::fset)) #2# 89395) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #231=#A(t (15) (swank::eval-in-frame-aux swank::frame string package print swank::parse-string swank::wrap-sldb-vars swank::form list swank-backend::eval-in-frame values #Y(nil nil nil (26 13 2 13 0 20 1 23 29) #231# #2# 89481) swank::call-with-buffer-syntax #Y(swank::eval-in-frame-aux nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 13 1 19 2 5 12 19 1 6 45 7 15 8 13 0 13 4 19 2 9 69 21 23 45 10 13 3 34 11 12 19 2 12 43 2 29) #231# #2# 89481) si::fset)) #2# 89481) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #232=#A(t (10) (swank::eval-string-in-frame string swank::frame package swank::format-values-for-echo-area swank::eval-in-frame-aux #Y(swank::eval-string-in-frame nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 2 13 0 33 4 12 19 4 5 29) #232# #2# 89739) si::fset symbol-package export)) #2# 89739) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #233=#A(t (10) (swank::pprint-eval-string-in-frame string swank::frame package swank::swank-pprint swank::eval-in-frame-aux #Y(swank::pprint-eval-string-in-frame nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 2 13 0 33 4 12 19 4 5 29) #233# #2# 89874) si::fset symbol-package export)) #2# 89874) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 1 0 16 10 12 19 2 11 29) #234=#A(t (12) (swank::frame-package-name swank::frame swank-backend::frame-package swank::pkg package-name *package* #Y(nil nil nil (26 11 5 16 4 29) #234# #2# 90001) swank::call-with-buffer-syntax #Y(swank::frame-package-name nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 39 7 10 0 16 4 38 8 77 34 6 12 19 2 7 43 1 29) #234# #2# 90001) si::fset symbol-package export)) #2# 90001) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #235=#A(t (13) (swank::frame-locals-and-catch-tags swank::index swank::frame-locals-for-emacs swank::to-string swank-backend::frame-catch-tags mapcar #Y(swank::frame-locals-and-catch-tags nil nil (24 45 1 26 13 0 19 1 2 12 33 3 12 13 0 19 1 4 12 19 2 5 6 2 73 29) #235# #2# 90185) si::fset function "Return a list (LOCALS TAGS) for vars and catch tags in the frame INDEX.
LOCALS is a list of the form ((&key NAME ID VALUE) ...).
TAGS has is a list of strings." si::set-documentation symbol-package export)) #2# 90185) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #236=#A(t (35) (swank::frame-locals-for-emacs swank::index swank::*backtrace-printer-bindings* swank-backend::frame-locals #:loop-list2911 swank::var #:loop-list-head2912 #:loop-list-tail2913 0 #:g2914 #:g2915 :name si::search-keyword #:g2916 si::missing-keyword eq swank::name :id #:g2917 swank::id :value #:g2918 swank::value (:value :id :name) si::check-keyword swank-backend::frame-package *package* prin1-to-string *print-right-margin* swank::to-line rplacd #Y(nil nil nil (26 58 60 193 77 13 1 19 1 3 12 46 4 46 5 75 6 1 45 6 10 0 45 7 57 8 61 2 2 154 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 10 3 45 9 10 0 45 10 13 0 15 11 19 2 12 45 13 13 0 1 14 17 15 39 4 75 38 3 10 0 45 16 13 2 15 17 19 2 12 45 18 13 0 1 14 17 15 39 4 75 38 3 10 0 45 19 13 4 15 20 19 2 12 45 21 13 0 1 14 17 15 39 4 75 38 3 10 0 45 22 13 6 15 23 19 2 24 14 11 13 14 19 1 25 40 3 11 26 48 26 10 4 16 27 12 44 1 14 17 13 2 14 20 13 0 14 28 19 2 29 6 6 43 8 6 1 51 1 17 30 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 29) #236# #2# 90501) swank::call-with-bindings #Y(swank::frame-locals-for-emacs nil nil (24 45 1 26 14 2 34 31 12 19 2 32 29) #236# #2# 90501) si::fset)) #2# 90501) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #237=#A(t (10) (swank::sldb-disassemble swank::index make-string-output-stream *standard-output* swank-backend::disassemble-frame get-output-stream-string #Y(swank::sldb-disassemble nil nil (24 45 1 26 19 0 2 48 3 13 0 19 1 4 11 3 16 5 44 1 29) #237# #2# 90922) si::fset symbol-package export)) #2# 90922) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 1 0 16 10 12 19 2 11 29) #238=#A(t (12) (swank::sldb-return-from-frame swank::index string swank::from-string swank::form list swank-backend::return-from-frame swank::to-string #Y(swank::sldb-return-from-frame nil nil (24 45 1 24 45 2 26 13 0 19 1 3 45 4 15 5 13 2 13 0 19 2 6 69 21 23 12 19 1 7 43 1 29) #238# #2# 91042) si::fset symbol-package export)) #2# 91042) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #239=#A(t (10) (swank::sldb-break swank::name read-from-string swank-backend::sldb-break-at-start #Y(nil nil nil (26 13 0 19 1 2 12 19 1 3 29) #239# #2# 91206) swank::call-with-buffer-syntax #Y(swank::sldb-break nil nil (24 45 1 26 77 34 4 12 19 2 5 29) #239# #2# 91206) si::fset symbol-package export)) #2# 91206) #Y(si::bytecodes nil nil (15 0 1 14 12 14 15 9 3 19 4 16 1 0 73 29) #240=#A(t (17) (swank::define-stepper-function #:g2920 #:g2919 #:g2921 si::dm-too-few-arguments swank::name swank::backend-function-name si::dm-too-many-arguments swank::defslimefun (swank::frame) cond (swank-backend::sldb-stepper-condition-p swank::*swank-debugger-condition*) (setq swank::*sldb-stepping-p* t) (((find-restart 'continue) (swank-backend::activate-stepping swank::frame) (setq swank::*sldb-stepping-p* t) (continue)) (t (error #241="Not currently single-stepping, ~
and no continue restart available."))) #Y(swank::define-stepper-function nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 13 1 15 9 15 10 15 11 15 12 10 0 6 1 6 3 12 1 13 7 3 6 4 73 29) #240# #2# 91319) t si::fset)) #2# 91319) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #242=#A(t (16) (swank::sldb-step swank::frame swank::*swank-debugger-condition* swank-backend::sldb-stepper-condition-p t swank::*sldb-stepping-p* swank-backend::sldb-step-into continue find-restart swank-backend::activate-stepping #241# error #Y(swank::sldb-step nil nil (24 45 1 26 14 2 19 1 3 39 10 11 4 52 5 19 0 6 38 27 15 7 19 1 8 39 15 13 0 19 1 9 11 4 52 5 19 0 7 38 6 15 10 19 1 11 29) #242# #2# 91815) si::fset symbol-package export)) #2# 91815) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #243=#A(t (16) (swank::sldb-next swank::frame swank::*swank-debugger-condition* swank-backend::sldb-stepper-condition-p t swank::*sldb-stepping-p* swank-backend::sldb-step-next continue find-restart swank-backend::activate-stepping #241# error #Y(swank::sldb-next nil nil (24 45 1 26 14 2 19 1 3 39 10 11 4 52 5 19 0 6 38 27 15 7 19 1 8 39 15 13 0 19 1 9 11 4 52 5 19 0 7 38 6 15 10 19 1 11 29) #243# #2# 91869) si::fset symbol-package export)) #2# 91869) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #244=#A(t (16) (swank::sldb-out swank::frame swank::*swank-debugger-condition* swank-backend::sldb-stepper-condition-p t swank::*sldb-stepping-p* swank-backend::sldb-step-out continue find-restart swank-backend::activate-stepping #241# error #Y(swank::sldb-out nil nil (24 45 1 26 14 2 19 1 3 39 10 11 4 52 5 19 0 6 38 27 15 7 19 1 8 39 15 13 0 19 1 9 11 4 52 5 19 0 7 38 6 15 10 19 1 11 29) #244# #2# 91921) si::fset symbol-package export)) #2# 91921) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #245=#A(t (8) (swank::toggle-break-on-signals *break-on-signals* "*break-on-signals* = ~a" format #Y(swank::toggle-break-on-signals nil nil (26 11 1 76 52 1 77 15 2 14 1 19 3 3 29) #245# #2# 91972) si::fset symbol-package export)) #2# 91972) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 1 0 16 5 12 19 2 6 29) #246=#A(t (7) (swank::sdlb-print-condition swank::*swank-debugger-condition* princ-to-string #Y(swank::sdlb-print-condition nil nil (26 11 1 16 2 29) #246# #2# 92131) si::fset symbol-package export)) #2# 92131) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 15 4 15 5 15 6 77 77 77 15 7 9 6 9 0 77 15 8 19 15 9 15 10 1 18 12 19 2 19 1 0 73 29) #247=#A(t (20) (:compilation-result "COMPILATION-RESULT-" list t (swank::notes (swank::successp nil :type boolean) (swank::duration #248=0.0 :type float) (swank::loadp nil :type boolean) (swank::faslfile nil :type #249=(or null string))) ((si::typed-structure-name :compilation-result) (swank::notes nil t nil 1 nil) (swank::successp nil boolean nil 2 nil) (swank::duration #248# float nil 3 nil) (swank::loadp nil boolean nil 4 nil) (swank::faslfile nil #249# nil 5 nil)) swank::copy-compilation-result (swank::make-compilation-result) swank::compilation-result-p si::define-structure swank::make-compilation-result (nil :faslfile :loadp :duration :successp :notes) #:notes #:successp #248# #:duration #:loadp #:faslfile #Y(swank::make-compilation-result nil nil (28 11 22 40 2 77 46 12 22 40 2 77 46 13 22 40 3 15 14 46 15 22 40 2 77 46 16 22 40 2 77 46 17 15 0 13 4 13 3 13 2 13 1 10 0 6 6 73 29) #247# #2# 92220) si::fset)) #2# 92220) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #250=#A(t (14) (swank::measure-time-interval swank::fun get-internal-real-time swank::before - internal-time-units-per-second float coerce / #Y(swank::measure-time-interval nil nil (24 45 1 26 19 0 2 45 3 13 1 20 0 23 12 19 0 2 12 13 0 19 2 4 12 14 5 1 6 17 7 12 19 2 8 12 72 2 43 1 29) #250# #2# 92465) si::fset function "Call FUN and return the first return value and the elapsed time.
The time is measured in seconds." si::set-documentation)) #2# 92465) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #251=#A(t (18) (swank::make-compiler-note condition :message swank-backend::message :severity swank-backend::severity :location swank-backend::location :references swank-backend::references swank-backend::source-context swank::s :source-context #Y(swank::make-compiler-note nil nil (24 45 1 26 14 2 13 0 19 1 3 12 14 4 13 0 19 1 5 12 14 6 13 0 19 1 7 12 14 8 13 0 19 1 9 12 13 0 19 1 10 45 11 10 0 39 7 14 12 10 0 6 2 43 1 7 9 73 29) #251# #2# 92822) si::fset function "Make a compiler note data structure from a compiler-condition." si::set-documentation)) #2# 92822) #Y(si::bytecodes nil nil (15 0 1 52 12 19 2 53 1 0 73 29) #252=#A(t (54) (swank::collect-notes function swank::notes swank-backend::compiler-condition swank::c swank::make-compiler-note #Y(nil nil nil (24 45 4 26 13 0 19 1 5 12 10 1 3 51 1 73 29) #252# #2# 93241) si::*handler-clusters* #:g2931 #:g2932 0 :name abort :function si::temp #Y(nil nil nil (27 45 14 10 0 51 2 35 1 0 29) #252# #2# 93241) :report-function stream "Abort compilation." write-string #Y(nil nil nil (24 45 17 26 15 18 13 0 19 2 19 29) #252# #2# 93241) si::make-restart si::*restart-clusters* list #Y(nil nil nil (26 75 6 1 73 29) #252# #2# 93241) apply #Y(nil nil nil (26 57 8 60 63 75 45 9 57 10 61 1 40 14 11 15 12 14 13 34 15 12 14 16 34 20 12 19 6 21 6 1 12 11 22 3 48 22 15 23 13 4 20 0 23 69 21 23 36 2 44 1 34 24 12 13 1 19 2 25 36 2 62 73 43 1 63 29) #252# #2# 93241) swank::measure-time-interval swank::seconds swank::result #:g2935 #:g2936 si::dm-too-few-arguments swank::successp swank::loadp swank::faslfile si::dm-too-many-arguments #:g2937 null typep pathname swank-backend::pathname-to-filename (null pathname) si::etypecase-error :notes reverse :duration :successp t :loadp :faslfile swank::make-compilation-result #Y(swank::collect-notes nil nil (24 45 1 26 75 45 2 15 3 34 6 3 6 1 12 11 7 3 48 7 34 26 12 19 1 27 44 1 47 1 28 45 29 10 0 45 30 10 0 45 31 10 0 76 39 6 13 1 19 1 32 10 0 4 12 10 0 5 51 0 22 45 33 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 34 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 35 10 3 39 6 13 4 19 1 36 10 0 45 37 13 0 15 38 19 2 39 39 4 75 38 23 13 0 15 40 19 2 39 39 8 13 1 19 1 41 38 7 13 0 1 42 17 43 43 1 45 35 14 44 10 8 16 45 12 14 46 13 7 14 47 10 3 73 39 4 11 48 73 12 14 49 10 2 73 39 4 11 48 73 12 14 50 13 0 19 10 51 43 1 43 5 43 2 43 1 29) #252# #2# 93241) si::fset)) #2# 93241) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #253=#A(t (17) (swank::swank-compile-file* pathname swank::load-p swank::options (t :policy) swank::policy swank::fasl-pathname swank-backend::guess-external-format :default :policy swank-backend::swank-compile-file swank::failure? swank::warnings? swank::output-pathname t #Y(swank::swank-compile-file* nil nil (24 45 1 24 45 2 27 45 3 28 4 22 40 2 77 46 5 13 3 13 3 13 1 19 2 6 12 77 13 3 19 1 7 73 40 4 11 8 73 12 14 9 13 0 19 6 10 47 2 11 47 1 12 45 13 14 14 10 2 76 12 13 5 13 0 72 4 43 3 29) #253# #2# 94314) si::fset)) #2# 94314) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*compile-file-for-emacs-hook* si::*make-special boundp (swank::swank-compile-file*))) #2# 94887) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 15 0 15 24 15 25 19 3 26 15 0 1 0 16 27 12 19 2 28 29) #254=#A(t (29) (swank::compile-file-for-emacs swank::filename swank::load-p swank::options swank-backend::filename-to-pathname t *compile-verbose* *compile-print* pathname swank::*compile-file-for-emacs-hook* #:loop-list2939 swank::hook 0 apply swank::output-pathname swank::load? swank::success swank::tried #Y(nil nil nil (26 13 2 19 1 4 12 77 14 5 49 6 49 7 46 8 58 60 78 77 14 9 46 10 46 11 57 12 61 2 2 60 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 13 6 13 5 19 4 13 47 3 14 47 2 15 47 1 16 45 17 10 0 39 11 13 1 13 2 13 3 72 3 36 7 43 4 35 0 0 62 73 43 2 63 43 1 44 2 29) #254# #2# 94952) swank::collect-notes #Y(nil nil nil (26 34 18 12 19 1 19 29) #254# #2# 94952) swank::call-with-buffer-syntax #Y(swank::compile-file-for-emacs nil nil (24 45 1 24 45 2 27 45 3 77 34 20 12 19 2 21 29) #254# #2# 94952) si::fset function "Compile FILENAME and, when LOAD-P, load the result.
Record compiler notes signalled as `compiler-condition's." si::set-documentation symbol-package export)) #2# 94952) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*fasl-pathname-function* si::*make-special boundp variable "In non-nil, use this function to compute the name for fasl-files." si::set-documentation)) #2# 95647) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #255=#A(t (8) (swank::pathname-as-directory pathname pathname-directory pathname-name file-namestring append #Y(swank::pathname-as-directory nil nil (24 45 1 26 13 0 19 1 2 12 13 0 19 1 3 73 39 8 10 0 16 4 6 1 73 12 19 2 5 29) #255# #2# 95855) si::fset)) #2# 95855) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #256=#A(t (10) (swank::compile-file-output swank::file directory :directory swank::pathname-as-directory :defaults compile-file-pathname make-pathname #Y(swank::compile-file-output nil nil (24 45 1 24 45 2 26 14 3 13 0 19 1 4 12 14 5 13 1 19 1 6 12 19 4 7 29) #256# #2# 96031) si::fset)) #2# 96031) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #257=#A(t (18) (swank::fasl-pathname swank::input-file swank::options swank::*fasl-pathname-function* :fasl-directory getf swank::dir (char= (aref swank::dir (1- (length swank::dir))) #\/) si::assert-failure length 1- aref #\/ char= swank::compile-file-output compile-file-pathname #Y(swank::fasl-pathname nil nil (24 45 1 24 45 2 26 11 3 39 12 14 3 13 1 13 0 20 2 23 38 63 13 0 14 4 19 2 5 39 49 13 0 14 4 19 2 5 45 6 38 6 15 7 19 1 8 13 0 10 0 16 9 16 10 12 19 2 11 12 15 12 19 2 13 76 40 -25 13 2 13 0 19 2 14 43 1 38 6 13 1 19 1 15 29) #257# #2# 96200) si::fset)) #2# 96200) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 15 0 15 23 15 24 19 3 25 15 0 1 0 16 26 12 19 2 27 29) #258=#A(t (28) (swank::compile-string-for-emacs string swank::buffer position swank::filename swank::policy :position assoc cadr swank::offset t *compile-verbose* *compile-print* :buffer :filename :policy swank-backend::swank-compile-string #Y(nil nil nil (26 14 10 77 49 11 49 12 13 5 14 13 13 4 14 6 13 0 14 14 13 2 14 15 13 1 19 9 16 44 2 29) #258# #2# 96613) swank::collect-notes #Y(nil nil nil (26 34 17 12 19 1 18 29) #258# #2# 96613) swank::call-with-buffer-syntax #Y(swank::compile-string-for-emacs nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 14 6 13 2 19 2 7 16 8 45 9 77 34 19 12 19 2 20 43 1 29) #258# #2# 96613) si::fset function "Compile STRING (exerpted from BUFFER at POSITION).
Record compiler notes signalled as `compiler-condition's." si::set-documentation symbol-package export)) #2# 96613) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 15 0 15 28 15 29 19 3 30 15 0 1 0 16 31 12 19 2 32 29) #259=#A(t (33) (swank::compile-multiple-strings-for-emacs swank::strings swank::policy #:loop-list2943 swank::filename position package swank::buffer string #:loop-list-head2944 #:loop-list-tail2945 0 #60# t *compile-verbose* *compile-print* :buffer :position :filename :policy swank-backend::swank-compile-string #Y(nil nil nil (26 14 13 77 49 14 49 15 13 3 14 16 13 4 14 17 13 6 14 18 13 7 14 19 13 10 19 9 20 44 2 29) #259# #2# 97245) swank::call-with-buffer-syntax #Y(nil nil nil (26 13 5 34 21 12 19 2 22 29) #259# #2# 97245) swank::collect-notes rplacd #Y(swank::compile-multiple-strings-for-emacs nil nil (24 45 1 24 45 2 26 58 60 130 77 77 77 77 77 13 2 46 3 46 4 46 5 46 6 46 7 46 8 75 6 1 45 9 10 0 45 10 57 11 61 2 2 83 10 8 2 39 4 35 0 1 10 8 4 45 12 10 0 4 51 4 10 0 5 51 0 10 0 4 51 5 10 0 5 51 0 10 0 4 51 6 10 0 5 51 0 10 0 4 51 7 10 0 5 51 0 10 0 4 51 8 43 1 10 8 5 51 8 13 1 34 23 12 19 1 24 6 1 51 1 17 25 35 0 0 10 2 5 73 36 9 62 73 43 2 43 6 63 29) #259# #2# 97245) si::fset function "Compile STRINGS (exerpted from BUFFER at POSITION).
Record compiler notes signalled as `compiler-condition's." si::set-documentation symbol-package export)) #2# 97245) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #260=#A(t (10) (swank::file-newer-p swank::new-file swank::old-file file-write-date > #Y(swank::file-newer-p nil nil (24 45 1 24 45 2 26 10 1 16 3 12 10 0 16 3 12 19 2 4 29) #260# #2# 97928) si::fset function "Returns true if NEW-FILE is newer than OLD-FILE." si::set-documentation)) #2# 97928) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #261=#A(t (8) (swank::requires-compile-p swank::source-file compile-file-pathname probe-file swank::fasl-file swank::file-newer-p #Y(swank::requires-compile-p nil nil (24 45 1 26 13 0 19 1 2 16 3 45 4 10 0 76 73 40 8 13 1 13 0 19 2 5 43 1 29) #261# #2# 98087) si::fset)) #2# 98087) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 1 0 16 13 12 19 2 14 29) #262=#A(t (15) (swank::compile-file-if-needed swank::filename swank::loadp swank-backend::filename-to-pathname pathname swank::requires-compile-p swank::compile-file-for-emacs compile-file-pathname load #Y(nil nil nil (26 10 1 76 73 40 10 13 0 19 1 7 12 19 1 8 29) #262# #2# 98275) swank::collect-notes #Y(swank::compile-file-if-needed nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 0 19 1 5 39 10 13 0 13 1 19 2 6 38 7 34 9 12 19 1 10 43 1 29) #262# #2# 98275) si::fset symbol-package export)) #2# 98275) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 1 0 16 7 12 19 2 8 29) #263=#A(t (9) (swank::load-file swank::filename swank-backend::filename-to-pathname load swank::to-string #Y(swank::load-file nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 12 19 1 4 29) #263# #2# 98641) si::fset symbol-package export)) #2# 98641) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 15 19 15 20 19 3 21 15 0 1 0 16 22 12 19 2 23 29) #264=#A(t (24) (swank::swank-require swank::modules swank::filename swank::ensure-list si::%dolist-var swank::module string *modules* :test string= member swank-backend::filename-to-pathname swank::module-filename require (member (string swank::module) *modules* :test #'string=) "Required module ~s was not provided" si::assert-failure #Y(swank::swank-require nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 45 4 75 45 5 38 82 10 1 4 51 0 10 0 16 6 12 14 7 14 8 33 9 12 19 4 10 76 39 54 13 0 10 2 39 8 13 2 19 1 11 38 6 13 0 19 1 12 12 19 2 13 38 12 15 14 77 77 15 15 13 0 19 5 16 10 0 16 6 12 14 7 14 8 33 9 12 19 4 10 76 40 -28 10 1 5 51 1 10 1 40 -84 43 2 11 7 73 29) #264# #2# 98752) si::fset function "Load the module MODULE." si::set-documentation symbol-package export)) #2# 98752) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*find-module* si::*make-special boundp swank::find-module variable "Pluggable function to locate modules.
The function receives a module name as argument and should return
the filename of the module (or nil if the file doesn't exist)." si::set-documentation)) #2# 99267) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #265=#A(t (10) (swank::module-filename swank::module swank::*find-module* "Can't locate module: ~s" error #Y(swank::module-filename nil nil (24 45 1 26 14 2 13 0 20 1 23 73 40 8 15 3 13 0 19 2 4 29) #265# #2# 99480) si::fset function "Return the filename for the module MODULE." si::set-documentation)) #2# 99480) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #266=#A(t (11) (swank::merged-directory swank::dirname swank::defaults :directory :relative :defaults make-pathname merge-pathnames pathname-directory #Y(swank::merged-directory nil nil (24 45 1 24 45 2 26 14 3 14 4 10 1 6 2 12 14 5 13 0 19 4 6 12 13 0 19 2 7 12 19 1 8 29) #266# #2# 99651) si::fset)) #2# 99651) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*load-path* si::*make-special boundp variable "A list of directories to search for modules." si::set-documentation)) #2# 99873) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #267=#A(t (11) (swank::module-canditates swank::name swank::dir :name :defaults make-pathname compile-file-pathname :type "lisp" #Y(swank::module-canditates nil nil (24 45 1 24 45 2 26 14 3 13 1 14 4 13 0 19 4 5 12 19 1 6 12 14 3 13 1 14 7 15 8 14 4 13 0 19 6 5 6 2 73 29) #267# #2# 99951) si::fset)) #2# 99951) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #268=#A(t (12) (swank::find-module swank::module string-downcase swank::name swank::dir probe-file swank::module-canditates some #Y(nil nil nil (24 45 4 26 33 5 12 13 1 13 0 19 2 6 12 19 2 7 29) #268# #2# 100129) swank::*load-path* #Y(swank::find-module nil nil (24 45 1 26 13 0 19 1 2 45 3 34 8 12 14 9 19 2 7 43 1 29) #268# #2# 100129) si::fset)) #2# 100129) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*macroexpand-printer-bindings* si::*make-special boundp ((*print-circle*) (*print-pretty* . t) (*print-escape* . t) (*print-lines*) (*print-level*) (*print-length*)))) #2# 100303) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #269=#A(t (12) (swank::apply-macro-expander swank::expander string swank::*macroexpand-printer-bindings* swank::from-string prin1-to-string #Y(nil nil nil (26 13 1 13 0 19 1 4 12 20 1 23 16 5 29) #269# #2# 100535) swank::call-with-bindings #Y(nil nil nil (26 14 3 34 6 12 19 2 7 29) #269# #2# 100535) swank::call-with-buffer-syntax #Y(swank::apply-macro-expander nil nil (24 45 1 24 45 2 26 77 34 8 12 19 2 9 29) #269# #2# 100535) si::fset)) #2# 100535) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #270=#A(t (8) (swank::swank-macroexpand-1 string macroexpand-1 swank::apply-macro-expander #Y(swank::swank-macroexpand-1 nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #270# #2# 100729) si::fset symbol-package export)) #2# 100729) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #271=#A(t (8) (swank::swank-macroexpand string macroexpand swank::apply-macro-expander #Y(swank::swank-macroexpand nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #271# #2# 100824) si::fset symbol-package export)) #2# 100824) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #272=#A(t (8) (swank::swank-macroexpand-all string swank-backend::macroexpand-all swank::apply-macro-expander #Y(swank::swank-macroexpand-all nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #272# #2# 100915) si::fset symbol-package export)) #2# 100915) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #273=#A(t (8) (swank::swank-compiler-macroexpand-1 string swank-backend::compiler-macroexpand-1 swank::apply-macro-expander #Y(swank::swank-compiler-macroexpand-1 nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #273# #2# 101014) si::fset symbol-package export)) #2# 101014) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #274=#A(t (8) (swank::swank-compiler-macroexpand string swank-backend::compiler-macroexpand swank::apply-macro-expander #Y(swank::swank-compiler-macroexpand nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #274# #2# 101127) si::fset symbol-package export)) #2# 101127) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #275=#A(t (8) (swank::swank-expand-1 string swank::expand-1 swank::apply-macro-expander #Y(swank::swank-expand-1 nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #275# #2# 101236) si::fset symbol-package export)) #2# 101236) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #276=#A(t (8) (swank::swank-expand string swank::expand swank::apply-macro-expander #Y(swank::swank-expand nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #276# #2# 101321) si::fset symbol-package export)) #2# 101321) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #277=#A(t (9) (swank::expand-1 swank::form macroexpand-1 swank::expanded? swank::expansion t swank-backend::compiler-macroexpand-1 #Y(swank::expand-1 nil nil (24 45 1 26 13 0 19 1 2 47 1 3 45 4 10 1 39 9 13 0 14 5 72 2 38 6 13 2 19 1 6 43 2 29) #277# #2# 101402) si::fset)) #2# 101402) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #278=#A(t (6) (swank::expand swank::form swank::expand-1 swank::expand-repeatedly #Y(swank::expand nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #278# #2# 101586) si::fset)) #2# 101586) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #279=#A(t (8) (swank::expand-repeatedly swank::expander swank::form 0 swank::expanded? swank::expansion #Y(swank::expand-repeatedly nil nil (24 45 1 24 45 2 26 58 60 40 57 3 61 1 1 13 3 13 2 20 1 23 47 1 4 45 5 10 1 76 39 6 10 0 73 36 3 10 0 51 4 43 2 35 0 0 62 73 63 29) #279# #2# 101650) si::fset)) #2# 101650) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #280=#A(t (8) (swank::swank-format-string-expand string swank-backend::format-string-expand swank::apply-macro-expander #Y(swank::swank-format-string-expand nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #280# #2# 101852) si::fset symbol-package export)) #2# 101852) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 1 0 16 13 12 19 2 14 29) #281=#A(t (15) (swank::disassemble-form swank::form make-string-output-stream *standard-output* *print-readably* read-from-string eval disassemble get-output-stream-string #Y(nil nil nil (26 19 0 2 48 3 75 48 4 13 0 19 1 5 16 6 16 7 44 1 11 3 16 8 44 1 29) #281# #2# 101961) swank::call-with-buffer-syntax #Y(swank::disassemble-form nil nil (24 45 1 26 77 34 9 12 19 2 10 29) #281# #2# 101961) si::fset symbol-package export)) #2# 101961) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #282=#A(t (13) (swank::simple-completions swank::prefix package swank::all-completions swank::strings swank::longest-common-prefix #Y(swank::simple-completions nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 45 4 13 0 13 0 19 1 5 6 2 73 43 1 29) #282# #2# 102170) si::fset function "Return a list of completions for the string PREFIX." si::set-documentation symbol-package export)) #2# 102170) #Y(si::bytecodes nil nil (15 0 1 30 12 19 2 31 1 0 73 29) #283=#A(t (32) (swank::all-completions swank::prefix package swank::tokenize-symbol intern swank::pname swank::name swank::extern "" equal swank::keyword-package swank::guess-buffer-package swank::guess-package swank::pkg swank::sym symbol-name swank::prefix-match-p #Y(nil nil nil (24 45 14 26 13 3 10 0 16 15 12 19 2 16 29) #283# #2# 102415) swank::test swank::matching-symbols swank::syms #:loop-list2951 swank::str #:loop-list-head2952 #:loop-list-tail2953 0 swank::unparse-symbol rplacd swank::strings swank::format-completion-set #Y(swank::all-completions nil nil (24 45 1 24 45 2 26 13 1 19 1 3 47 2 4 47 1 5 45 6 10 1 39 4 10 2 76 45 7 13 2 1 8 17 9 39 5 11 10 38 18 10 2 76 39 8 13 4 19 1 11 38 6 13 2 19 1 12 45 13 34 17 45 18 10 1 39 10 13 1 13 2 13 0 19 3 19 45 20 58 60 87 77 13 1 46 21 46 14 75 45 22 75 6 1 45 23 10 0 45 24 57 25 61 2 2 48 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 19 1 26 51 3 13 11 13 3 19 2 16 39 11 13 1 10 3 6 1 51 1 17 27 35 0 0 10 2 5 73 36 6 62 43 2 43 1 43 2 63 45 28 13 0 13 7 13 6 19 3 29 43 5 43 3 29) #283# #2# 102415) si::fset)) #2# 102415) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #284=#A(t (16) (swank::matching-symbols package swank::external swank::test swank::s swank::symbol-external-p #Y(nil nil nil (24 45 4 26 13 0 13 3 19 2 5 73 39 8 13 1 13 0 20 1 23 29) #284# #2# 103138) swank::result #285=(:inherited :internal :external) t si::packages-iterator #:g2957 #:g2958 remove-duplicates #Y(swank::matching-symbols nil nil (24 45 1 24 45 2 24 45 3 26 10 1 39 6 34 6 73 38 4 10 0 73 12 77 46 7 46 3 58 60 61 13 5 15 8 14 9 19 3 10 45 11 75 45 12 75 45 4 38 36 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 4 13 0 20 1 23 39 8 13 0 10 5 3 51 5 75 39 -37 43 3 63 13 1 19 1 13 43 2 29) #284# #2# 103138) si::fset)) #2# 103138) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #286=#A(t (11) (swank::unparse-symbol symbol *readtable* readtable-case :downcase :upcase *print-case* symbol-name swank::unparse-name #Y(swank::unparse-symbol nil nil (24 45 1 26 11 2 16 3 42 4 5 11 5 38 3 11 4 48 6 10 0 16 7 12 19 1 8 44 1 29) #286# #2# 103444) si::fset)) #2# 103444) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #287=#A(t (14) (swank::prefix-match-p swank::prefix string :end2 length min :test char-equal mismatch #Y(swank::prefix-match-p nil nil (24 45 1 24 45 2 26 13 1 13 0 14 3 10 0 16 4 12 10 1 16 4 12 19 2 5 12 14 6 33 7 12 19 6 8 76 73 29) #287# #2# 103667) si::fset function "Return true if PREFIX is a prefix of STRING." si::set-documentation)) #2# 103667) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #288=#A(t (15) (swank::longest-common-prefix swank::strings "" swank::s1 swank::s2 mismatch swank::diff-pos subseq #Y(swank::common-prefix nil nil (24 45 3 24 45 4 26 13 1 13 0 19 2 5 45 6 10 0 39 12 13 2 9 0 13 0 19 3 7 38 4 10 2 73 43 1 29) #288# #2# 103874) reduce #Y(swank::longest-common-prefix nil nil (24 45 1 26 10 0 76 39 6 1 2 73 38 14 30 1 8 32 0 12 13 1 19 2 9 43 1 29) #288# #2# 103874) si::fset function "Return the longest string that is a common prefix of STRINGS." si::set-documentation)) #2# 103874) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #289=#A(t (15) (swank::format-completion-set swank::strings swank::internal-p package-name string swank::untokenize-symbol #Y(nil nil nil (24 45 4 26 13 1 13 2 13 0 19 3 5 29) #289# #2# 104209) string< sort mapcar #Y(swank::format-completion-set nil nil (24 45 1 24 45 2 24 45 3 26 34 6 12 13 2 33 7 12 19 2 8 12 19 2 9 29) #289# #2# 104209) si::fset function "Format a set of completion strings.
Returns a list of completions with package qualifiers if needed." si::set-documentation)) #2# 104209) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 15 0 1 0 16 20 12 19 2 21 29) #290=#A(t (22) (swank::operator-arglist swank::name package #:g2963 #:g2964 0 error si::temp #Y(nil nil nil (24 45 7 26 10 0 51 2 35 1 0 29) #290# #2# 104500) si::*handler-clusters* swank::guess-buffer-package swank::parse-symbol swank-backend::arglist swank::args :not-available eq princ-to-string condition #Y(swank::operator-arglist nil nil (24 45 1 24 45 2 26 57 3 60 82 75 45 4 57 5 61 1 56 15 6 34 8 3 6 1 12 11 9 3 48 9 13 4 13 3 19 1 10 12 19 2 11 12 19 1 12 45 13 13 0 11 14 17 15 39 5 75 73 38 8 13 5 10 0 3 16 16 43 1 36 2 44 1 10 1 45 17 77 13 0 72 2 43 1 36 2 62 73 43 1 63 29) #290# #2# 104500) si::fset symbol-package export)) #2# 104500) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 15 0 1 0 16 20 12 19 2 21 29) #291=#A(t (22) (swank::apropos-list-for-emacs swank::name swank::external-only swank::case-sensitive package swank::parse-package "No such package: ~S" error swank::briefly-describe-symbol-for-emacs swank::listify swank::apropos-symbols remove-duplicates swank::present-symbol-before-p sort mapcan #Y(swank::apropos-list-for-emacs nil nil (24 45 1 25 40 2 77 46 2 25 40 2 77 46 3 25 40 2 77 46 4 26 10 0 39 15 13 0 19 1 5 40 8 15 6 13 0 19 2 7 45 4 33 8 12 19 1 9 12 13 4 13 3 13 2 13 0 19 4 10 12 19 1 11 12 33 12 12 19 2 13 12 19 2 14 43 1 29) #291# #2# 104773) si::fset function "Make an apropos search for Emacs.
The result is a list of property lists." si::set-documentation symbol-package export)) #2# 104773) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #292=#A(t (19) (swank::briefly-describe-symbol-for-emacs symbol string #\Newline position swank::pos subseq #Y(swank::first-line nil nil (24 45 2 26 15 3 13 0 19 2 4 45 5 10 0 76 39 6 10 1 73 38 10 13 1 9 0 13 0 19 3 6 43 1 29) #292# #2# 105507) stringp swank-backend::describe-symbol-for-emacs swank::map-if swank::desc :designator swank::to-string #Y(swank::briefly-describe-symbol-for-emacs nil nil (24 45 1 26 30 1 7 33 8 12 32 0 12 13 1 19 1 9 12 19 3 10 45 11 10 0 73 39 14 14 12 13 2 19 1 13 12 10 0 7 3 73 43 1 43 1 29) #292# #2# 105507) si::fset function "Return a property list describing SYMBOL.
Like `describe-symbol-for-emacs' but with at most one line per item." si::set-documentation)) #2# 105507) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 1 0 73 29) #293=#A(t (13) (swank::map-if swank::test swank::fn swank::lists mapcar swank::x #Y(nil nil nil (24 45 5 26 13 3 13 0 20 1 23 39 10 13 2 13 0 20 1 23 38 4 10 0 73 29) #293# #2# 106011) apply #Y(swank::map-if nil nil (24 45 1 24 45 2 27 45 3 33 4 12 34 6 12 13 0 19 3 7 29) #293# #2# 106011) si::fset function "Like (mapcar FN . LISTS) but only call FN on objects satisfying TEST.
Example:
(map-if #'oddp #'- '(1 2 3 4 5)) => (-1 2 -3 4 -5)" si::set-documentation)) #2# 106011) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #294=#A(t (10) (swank::listify swank::f swank::x swank::y #Y(nil nil nil (24 45 2 26 13 1 13 0 20 1 23 45 3 10 0 73 39 6 10 0 6 1 73 43 1 29) #294# #2# 106287) #Y(swank::listify nil nil (24 45 1 26 34 4 73 29) #294# #2# 106287) si::fset function "Return a function like F, but which returns any non-null value
wrapped in a list." si::set-documentation)) #2# 106287) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 15 19 15 20 19 3 21 1 0 73 29) #295=#A(t (22) (swank::present-symbol-before-p swank::x swank::y swank::s symbol-name swank::*buffer-package* find-symbol eq #Y(swank::accessible nil nil (24 45 3 26 10 0 16 4 12 14 5 19 2 6 12 10 0 17 7 29) #295# #2# 106469) swank::ay swank::ax string< t symbol-package swank::py swank::px package-name #Y(swank::present-symbol-before-p nil nil (24 45 1 24 45 2 26 30 1 8 13 2 32 0 18 1 12 13 1 32 0 18 1 12 46 9 46 10 10 0 39 3 10 1 39 16 10 4 16 4 12 10 3 16 4 12 19 2 11 38 70 10 0 39 6 11 12 73 38 61 10 1 39 5 75 73 38 53 10 4 16 13 12 10 3 16 13 12 46 14 46 15 13 0 10 1 17 7 39 16 10 6 16 4 12 10 5 16 4 12 19 2 11 38 14 10 0 16 16 12 10 1 16 16 12 19 2 11 43 2 43 2 43 1 29) #295# #2# 106469) si::fset function "Return true if X belongs before Y in a printed summary of symbols.
Sorted alphabetically by package name and then symbol name, except
that symbols accessible in the current package go first." si::set-documentation)) #2# 106469) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #296=#A(t (13) (swank::make-apropos-matcher swank::pattern swank::case-sensitive char= char-equal swank::chr= symbol string :test search #Y(nil nil nil (24 45 6 26 13 3 10 0 16 7 12 14 8 13 1 19 4 9 29) #296# #2# 107309) #Y(swank::make-apropos-matcher nil nil (24 45 1 24 45 2 26 10 0 39 5 33 3 38 3 33 4 45 5 34 10 73 43 1 29) #296# #2# 107309) si::fset)) #2# 107309) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #297=#A(t (23) (swank::apropos-symbols string swank::external-only swank::case-sensitive package :keyword find-package list-all-packages remove swank::make-apropos-matcher swank::result swank::matcher swank::packages (:external :internal) t si::packages-iterator swank::next 0 symbol swank::morep swank::symbol-external-p #Y(swank::apropos-symbols nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 0 73 40 13 11 5 16 6 12 19 0 7 12 19 2 8 12 13 3 13 1 19 2 9 12 77 46 10 46 11 46 12 13 0 15 13 14 14 19 3 15 45 16 58 60 65 57 17 61 1 1 13 2 20 0 23 47 1 18 45 19 10 0 76 39 7 75 73 36 3 38 32 10 10 39 8 13 1 19 1 20 38 3 11 14 39 8 13 6 13 1 20 1 23 39 8 13 1 10 7 3 51 7 43 2 35 0 0 62 63 43 1 10 2 73 43 3 29) #297# #2# 107499) si::fset)) #2# 107499) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #298=#A(t (5) (swank::call-with-describe-settings swank::fn *print-readably* #Y(swank::call-with-describe-settings nil nil (24 45 1 26 75 48 2 13 0 20 0 23 44 1 29) #298# #2# 108134) si::fset)) #2# 108134) #Y(si::bytecodes nil nil (15 0 1 11 12 14 12 9 2 19 4 13 1 0 73 29) #299=#A(t (14) (swank::with-describe-settings #:g2977 #:g2976 #:g2978 si::dm-too-few-arguments #:g2979 #:g2980 swank::_ swank::body swank::call-with-describe-settings lambda #Y(swank::with-describe-settings nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 45 7 10 3 45 8 15 9 15 10 77 10 0 7 3 6 2 73 29) #299# #2# 108230) t si::fset)) #2# 108230) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #300=#A(t (10) (swank::describe-to-string swank::object make-string-output-stream *standard-output* describe get-output-stream-string #Y(nil nil nil (26 19 0 2 48 3 13 0 19 1 4 11 3 16 5 44 1 29) #300# #2# 108367) swank::call-with-describe-settings #Y(swank::describe-to-string nil nil (24 45 1 26 34 6 12 19 1 7 29) #300# #2# 108367) si::fset)) #2# 108367) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #301=#A(t (10) (swank::describe-symbol symbol-name swank::parse-symbol-or-lose swank::describe-to-string #Y(nil nil nil (26 13 0 19 1 2 12 19 1 3 29) #301# #2# 108515) swank::call-with-buffer-syntax #Y(swank::describe-symbol nil nil (24 45 1 26 77 34 4 12 19 2 5 29) #301# #2# 108515) si::fset symbol-package export)) #2# 108515) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 15 0 1 0 16 11 12 19 2 12 29) #302=#A(t (13) (swank::describe-function swank::name swank::parse-symbol-or-lose symbol macro-function symbol-function swank::describe-to-string #Y(nil nil nil (26 13 0 19 1 2 45 3 13 0 19 1 4 73 40 5 10 0 16 5 12 19 1 6 43 1 29) #302# #2# 108650) swank::call-with-buffer-syntax #Y(swank::describe-function nil nil (24 45 1 26 77 34 7 12 19 2 8 29) #302# #2# 108650) si::fset symbol-package export)) #2# 108650) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #303=#A(t (16) (swank::describe-definition-for-emacs swank::name swank::kind make-string-output-stream *standard-output* swank::parse-symbol-or-lose swank-backend::describe-definition get-output-stream-string #Y(nil nil nil (26 19 0 3 48 4 13 1 19 1 5 12 13 0 19 2 6 11 4 16 7 44 1 29) #303# #2# 108882) swank::call-with-describe-settings #Y(nil nil nil (26 34 8 12 19 1 9 29) #303# #2# 108882) swank::call-with-buffer-syntax #Y(swank::describe-definition-for-emacs nil nil (24 45 1 24 45 2 26 77 34 10 12 19 2 11 29) #303# #2# 108882) si::fset symbol-package export)) #2# 108882) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 15 0 1 0 16 24 12 19 2 25 29) #304=#A(t (26) (swank::documentation-symbol symbol-name swank::parse-symbol swank::foundp swank::sym variable documentation function swank::fdoc swank::vdoc make-string-output-stream string "Documentation for the symbol ~a:~2%" format "Not documented." "Variable:~% ~a~2%" "Function:~% Arglist: ~a~2% ~a" swank-backend::arglist get-output-stream-string "No such symbol, ~a." #Y(nil nil nil (26 13 0 19 1 2 47 1 3 45 4 10 1 39 93 13 0 15 5 19 2 6 12 13 0 15 7 19 2 6 12 46 8 46 9 19 0 10 45 11 13 0 15 12 13 3 19 3 13 10 1 40 3 10 2 76 39 8 13 0 15 14 19 2 13 10 1 39 10 13 0 15 15 13 1 19 3 13 10 2 39 16 13 0 15 16 13 3 19 1 17 12 13 2 19 4 13 10 0 16 18 43 1 43 2 38 9 77 15 19 13 2 19 3 13 43 2 29) #304# #2# 109116) swank::call-with-buffer-syntax #Y(swank::documentation-symbol nil nil (24 45 1 26 77 34 20 12 19 2 21 29) #304# #2# 109116) si::fset symbol-package export)) #2# 109116) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 15 0 1 0 16 13 12 19 2 14 29) #305=#A(t (15) (swank::list-all-package-names swank::nicknames swank::unparse-name swank::package-names list-all-packages mapcan package-name mapcar #Y(swank::list-all-package-names nil nil (25 40 2 77 46 1 26 33 2 12 10 0 39 13 33 3 12 19 0 4 12 19 2 5 38 11 33 6 12 19 0 4 12 19 2 7 12 19 2 7 29) #305# #2# 109919) si::fset function "Return a list of all package names.
Include the nicknames if NICKNAMES is true." si::set-documentation symbol-package export)) #2# 109919) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #306=#A(t (7) (swank::tracedp swank::fspec (trace) eval member #Y(swank::tracedp nil nil (24 45 1 26 13 0 1 2 16 3 12 19 2 4 29) #306# #2# 110268) si::fset)) #2# 110268) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 1 0 16 15 12 19 2 16 29) #307=#A(t (17) (swank::swank-toggle-trace swank::spec-string swank::from-string swank::spec consp swank-backend::toggle-trace swank::tracedp untrace eval "~S is now untraced." format trace "~S is now traced." #Y(swank::swank-toggle-trace nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 16 4 39 8 13 0 19 1 5 38 42 13 0 19 1 6 39 19 15 7 10 0 6 2 16 8 77 15 9 13 0 19 3 10 38 17 15 11 10 0 6 2 16 8 77 15 12 13 0 19 3 10 43 1 29) #307# #2# 110393) si::fset symbol-package export)) #2# 110393) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 1 0 16 4 12 19 2 5 29) #308=#A(t (6) (swank::untrace-all si::untrace* #Y(swank::untrace-all nil nil (26 77 19 1 1 29) #308# #2# 110775) si::fset symbol-package export)) #2# 110775) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 1 0 16 9 12 19 2 10 29) #309=#A(t (11) (swank::undefine-function swank::fname-string swank::from-string swank::fname "~S" fmakunbound format #Y(swank::undefine-function nil nil (24 45 1 26 13 0 19 1 2 45 3 77 15 4 10 0 16 5 12 19 3 6 43 1 29) #309# #2# 110820) si::fset symbol-package export)) #2# 110820) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 1 0 16 16 12 19 2 17 29) #310=#A(t (18) (swank::unintern-symbol swank::name package swank::guess-package swank::pkg "No such package: ~s" format swank::parse-symbol swank::found swank::sym nil "~s not in package ~s" unintern "Uninterned symbol: ~s" #Y(swank::unintern-symbol nil nil (24 45 1 24 45 2 26 13 0 19 1 3 45 4 10 0 76 39 11 77 15 5 13 1 19 3 6 38 47 13 2 13 0 19 2 7 47 1 8 45 9 10 1 42 10 13 77 15 11 13 4 13 3 19 4 6 38 16 13 0 13 2 19 2 12 77 15 13 13 0 19 3 6 43 2 43 1 29) #310# #2# 110979) si::fset symbol-package export)) #2# 110979) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #311=#A(t (6) (swank::profiledp swank::fspec swank-backend::profiled-functions member #Y(swank::profiledp nil nil (24 45 1 26 13 0 19 0 2 12 19 2 3 29) #311# #2# 111435) si::fset)) #2# 111435) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 1 0 16 12 12 19 2 13 29) #312=#A(t (14) (swank::toggle-profile-fdefinition swank::fname-string swank::from-string swank::fname swank::profiledp swank-backend::unprofile "~S is now unprofiled." format swank-backend::profile "~S is now profiled." #Y(swank::toggle-profile-fdefinition nil nil (24 45 1 26 13 0 19 1 2 45 3 13 0 19 1 4 39 16 13 0 19 1 5 77 15 6 13 0 19 3 7 38 14 13 0 19 1 8 77 15 9 13 0 19 3 7 43 1 29) #312# #2# 111524) si::fset symbol-package export)) #2# 111524) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 15 0 1 0 16 39 12 19 2 40 29) #313=#A(t (41) (swank::profile-by-substring swank::substring package count symbol fboundp swank::profiledp symbol-name :test equalp search #:g3000 #:g3001 0 error si::temp #Y(nil nil nil (24 45 15 26 10 0 51 2 35 1 0 29) #313# #2# 111814) si::*handler-clusters* swank-backend::profile #:g3004 + condition "~a" warn #Y(swank::maybe-profile nil nil (24 45 4 26 10 0 16 5 39 24 13 0 19 1 6 76 39 16 13 3 10 0 16 7 12 14 8 33 9 12 19 4 10 73 39 71 57 11 60 67 75 45 12 57 13 61 1 39 15 14 34 16 3 6 1 12 11 17 3 48 17 13 3 19 1 18 8 1 45 19 13 5 13 0 19 2 20 51 5 73 43 1 36 2 44 1 10 1 45 21 15 22 13 0 19 2 23 43 1 36 2 62 73 43 1 63 29) #313# #2# 111814) swank::parse-package #285# t si::packages-iterator #:g3005 #:g3006 list-all-packages #314=(:internal :external) #:g3007 #:g3008 "~a function~:p ~:*~[are~;is~:;are~] now profiled" format #Y(swank::profile-by-substring nil nil (24 45 1 24 45 2 26 8 0 45 3 30 1 24 10 2 39 60 58 60 55 13 3 19 1 25 12 15 26 14 27 19 3 28 45 29 75 45 30 75 45 4 38 26 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 32 4 18 1 75 39 -27 43 3 63 38 56 58 60 53 19 0 31 12 15 32 14 27 19 3 28 45 33 75 45 34 75 45 4 38 26 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 32 4 18 1 75 39 -27 43 3 63 43 1 77 15 35 13 0 19 3 36 43 1 29) #313# #2# 111814) si::fset symbol-package export)) #2# 111814) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 1 0 16 5 12 19 2 6 29) #315=#A(t (7) (swank::find-definition-for-thing swank::thing swank-backend::find-source-location #Y(swank::find-definition-for-thing nil nil (24 45 1 26 13 0 19 1 2 29) #315# #2# 112580) si::fset symbol-package export)) #2# 112580) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #316=#A(t (8) (swank::find-source-location-for-emacs swank::spec swank::value-spec-ref swank-backend::find-source-location #Y(swank::find-source-location-for-emacs nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #316# #2# 112691) si::fset symbol-package export)) #2# 112691) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #317=#A(t (31) (swank::value-spec-ref swank::spec #:|tmp-3020| #:|op-3018| #:|rand-3019| :string #:g3021 #:g3022 si::dm-too-few-arguments string package si::dm-too-many-arguments read-from-string eval #Y(nil nil nil (26 13 1 19 1 12 16 13 29) #317# #2# 112794) swank::call-with-buffer-syntax :inspector #:g3023 #:g3024 swank::part swank::inspector-nth-part :sldb #:g3025 #:g3026 swank::frame swank::var swank-backend::frame-var-value #61# error #Y(swank::value-spec-ref nil nil (24 45 1 26 10 0 45 2 10 0 4 45 3 10 1 5 45 4 10 1 42 5 74 10 0 45 6 10 0 45 7 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 9 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 10 10 2 39 6 13 3 19 1 11 13 0 34 14 12 19 2 15 43 4 38 134 42 16 49 10 0 45 17 10 0 45 18 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 19 10 1 39 6 13 2 19 1 11 13 0 19 1 20 43 3 38 83 42 21 73 10 0 45 22 10 0 45 23 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 24 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 25 10 2 39 6 13 3 19 1 11 13 1 13 0 19 2 26 43 4 38 8 15 27 13 2 19 2 28 43 3 29) #317# #2# 112794) si::fset)) #2# 112794) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*find-definitions-right-trim* si::*make-special boundp ",:.>")) #2# 113081) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*find-definitions-left-trim* si::*make-special boundp "#:<")) #2# 113130) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #318=#A(t (17) (swank::find-definitions-find-symbol-or-package swank::name swank::parse-symbol #Y(nil nil nil (26 13 0 19 1 2 29) #318# #2# 113175) swank::call-with-buffer-syntax swank::found symbol find-package make-symbol t #Y(swank::do-find nil nil (24 45 1 26 77 34 3 12 19 2 4 47 2 1 47 1 5 45 6 10 1 39 11 13 0 13 1 72 2 36 4 38 19 10 2 16 7 73 39 12 10 2 16 8 12 14 9 72 2 36 4 43 3 29) #318# #2# 113175) swank::*find-definitions-right-trim* string-right-trim swank::*find-definitions-left-trim* string-left-trim #Y(swank::find-definitions-find-symbol-or-package nil nil (24 45 1 26 57 0 60 50 30 1 10 13 2 32 0 18 1 14 11 10 2 17 12 12 32 0 18 1 14 13 10 2 17 14 12 32 0 18 1 14 13 14 11 10 2 17 12 17 14 12 32 0 18 1 43 1 63 29) #318# #2# 113175) si::fset)) #2# 113175) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 15 0 1 0 16 13 12 19 2 14 29) #319=#A(t (15) (swank::find-definitions-for-emacs swank::name swank::find-definitions-find-symbol-or-package swank::found symbol swank::xref>elisp swank-backend::find-definitions mapcar #Y(swank::find-definitions-for-emacs nil nil (24 45 1 26 13 0 19 1 2 47 1 3 45 4 10 1 73 39 13 33 5 12 13 0 19 1 6 12 19 2 7 43 2 29) #319# #2# 114181) si::fset function "Return a list ((DSPEC LOCATION) ...) of definitions for NAME.
DSPEC is a string and LOCATION a source location. NAME is a string." si::set-documentation symbol-package export)) #2# 114181) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 15 0 15 0 77 15 6 15 7 1 11 12 14 2 19 6 12 12 19 2 13 29) #320=#A(t (14) (swank::xref-doit :delete-methods t :lambda-list (type swank::thing) ensure-generic-function (t t) (type swank::thing) type swank::thing :not-implemented #Y(nil nil nil (24 45 8 24 45 9 26 11 10 73 29) #320# #2# 114535) clos::install-method clos::associate-methods-to-gfun)) #2# 114535) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 34 6 12 14 7 19 6 8 15 0 77 15 9 15 10 34 12 12 14 7 19 6 8 15 0 77 15 13 15 14 34 16 12 14 7 19 6 8 15 0 77 15 17 15 18 34 20 12 14 7 19 6 8 15 0 77 15 21 15 22 34 24 12 14 7 19 6 8 15 0 77 15 25 15 26 34 28 12 14 7 19 6 8 15 0 77 15 29 15 30 34 32 12 14 7 19 6 8 15 0 77 15 33 15 34 34 36 12 14 7 19 6 8 29) #321=#A(t (37) (swank::xref-doit ((eql :calls) t) (type swank::thing) type swank::thing swank-backend::who-calls #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 5 29) #321# #2# 114706) t clos::install-method ((eql :calls-who) t) (type swank::thing) swank-backend::calls-who #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 11 29) #321# #2# 114706) ((eql :references) t) (type swank::thing) swank-backend::who-references #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 15 29) #321# #2# 114706) ((eql :binds) t) (type swank::thing) swank-backend::who-binds #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 19 29) #321# #2# 114706) ((eql :macroexpands) t) (type swank::thing) swank-backend::who-macroexpands #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 23 29) #321# #2# 114706) ((eql :specializes) t) (type swank::thing) swank-backend::who-specializes #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 27 29) #321# #2# 114706) ((eql :callers) t) (type swank::thing) swank-backend::list-callers #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 31 29) #321# #2# 114706) ((eql :callees) t) (type swank::thing) swank-backend::list-callees #Y(nil nil nil (24 45 3 24 45 4 26 13 0 19 1 35 29) #321# #2# 114706))) #2# 114706) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 1 0 16 21 12 19 2 22 29) #322=#A(t (23) (swank::xref type swank::name #:g3033 #:g3034 0 error si::temp #Y(nil nil nil (24 45 7 26 10 0 51 2 35 1 0 29) #322# #2# 115342) si::*handler-clusters* swank::from-string condition swank::sexp swank::xref-doit swank::xrefs :not-implemented eq swank::xref>elisp mapcar #Y(swank::xref nil nil (24 45 1 24 45 2 26 57 3 60 49 75 45 4 57 5 61 1 23 15 6 34 8 3 6 1 12 11 9 3 48 9 13 3 19 1 10 36 2 44 1 10 1 45 11 77 13 0 72 2 43 1 36 2 62 73 43 1 63 47 1 6 45 12 10 1 76 73 39 33 13 3 13 0 19 2 13 45 14 13 0 11 15 17 16 39 6 11 15 73 38 9 33 17 12 13 0 19 2 18 43 1 43 2 29) #322# #2# 115342) si::fset symbol-package export)) #2# 115342) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #323=#A(t (16) (swank::xrefs swank::types swank::name #:loop-list3039 type #:loop-list-head3040 #:loop-list-tail3041 0 swank::xref :not-implemented eq rplacd #Y(swank::xrefs nil nil (24 45 1 24 45 2 26 58 60 99 77 13 2 46 3 46 4 75 45 0 75 6 1 45 5 10 0 45 6 57 7 61 2 2 59 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 13 7 19 2 8 51 3 14 9 10 3 17 10 76 39 5 10 3 76 76 39 14 13 1 13 4 10 3 3 6 1 51 1 17 11 35 0 0 10 2 5 73 36 6 62 73 43 2 43 1 43 2 63 29) #323# #2# 115628) si::fset symbol-package export)) #2# 115628) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #324=#A(t (11) (swank::xref>elisp swank::xref #:g3044 #:g3045 si::dm-too-few-arguments swank::name swank::loc si::dm-too-many-arguments swank::to-string #Y(swank::xref>elisp nil nil (24 45 1 26 10 0 45 2 10 0 45 3 10 0 76 39 6 13 1 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 2 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 3 19 1 7 13 1 19 1 8 12 10 0 6 2 73 43 4 29) #324# #2# 115859) si::fset)) #2# 115859) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 3 77 77 15 6 19 15 7 15 0 19 1 20 78 16 15 8 1 18 12 19 2 19 1 0 73 29) #325=#A(t (21) (swank::lcons "LCONS-" (car (swank::%cdr nil :type #326=(or null swank::lcons function)) (swank::forced? nil)) ((car nil t nil 0 nil) (swank::%cdr nil #326# nil 1 nil) (swank::forced? nil t nil 2 nil)) swank::copy-lcons ((swank::%lcons (car swank::%cdr))) swank::lcons? si::define-structure swank::%lcons car swank::%cdr swank::forced? (or null swank::lcons function) typep (or null swank::lcons function) si::structure-type-error 0 si::make-structure #Y(swank::%lcons nil nil (24 45 9 24 45 10 26 75 45 11 13 1 15 12 19 2 13 76 39 12 13 1 15 14 15 0 15 10 19 4 15 15 16 13 2 13 1 13 0 19 4 17 29) #325# #2# 115961) si::fset find-class)) #2# 115961) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #327=#A(t (13) (swank::lcons #:g3047 #:g3046 #:g3048 si::dm-too-few-arguments car cdr si::dm-too-many-arguments swank::%lcons lambda #Y(swank::lcons nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 13 1 15 9 77 10 0 6 3 6 3 73 29) #327# #2# 116148) t si::fset)) #2# 116148) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 3 19 4 11 1 0 73 29) #328=#A(t (12) (swank::lcons* #:g3050 #:g3049 #:g3051 si::dm-too-few-arguments car cdr swank::more swank::lcons #Y(swank::lcons* nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 10 0 76 39 12 15 8 13 2 10 1 6 3 73 38 16 15 8 13 2 15 0 13 1 10 0 7 3 6 3 73 29) #328# #2# 116213) t si::fset)) #2# 116213) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #329=#A(t (14) (swank::lcons-cdr swank::lcons #:g3060 swank::lcons-forced? swank::lcons-%cdr swank::value #:g3064 t #:g3065 si::structure-set #:g3066 #:g3067 #Y(swank::lcons-cdr nil nil (24 45 1 26 10 0 45 2 13 0 19 1 3 39 8 13 0 19 1 4 38 60 13 0 19 1 4 12 20 0 23 45 5 10 1 45 6 11 7 45 8 13 1 15 1 9 2 13 0 19 4 9 43 1 43 1 10 1 45 10 10 1 45 11 13 1 15 1 9 1 13 0 19 4 9 43 1 43 1 43 1 43 1 29) #329# #2# 116346) si::fset)) #2# 116346) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #330=#A(t (9) (swank::llist-range swank::llist swank::start swank::end swank::llist-skip - swank::llist-take #Y(swank::llist-range nil nil (24 45 1 24 45 2 24 45 3 26 13 2 13 1 19 2 4 12 13 0 13 1 19 2 5 12 19 2 6 29) #330# #2# 116589) si::fset)) #2# 116589) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #331=#A(t (10) (swank::llist-skip swank::lcons swank::index swank::l swank::i 1+ swank::lcons-cdr = #Y(swank::llist-skip nil nil (24 45 1 24 45 2 26 9 0 13 1 46 3 46 4 38 16 10 0 16 5 12 13 1 19 1 6 12 53 1 53 0 13 0 13 2 19 2 7 40 4 10 1 76 39 -28 10 1 73 43 2 29) #331# #2# 116685) si::fset)) #2# 116685) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #332=#A(t (13) (swank::llist-take swank::lcons count swank::result swank::l swank::i swank::lcons-car 1+ swank::lcons-cdr = nreverse #Y(swank::llist-take nil nil (24 45 1 24 45 2 26 75 45 3 9 0 13 2 46 4 46 5 38 27 13 1 19 1 6 12 10 2 3 51 2 10 0 16 7 12 13 1 19 1 8 12 53 1 53 0 13 0 13 3 19 2 9 40 4 10 1 76 39 -39 43 2 10 0 16 10 43 1 29) #332# #2# 116821) si::fset)) #2# 116821) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #333=#A(t (6) (swank::iline swank::label swank::value :line #Y(swank::iline nil nil (24 45 1 24 45 2 26 14 3 13 1 10 0 6 3 73 29) #333# #2# 117049) si::fset)) #2# 117049) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*inspector-verbose* si::*make-special boundp)) #2# 117106) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*inspector-printer-bindings* si::*make-special boundp ((*print-lines* . 1) (*print-right-margin* . 75) (*print-pretty* . t) (*print-readably*)))) #2# 117164) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (swank::*inspector-verbose-printer-bindings* si::*make-special boundp ((*print-escape* . t) (*print-circle* . t) (*print-array*)))) #2# 117338) #Y(si::bytecodes nil nil (15 0 15 1 77 77 77 77 15 2 77 77 77 15 3 9 0 77 77 15 4 19 15 5 15 0 19 1 12 78 8 15 6 1 10 12 19 2 11 1 0 73 29) #334=#A(t (13) (swank::inspector-state "INSPECTOR-STATE-" swank::copy-inspector-state (swank::make-inspector-state) swank::inspector-state-p si::define-structure swank::make-inspector-state (nil) 0 si::make-structure #Y(swank::make-inspector-state nil nil (28 7 15 8 19 1 9 29) #334# #2# 117468) si::fset find-class)) #2# 117468) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 8 77 77 15 7 19 15 8 15 0 19 1 28 78 24 15 9 1 26 12 19 2 27 1 0 73 29) #335=#A(t (29) (swank::istate swank::istate. (swank::object (swank::verbose swank::*inspector-verbose*) (swank::parts #336=(make-array 10 :adjustable t :fill-pointer 0)) (swank::actions #337=(make-array 10 :adjustable t :fill-pointer 0)) swank::metadata-plist swank::content swank::next swank::previous) ((swank::object nil t nil 0 nil) (swank::verbose swank::*inspector-verbose* t nil 1 nil) (swank::parts #336# t nil 2 nil) (swank::actions #337# t nil 3 nil) (swank::metadata-plist nil t nil 4 nil) (swank::content nil t nil 5 nil) (swank::next nil t nil 6 nil) (swank::previous nil t nil 7 nil)) swank::copy-istate swank::inspector-state (swank::make-istate) swank::istate-p si::define-structure swank::make-istate (nil :previous :next :content :metadata-plist :actions :parts :verbose :object) #:object swank::*inspector-verbose* #:verbose :adjustable t :fill-pointer make-array #:parts #:actions #:metadata-plist #:content #:next #:previous 0 si::make-structure #Y(swank::make-istate nil nil (28 10 22 40 2 77 46 11 22 40 3 14 12 46 13 22 40 15 9 10 14 14 14 15 14 16 9 0 19 5 17 12 46 18 22 40 15 9 10 14 14 14 15 14 16 9 0 19 5 17 12 46 19 22 40 2 77 46 20 22 40 2 77 46 21 22 40 2 77 46 22 22 40 2 77 46 23 15 24 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 9 25 29) #335# #2# 117499) si::fset find-class)) #2# 117499) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*istate* si::*make-special boundp)) #2# 117774) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (swank::*inspector-history* si::*make-special)) #2# 117799) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #338=#A(t (9) (swank::reset-inspector swank::*istate* :adjustable t :fill-pointer make-array swank::*inspector-history* #Y(swank::reset-inspector nil nil (26 75 52 1 9 10 14 2 14 3 14 4 9 0 19 5 5 52 6 73 29) #338# #2# 117829) si::fset)) #2# 117829) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 1 0 16 13 12 19 2 14 29) #339=#A(t (15) (swank::init-inspector string "Retry SLIME inspection request." swank::reset-inspector read-from-string eval swank::inspect-object #Y(nil nil nil (26 19 0 3 13 0 19 1 4 16 5 12 19 1 6 29) #339# #2# 117957) swank::call-with-retry-restart #Y(nil nil nil (26 15 2 34 7 12 19 2 8 29) #339# #2# 117957) swank::call-with-buffer-syntax #Y(swank::init-inspector nil nil (24 45 1 26 77 34 9 12 19 2 10 29) #339# #2# 117957) si::fset symbol-package export)) #2# 117957) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #340=#A(t (28) (swank::ensure-istate-metadata swank::o swank::indicator swank::default swank::*istate* #341=#:oo-3082 #:g3084 #:g3083 (swank::istate.object #341#) #:g3086 #:g3085 (swank::istate.metadata-plist #341#) (eq swank::object swank::o) si::assert-failure swank::istate.object eq swank::istate.metadata-plist getf swank::data #:g3087 #:g3089 #:g3090 si::put-f #:g3088 swank::istate si::structure-set #Y(swank::ensure-istate-metadata nil nil (24 45 1 24 45 2 24 45 3 26 11 4 45 5 38 6 15 12 19 1 13 13 0 19 1 14 12 10 3 17 15 76 40 -17 13 0 19 1 16 12 13 2 13 1 19 3 17 45 18 10 1 45 19 10 4 45 20 10 2 45 21 13 2 19 1 16 12 13 0 13 1 19 3 22 45 23 13 3 15 24 9 4 13 0 19 4 25 10 1 43 1 43 1 43 2 10 0 73 43 1 43 1 29) #340# #2# 118176) si::fset)) #2# 118176) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #342=#A(t (25) (swank::inspect-object swank::o swank::*istate* swank::prev :object :previous :verbose swank::istate.verbose swank::*inspector-verbose* swank::make-istate swank::istate #:g3096 swank::emacs-inspect/istate #:g3097 si::structure-set swank::*inspector-history* find vector-push-extend swank::istate.previous swank::previous #:g3098 #:g3099 swank::istate>elisp #Y(swank::inspect-object nil nil (24 45 1 26 11 2 45 3 14 4 13 1 14 5 13 0 14 6 10 0 39 8 13 0 19 1 7 38 4 11 8 73 12 19 6 9 45 10 10 0 52 2 10 0 45 11 13 1 19 1 12 45 13 13 1 15 10 9 5 13 0 19 4 14 43 1 43 1 13 2 14 15 19 2 16 76 39 8 13 2 14 15 19 2 17 13 0 19 1 18 45 19 10 0 39 24 10 0 45 20 10 2 45 21 13 1 15 10 9 6 13 0 19 4 14 43 1 43 1 43 1 13 0 19 1 22 43 2 29) #342# #2# 118441) si::fset)) #2# 118441) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #343=#A(t (11) (swank::emacs-inspect/istate swank::istate swank::istate.verbose swank::*inspector-verbose-printer-bindings* swank::*inspector-printer-bindings* swank::istate.object swank-backend::emacs-inspect #Y(nil nil nil (26 13 0 19 1 5 12 19 1 6 29) #343# #2# 119024) swank::call-with-bindings #Y(swank::emacs-inspect/istate nil nil (24 45 1 26 13 0 19 1 2 39 6 11 3 73 38 4 11 4 73 12 34 7 12 19 2 8 29) #343# #2# 119024) si::fset)) #2# 119024) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #344=#A(t (12) (swank::istate>elisp swank::istate :title swank::prepare-title :id swank::istate.object swank::istate.parts swank::assign-index :content swank::prepare-range #Y(swank::istate>elisp nil nil (24 45 1 26 14 2 13 0 19 1 3 12 14 4 13 0 19 1 5 12 13 0 19 1 6 12 19 2 7 12 14 8 13 0 9 0 9 500 19 3 9 6 6 73 29) #344# #2# 119267) si::fset)) #2# 119267) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #345=#A(t (17) (swank::prepare-title swank::istate swank::istate.verbose swank::*inspector-verbose-printer-bindings* swank::istate.object swank::to-string #Y(nil nil nil (26 13 0 19 1 4 12 19 1 5 29) #345# #2# 119460) swank::call-with-bindings swank::*inspector-printer-bindings* stream t si::print-unreadable-object-function #Y(nil nil nil (24 45 9 26 13 1 19 1 4 12 13 0 14 10 14 10 77 19 5 11 29) #345# #2# 119460) swank::call/truncated-output-to-string #Y(nil nil nil (26 9 200 34 12 12 19 2 13 29) #345# #2# 119460) #Y(swank::prepare-title nil nil (24 45 1 26 13 0 19 1 2 39 11 14 3 34 6 12 19 2 7 38 9 14 8 34 14 12 19 2 7 29) #345# #2# 119460) si::fset)) #2# 119460) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #346=#A(t (25) (swank::prepare-range swank::istate swank::start swank::end swank::istate.content swank::content-range swank::range #:loop-list3105 swank::part #:loop-list-head3106 #:loop-list-tail3107 0 #:g3108 swank::prepare-part copy-list #:g3109 rplacd last swank::ps length - < + #Y(swank::prepare-range nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 12 13 1 13 0 19 3 5 45 6 58 60 94 77 13 1 46 7 46 8 75 6 1 45 9 10 0 45 10 57 11 61 2 2 60 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 12 13 4 13 10 19 2 13 16 14 45 15 13 1 10 0 17 16 10 0 43 1 43 1 39 10 10 1 5 12 19 1 17 51 1 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 45 18 13 0 10 0 16 19 12 13 2 13 3 19 2 20 12 19 2 21 39 13 13 3 10 0 16 19 12 19 2 22 38 8 13 2 9 1000 19 2 22 12 13 3 10 2 6 4 73 43 2 29) #346# #2# 119853) si::fset)) #2# 119853) #Y(si::bytecodes nil nil (15 0 1 57 12 19 2 58 1 0 73 29) #347=#A(t (59) (swank::prepare-part swank::part swank::istate "
" swank::newline #:g3125 string typep cons #:|tmp-3128| #:|op-3126| #:|rand-3127| :newline #:g3129 #:g3130 si::dm-too-many-arguments :value #:g3131 #:g3132 si::dm-too-few-arguments swank::obj swank::str swank::istate.parts swank::value-part :label #:g3133 #:g3134 swank::strs swank::cat mapcar apply :action #:g3135 #:g3136 swank::label lambda :refreshp si::search-keyword #:g3137 si::missing-keyword eq t swank::refreshp (:refreshp) si::check-keyword swank::istate.actions swank::action-part :line #:g3138 #:g3139 swank::value princ-to-string ": " #61# error (string cons) si::etypecase-error #Y(swank::prepare-part nil nil (24 45 1 24 45 2 26 1 3 45 4 10 2 45 5 13 0 15 6 19 2 7 39 8 10 3 6 1 73 38 396 13 0 15 8 19 2 7 39 381 10 3 45 9 10 0 4 45 10 10 1 5 45 11 10 1 42 12 27 10 0 45 13 10 0 45 14 10 0 39 6 13 1 19 1 15 10 6 6 1 73 43 2 38 332 42 16 79 10 0 45 17 10 0 45 18 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 20 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 21 10 2 39 6 13 3 19 1 15 13 1 13 0 13 9 19 1 22 12 19 3 23 6 1 73 43 4 38 251 42 24 39 10 0 45 25 10 0 45 26 10 0 45 27 14 24 33 28 12 33 6 12 13 0 19 2 29 12 19 2 30 6 2 6 1 73 43 3 38 210 42 31 107 10 0 45 32 10 0 45 33 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 34 10 1 76 39 6 13 2 19 1 19 10 1 4 12 10 1 5 51 1 22 45 35 13 2 15 36 19 2 37 45 38 13 0 1 39 17 40 39 5 11 41 38 3 10 0 45 42 13 4 15 43 19 2 44 13 3 13 2 13 0 13 11 19 1 45 12 19 4 46 6 1 73 43 6 38 101 42 47 91 10 0 45 48 10 0 45 49 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 34 10 1 76 39 6 13 2 19 1 19 10 1 4 12 10 1 5 51 1 22 45 50 10 2 39 6 13 3 19 1 15 10 1 16 51 12 15 52 13 0 77 13 9 19 1 22 12 19 3 23 12 10 8 6 4 73 43 4 38 8 15 53 13 2 19 2 54 43 3 38 7 13 0 1 55 17 56 43 1 43 1 29) #347# #2# 120189) si::fset)) #2# 120189) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #348=#A(t (9) (swank::value-part swank::object string swank::parts :value swank::print-part-to-string swank::assign-index #Y(swank::value-part nil nil (24 45 1 24 45 2 24 45 3 26 14 4 10 1 73 40 6 13 2 19 1 5 12 13 2 13 0 19 2 6 6 3 73 29) #348# #2# 120986) si::fset)) #2# 120986) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #349=#A(t (9) (swank::action-part swank::label lambda swank::refreshp swank::actions :action swank::assign-index #Y(swank::action-part nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 14 5 13 3 13 2 10 1 6 2 12 13 0 19 2 6 6 3 73 29) #349# #2# 121136) si::fset)) #2# 121136) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #350=#A(t (8) (swank::assign-index swank::object vector fill-pointer swank::index vector-push-extend #Y(swank::assign-index nil nil (24 45 1 24 45 2 26 10 0 16 3 45 4 13 2 13 1 19 2 5 10 0 73 43 1 29) #350# #2# 121261) si::fset)) #2# 121261) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #351=#A(t (12) (swank::print-part-to-string swank::value *print-readably* swank::to-line string swank::*inspector-history* position swank::pos "@~D=~A" format #Y(swank::print-part-to-string nil nil (24 45 1 26 75 48 2 13 0 19 1 3 45 4 13 1 14 5 19 2 6 45 7 10 0 39 13 77 15 8 13 0 13 1 19 4 9 38 4 10 1 73 43 2 44 1 29) #351# #2# 121393) si::fset)) #2# 121393) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #352=#A(t (14) (swank::content-range list swank::start swank::end #:g3141 typep length swank::len min subseq swank::lcons swank::llist-range #Y(swank::content-range nil nil (24 45 1 24 45 2 24 45 3 26 10 2 45 4 13 0 15 1 19 2 5 39 26 10 3 16 6 45 7 13 4 13 3 13 0 13 2 19 2 8 12 19 3 9 43 1 38 23 13 0 15 10 19 2 5 39 12 13 3 13 2 13 1 19 3 11 38 3 75 73 43 1 29) #352# #2# 121628) si::fset)) #2# 121628) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 1 0 16 7 12 19 2 8 29) #353=#A(t (9) (swank::inspector-nth-part swank::index swank::*istate* swank::istate.parts aref #Y(swank::inspector-nth-part nil nil (24 45 1 26 14 2 19 1 3 12 13 0 19 2 4 29) #353# #2# 121818) si::fset symbol-package export)) #2# 121818) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #354=#A(t (10) (swank::inspect-nth-part swank::index swank::inspector-nth-part swank::inspect-object #Y(nil nil nil (26 13 0 19 1 2 12 19 1 3 29) #354# #2# 121902) swank::call-with-buffer-syntax #Y(swank::inspect-nth-part nil nil (24 45 1 26 77 34 4 12 19 2 5 29) #354# #2# 121902) si::fset symbol-package export)) #2# 121902) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 1 0 16 7 12 19 2 8 29) #355=#A(t (9) (swank::inspector-range swank::from swank::to swank::*istate* swank::prepare-range #Y(swank::inspector-range nil nil (24 45 1 24 45 2 26 14 3 13 1 13 0 19 3 4 29) #355# #2# 122020) si::fset symbol-package export)) #2# 122020) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 1 0 16 16 12 19 2 17 29) #356=#A(t (18) (swank::inspector-call-nth-action swank::index swank::args swank::*istate* swank::istate.actions aref #:g3144 #:g3145 si::dm-too-few-arguments swank::fun swank::refreshp si::dm-too-many-arguments apply swank::inspector-reinspect #Y(swank::inspector-call-nth-action nil nil (24 45 1 27 45 2 14 3 19 1 4 12 13 1 19 2 5 45 6 10 0 45 7 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 9 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 10 10 2 39 6 13 3 19 1 11 13 1 13 4 19 2 12 10 0 39 6 19 0 13 38 3 75 73 43 4 29) #356# #2# 122099) si::fset symbol-package export)) #2# 122099) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #357=#A(t (13) (swank::inspector-pop swank::*istate* swank::istate.previous swank::istate>elisp #Y(nil nil nil (26 14 1 19 1 2 39 15 14 1 19 1 2 52 1 14 1 19 1 3 38 3 75 73 29) #357# #2# 122398) swank::call-with-buffer-syntax #Y(swank::inspector-pop nil nil (26 77 34 4 12 19 2 5 29) #357# #2# 122398) si::fset function "Inspect the previous object.
Return nil if there's no previous object." si::set-documentation symbol-package export)) #2# 122398) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #358=#A(t (13) (swank::inspector-next swank::*istate* swank::istate.next swank::istate>elisp #Y(nil nil nil (26 14 1 19 1 2 39 15 14 1 19 1 2 52 1 14 1 19 1 3 38 3 75 73 29) #358# #2# 122687) swank::call-with-buffer-syntax #Y(swank::inspector-next nil nil (26 77 34 4 12 19 2 5 29) #358# #2# 122687) si::fset function "Inspect the next element in the history of inspected objects.." si::set-documentation symbol-package export)) #2# 122687) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 1 0 16 10 12 19 2 11 29) #359=#A(t (12) (swank::inspector-reinspect swank::*istate* swank::istate #:g3148 swank::emacs-inspect/istate #:g3149 si::structure-set swank::istate>elisp #Y(swank::inspector-reinspect nil nil (26 11 1 45 2 10 0 45 3 13 1 19 1 4 45 5 13 1 15 2 9 5 13 0 19 4 6 43 1 43 1 13 0 19 1 7 43 1 29) #359# #2# 122960) si::fset symbol-package export)) #2# 122960) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 15 0 1 0 16 13 12 19 2 14 29) #360=#A(t (15) (swank::inspector-toggle-verbose swank::*istate* #:g3152 swank::istate.verbose #:g3153 swank::istate si::structure-set swank::istate>elisp #Y(swank::inspector-toggle-verbose nil nil (26 11 1 45 2 14 1 19 1 3 76 45 4 13 1 15 5 9 1 13 0 19 4 6 43 1 43 1 14 1 19 1 7 29) #360# #2# 123122) si::fset function "Toggle verbosity of inspected object." si::set-documentation symbol-package export)) #2# 123122) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 15 0 1 0 16 36 12 19 2 37 29) #361=#A(t (38) (swank::inspector-eval string swank::*istate* swank::istate.object swank::obj swank-backend::eval-context swank::context *package* assoc read-from-string #Y(nil nil nil (26 13 2 19 1 9 29) #361# #2# 123305) swank::call-with-buffer-syntax swank::form boundp car mapcar remove-if ignorable let * quote - #:loop-list3157 swank::val swank::var #:loop-list-head3158 #:loop-list-tail3159 0 #60# constantp rplacd declare eval swank::to-string #Y(swank::inspector-eval nil nil (24 45 1 26 14 2 19 1 3 45 4 13 0 19 1 5 45 6 15 7 13 0 19 2 8 5 12 34 10 12 19 2 11 45 12 33 13 12 33 14 12 13 1 19 2 15 12 19 2 16 45 17 15 18 15 19 15 20 10 3 6 2 6 2 12 15 21 15 20 10 1 6 2 6 2 12 58 60 101 77 77 13 3 46 22 46 23 46 24 75 6 1 45 25 10 0 45 26 57 27 61 2 2 64 10 5 2 39 4 35 0 1 10 5 4 45 28 10 0 4 51 4 10 0 5 51 0 10 0 51 5 43 1 10 5 5 51 5 13 3 19 1 29 76 39 19 13 1 13 3 15 20 10 4 6 2 6 2 6 1 51 1 17 30 35 0 0 10 2 5 73 36 6 62 43 2 43 3 63 7 3 12 15 31 15 17 10 0 7 2 6 2 12 10 1 6 4 16 32 12 19 1 33 43 4 29) #361# #2# 123305) si::fset symbol-package export)) #2# 123305) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 15 0 1 0 16 33 12 19 2 34 29) #362=#A(t (35) (swank::inspector-history make-string-output-stream swank::out swank::s swank::next 0 swank::*istate* swank::istate.next swank::newest "--- next/prev chain ---" format swank::istate.object swank::val "~%~:[  ~; *~]@~d " eq swank::*inspector-history* position t si::print-unreadable-object-function swank::istate.previous "~%~%--- all visited objects ---" #:loop-across-list3165 #:loop-across-index-3164 #:loop-across-vector-3163 swank::i length >= aref 1+ "~%~2,' d " get-output-stream-string #Y(swank::inspector-history nil nil (26 19 0 1 45 2 58 60 47 75 45 3 75 45 4 57 5 61 2 6 29 11 6 51 2 13 2 19 1 7 51 1 10 1 76 39 6 10 2 73 36 3 10 1 51 2 35 0 0 62 43 1 43 1 63 45 8 13 1 15 9 19 2 10 75 45 3 57 5 61 2 6 66 10 2 51 1 10 1 76 39 4 35 0 1 13 1 19 1 11 45 12 13 4 15 13 13 2 11 6 17 14 12 13 0 14 15 19 2 16 12 19 4 10 13 0 13 4 14 17 14 17 77 19 5 18 43 1 13 1 19 1 19 51 1 35 0 0 62 43 1 43 1 13 0 15 20 19 2 10 77 14 15 9 0 9 0 46 21 46 22 46 23 46 12 8 0 45 24 57 5 61 2 35 91 10 3 16 25 51 5 13 4 13 5 19 2 26 39 4 35 0 1 13 3 13 4 19 2 27 51 2 10 4 16 28 51 4 13 6 15 29 13 1 19 3 10 13 2 13 6 14 17 14 17 77 19 5 18 13 4 13 5 19 2 26 39 4 35 0 1 13 3 13 4 19 2 27 51 2 10 4 16 28 51 4 10 1 16 28 51 1 35 0 0 62 43 1 43 4 10 0 16 30 43 1 29) #362# #2# 123945) si::fset symbol-package export)) #2# 123945) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 1 0 16 4 12 19 2 5 29) #363=#A(t (6) (swank::quit-inspector swank::reset-inspector #Y(swank::quit-inspector nil nil (26 19 0 1 75 73 29) #363# #2# 124765) si::fset symbol-package export)) #2# 124765) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #364=#A(t (13) (swank::describe-inspectee swank::*istate* swank::istate.object swank::describe-to-string #Y(nil nil nil (26 14 1 19 1 2 12 19 1 3 29) #364# #2# 124828) swank::call-with-buffer-syntax #Y(swank::describe-inspectee nil nil (26 77 34 4 12 19 2 5 29) #364# #2# 124828) si::fset function "Describe the currently inspected object." si::set-documentation symbol-package export)) #2# 124828) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 15 0 1 0 16 11 12 19 2 12 29) #365=#A(t (13) (swank::pprint-inspector-part swank::index swank::inspector-nth-part swank::swank-pprint #Y(nil nil nil (26 13 0 19 1 2 6 1 12 19 1 3 29) #365# #2# 124991) swank::call-with-buffer-syntax #Y(swank::pprint-inspector-part nil nil (24 45 1 26 77 34 4 12 19 2 5 29) #365# #2# 124991) si::fset function "Pretty-print the currently inspected object." si::set-documentation symbol-package export)) #2# 124991) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 1 0 16 14 12 19 2 15 29) #366=#A(t (16) (swank::inspect-in-frame string swank::index "Retry SLIME inspection request." swank::reset-inspector swank::from-string swank-backend::eval-in-frame swank::inspect-object #Y(nil nil nil (26 19 0 4 13 1 19 1 5 12 13 0 19 2 6 12 19 1 7 29) #366# #2# 125169) swank::call-with-retry-restart #Y(nil nil nil (26 15 3 34 8 12 19 2 9 29) #366# #2# 125169) swank::call-with-buffer-syntax #Y(swank::inspect-in-frame nil nil (24 45 1 24 45 2 26 77 34 10 12 19 2 11 29) #366# #2# 125169) si::fset symbol-package export)) #2# 125169) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 1 0 16 8 12 19 2 9 29) #367=#A(t (10) (swank::inspect-current-condition swank::reset-inspector swank::*swank-debugger-condition* swank::inspect-object #Y(nil nil nil (26 19 0 1 14 2 19 1 3 29) #367# #2# 125404) swank::call-with-buffer-syntax #Y(swank::inspect-current-condition nil nil (26 77 34 4 12 19 2 5 29) #367# #2# 125404) si::fset symbol-package export)) #2# 125404) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 1 0 16 10 12 19 2 11 29) #368=#A(t (12) (swank::inspect-frame-var swank::frame swank::var swank::reset-inspector swank-backend::frame-var-value swank::inspect-object #Y(nil nil nil (26 19 0 3 13 1 13 0 19 2 4 12 19 1 5 29) #368# #2# 125549) swank::call-with-buffer-syntax #Y(swank::inspect-frame-var nil nil (24 45 1 24 45 2 26 77 34 6 12 19 2 7 29) #368# #2# 125549) si::fset symbol-package export)) #2# 125549) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 7 12 14 8 19 6 9 29) #369=#A(t (10) (swank-backend::emacs-inspect (cons) (swank::o) swank::o listp swank::inspect-list swank::inspect-cons #Y(nil nil nil (24 45 3 26 10 0 5 16 4 39 8 13 0 19 1 5 38 6 13 0 19 1 6 29) #369# #2# 125696) t clos::install-method)) #2# 125696) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #370=#A(t (8) (swank::inspect-cons cons car swank-backend::label-value-line cdr append #Y(swank::inspect-cons nil nil (24 45 1 26 15 2 10 0 4 12 19 2 3 12 15 4 10 0 5 12 19 2 3 12 19 2 5 29) #370# #2# 125823) si::fset)) #2# 125823) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #371=#A(t (15) (swank::inspect-list list swank::safe-length swank::tail length swank::title (:newline) swank::inspect-list-aux #Y(swank::frob nil nil (24 45 5 24 45 1 26 13 1 15 6 13 0 19 1 7 7 3 73 29) #371# #2# 125922) "A circular list:" ldiff "A proper list:" "An improper list:" #Y(swank::inspect-list nil nil (24 45 1 26 13 0 19 1 2 47 1 3 45 4 30 1 8 10 1 76 39 23 15 9 10 3 4 12 10 3 5 12 10 3 17 10 3 12 32 0 18 2 38 24 10 2 76 39 11 15 11 13 3 32 0 18 2 38 9 15 12 13 3 32 0 18 2 43 1 43 2 29) #371# #2# 125922) si::fset)) #2# 125922) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #372=#A(t (21) (swank::inspect-list-aux list swank::i rest #:loop-list-head3170 #:loop-list-tail3171 0 atom consp #:g3172 listp swank-backend::label-value-line :tail append copy-list #:g3173 rplacd last 1+ #Y(swank::inspect-list-aux nil nil (24 45 1 26 58 60 144 8 0 45 2 10 2 45 3 75 6 1 45 4 10 0 45 5 57 6 61 2 2 106 10 3 16 7 39 4 35 0 1 10 3 16 8 76 39 4 35 0 1 10 1 45 9 10 4 5 16 10 39 12 13 5 10 4 4 12 19 2 11 38 24 13 5 10 4 4 12 19 2 11 12 14 12 10 4 5 12 19 2 11 12 19 2 13 16 14 45 15 13 1 10 0 17 16 10 0 43 1 43 1 39 10 10 1 5 12 19 1 17 51 1 10 4 16 18 51 4 10 3 5 51 3 35 0 0 10 2 5 73 36 5 62 73 43 2 43 1 43 1 63 29) #372# #2# 126398) si::fset)) #2# 126398) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #373=#A(t (16) (swank::safe-length list swank::slow swank::fast swank::n consp 1+ eq > + cddr #Y(swank::safe-length nil nil (24 45 1 26 58 60 142 9 0 13 1 13 1 46 2 46 3 46 4 38 120 10 1 76 39 10 13 0 77 72 2 36 3 38 83 10 1 16 5 76 39 11 13 0 13 1 72 2 36 3 38 66 10 1 5 76 39 16 10 0 16 6 12 10 1 5 12 72 2 36 3 38 45 13 1 10 2 17 7 39 8 13 0 9 0 19 2 8 39 7 75 73 36 3 38 22 10 1 5 16 5 76 39 14 10 0 16 6 12 10 1 5 12 72 2 36 3 13 0 9 2 19 2 9 12 10 1 16 10 12 10 2 5 12 53 2 53 1 53 0 75 39 -121 75 73 43 3 63 29) #373# #2# 126648) si::fset function "Similar to `list-length', but avoid errors on improper lists.
Return two values: the length of the list and the last cdr.
Return NIL if LIST is circular." si::set-documentation)) #2# 126648) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #374=#A(t (10) (swank::hash-table-to-alist swank::ht swank::result swank::key swank::value acons #Y(nil nil nil (24 45 3 24 45 4 26 13 1 13 0 13 2 19 3 5 51 2 73 29) #374# #2# 127343) maphash #Y(swank::hash-table-to-alist nil nil (24 45 1 26 75 45 2 34 6 12 10 1 17 7 10 0 73 43 1 29) #374# #2# 127343) si::fset)) #2# 127343) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 58 12 14 59 19 6 60 29) #375=#A(t (61) (swank-backend::emacs-inspect (hash-table) (swank::ht) swank::ht "Count" hash-table-count swank-backend::label-value-line "Size" hash-table-size "Test" hash-table-test "Rehash size" hash-table-rehash-size "Rehash threshold" hash-table-rehash-threshold append swank-backend::hash-table-weakness swank::weakness "Weakness:" zerop :action "[clear hashtable]" clrhash #Y(nil nil nil (26 10 0 16 22 29) #375# #2# 127544) ((:newline) "Contents: " (:newline)) swank::hash-table-to-alist swank::content swank::x (or string symbol) typep #Y(nil nil nil (24 45 27 26 10 0 4 12 15 28 19 2 29 29) #375# #2# 127544) every string< :key first sort number #Y(nil nil nil (24 45 27 26 10 0 4 12 15 36 19 2 29 29) #375# #2# 127544) < #:loop-list3197 swank::value swank::key #:loop-list-head3198 #:loop-list-tail3199 0 #60# #:g3200 :value " = " " " "[remove entry]" remhash #Y(nil nil nil (26 13 0 10 10 17 51 29) #375# #2# 127544) (:newline) copy-list #:g3201 rplacd last #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 15 7 10 0 16 8 12 19 2 6 12 15 9 10 0 16 10 12 19 2 6 12 15 11 10 0 16 12 12 19 2 6 12 15 13 10 0 16 14 12 19 2 6 12 19 5 15 12 13 0 19 1 16 45 17 10 0 73 39 8 15 18 13 0 19 2 6 12 43 1 10 0 16 5 16 19 76 73 39 15 14 20 15 21 34 23 6 3 12 1 24 7 2 73 12 13 0 19 1 25 45 26 34 30 12 13 0 19 2 31 39 17 13 0 15 32 14 33 33 34 12 19 4 35 51 0 38 25 34 37 12 13 0 19 2 31 39 15 13 0 15 38 14 33 33 34 12 19 4 35 51 0 58 60 144 77 77 13 1 46 39 46 40 46 41 75 6 1 45 42 10 0 45 43 57 44 61 2 2 106 10 5 2 39 4 35 0 1 10 5 4 45 45 10 0 4 51 4 10 0 5 51 0 10 0 51 5 43 1 10 5 5 51 5 10 1 45 46 14 47 10 4 6 2 12 15 48 14 47 10 5 6 2 12 15 49 14 20 15 50 10 4 45 41 34 52 43 1 6 3 12 1 53 6 6 16 54 45 55 13 1 10 0 17 56 10 0 43 1 43 1 39 10 10 1 5 12 19 1 57 51 1 35 0 0 10 2 5 73 36 6 62 73 43 2 43 3 63 12 43 1 19 4 15 29) #375# #2# 127544) t clos::install-method)) #2# 127544) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 33 12 14 34 19 6 35 29) #376=#A(t (36) (swank-backend::emacs-inspect (array) (array) array "Dimensions" array-dimensions swank::iline "Element type" array-element-type "Total size" array-total-size "Adjustable" adjustable-array-p "Fill pointer" array-has-fill-pointer-p fill-pointer "Contents:" (:newline) swank::i max = row-major-aref 1+ #Y(nil nil nil (26 10 1 16 22 12 13 0 32 2 18 2 29) #376# #2# 128732) swank::%lcons #Y(swank::k nil nil (24 45 18 24 45 19 26 13 1 13 0 19 2 20 39 5 75 73 38 20 13 1 13 3 10 1 17 21 12 19 2 6 12 34 23 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 31 1 25 9 0 10 1 16 10 12 32 0 18 2 43 1 29) #376# #2# 128732) #Y(nil nil nil (26 15 17 34 26 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 15 16 34 27 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 15 13 10 0 16 14 73 39 5 10 0 16 15 12 19 2 6 12 34 28 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 15 11 10 0 16 12 12 19 2 6 12 34 29 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 15 9 10 0 16 10 12 19 2 6 12 34 30 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (26 15 7 10 0 16 8 12 19 2 6 12 34 31 12 19 2 24 29) #376# #2# 128732) #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 34 32 12 19 2 24 29) #376# #2# 128732) t clos::install-method)) #2# 128732) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 17 12 14 18 19 6 19 29) #377=#A(t (20) (swank-backend::emacs-inspect (character) (char) char "Char code" char-code swank-backend::label-value-line "Lower cased" char-downcase "Upper cased" char-upcase append get-macro-character "In the current readtable (" :value *readtable* ") it is a macro character: " #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 15 7 10 0 16 8 12 19 2 6 12 15 9 10 0 16 10 12 19 2 6 12 19 3 11 12 13 0 19 1 12 73 39 24 15 13 14 14 11 15 6 2 12 15 16 14 14 13 0 19 1 12 6 2 6 4 73 12 19 2 11 29) #377# #2# 129371) t clos::install-method)) #2# 129371) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*thread-list* si::*make-special boundp variable "List of threads displayed in Emacs.  We don't care a about
synchronization issues (yet).  There can only be one thread listing at
a time." si::set-documentation)) #2# 129775) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 15 0 15 40 15 41 19 3 42 15 0 1 0 16 43 12 19 2 44 29) #378=#A(t (45) (swank::list-threads swank-backend::all-threads swank::*thread-list* swank::*emacs-connection* swank::use-threads-p swank-backend::current-thread swank-backend::thread-name "worker" equalp delete swank-backend::thread-attributes swank::plist swank::key #:g3213 #:loop-list-head3214 #:loop-list-tail3215 0 atom cddr rplacd labels :id :name :status #:loop-list3216 swank::thread swank::name swank::attributes #:loop-list-head3217 #:loop-list-tail3218 swank-backend::thread-id string swank-backend::thread-status #:loop-list3219 swank::label #:loop-list-head3220 #:loop-list-tail3221 getf #Y(swank::list-threads nil nil (26 19 0 1 52 2 11 3 39 18 19 0 4 39 13 19 0 5 12 19 1 6 12 1 7 17 8 39 12 19 0 5 12 14 2 19 2 9 52 2 11 2 4 12 19 1 10 45 11 58 60 68 13 1 77 46 12 46 13 75 6 1 45 14 10 0 45 15 57 16 61 2 2 34 10 3 16 17 39 4 35 0 1 10 3 4 51 4 10 3 16 18 51 3 13 1 10 4 6 1 51 1 17 19 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 45 20 14 21 14 22 14 23 10 0 7 4 12 58 60 180 77 14 2 46 24 46 25 75 45 26 75 45 27 75 6 1 45 28 10 0 45 29 57 16 61 2 2 136 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 13 5 19 1 6 51 4 13 5 19 1 10 51 3 13 1 13 5 19 1 30 12 10 4 16 31 12 13 5 19 1 32 12 58 60 71 77 13 9 46 33 46 34 75 6 1 45 35 10 0 45 36 57 16 61 2 2 37 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 9 13 3 19 2 37 6 1 51 1 17 19 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 4 6 1 51 1 17 19 35 0 0 10 2 5 73 36 7 62 43 2 43 1 43 1 43 2 63 7 2 73 43 2 29) #378# #2# 129973) si::fset function "Return a list (LABELS (ID NAME STATUS ATTRS ...) ...).
LABELS is a list of attribute names and the remaining lists are the
corresponding attribute values per thread.  
Example: 
  ((:id :name :status :priority)
   (6 \"swank-indentation-cache-thread\" \"Semaphore timed wait\" 0)
   (5 \"reader-thread\" \"Active\" 0)
   (4 \"control-thread\" \"Semaphore timed wait\" 0)
   (2 \"Swank Sentinel\" \"Semaphore timed wait\" 0)
   (1 \"listener\" \"Active\" 0)
   (0 \"Initial\" \"Sleep\" 0))" si::set-documentation symbol-package export)) #2# 129973) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 1 0 16 4 12 19 2 5 29) #379=#A(t (6) (swank::quit-thread-browser swank::*thread-list* #Y(swank::quit-thread-browser nil nil (26 75 52 1 73 29) #379# #2# 131353) si::fset symbol-package export)) #2# 131353) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #380=#A(t (6) (swank::nth-thread swank::index swank::*thread-list* nth #Y(swank::nth-thread nil nil (24 45 1 26 13 0 11 2 17 3 29) #380# #2# 131421) si::fset)) #2# 131421) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 15 0 1 0 16 38 12 19 2 39 29) #381=#A(t (40) (swank::debug-nth-thread swank::index swank::*emacs-connection* swank::connection swank::nth-thread swank::simple-break #Y(nil nil nil (26 19 0 5 29) #381# #2# 131480) function eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g3226 #:g3227 #:g3228 0 swank::swank-error si::temp #Y(nil nil nil (24 45 17 26 10 0 51 2 35 1 0 29) #381# #2# 131480) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 20 26 11 21 73 39 6 13 0 19 1 22 29) #381# #2# 131480) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 25 12 13 5 19 2 26 29) #381# #2# 131480) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(nil nil nil (26 13 0 34 6 12 46 7 46 3 14 2 10 0 17 8 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 9 49 10 49 2 75 48 11 10 0 45 12 57 13 60 83 75 45 14 57 15 61 1 45 15 16 34 18 3 6 1 12 11 19 3 48 19 15 16 34 23 3 6 1 12 11 19 3 48 19 13 4 19 1 24 12 34 27 12 19 2 28 44 1 36 2 44 1 10 1 45 20 13 4 13 0 19 1 29 12 13 0 19 1 30 12 19 3 31 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #381# #2# 131480) swank::invoke-or-queue-interrupt #Y(nil nil nil (26 34 32 12 19 1 33 29) #381# #2# 131480) swank-backend::interrupt-thread #Y(swank::debug-nth-thread nil nil (24 45 1 26 11 2 45 3 13 1 19 1 4 12 34 34 12 19 2 35 43 1 29) #381# #2# 131480) si::fset symbol-package export)) #2# 131480) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 15 0 1 0 16 6 12 19 2 7 29) #382=#A(t (8) (swank::kill-nth-thread swank::index swank::nth-thread swank-backend::kill-thread #Y(swank::kill-nth-thread nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #382# #2# 131838) si::fset symbol-package export)) #2# 131838) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 0 15 10 15 11 19 3 12 15 0 1 0 16 13 12 19 2 14 29) #383=#A(t (15) (swank::start-swank-server-in-thread swank::index swank::port-file-name swank::nth-thread :style swank::start-server #Y(nil nil nil (26 13 0 14 4 77 19 3 5 29) #383# #2# 131915) swank-backend::interrupt-thread #Y(swank::start-swank-server-in-thread nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 34 6 12 19 2 7 29) #383# #2# 131915) si::fset function "Interrupt the INDEXth thread and make it start a swank server.
The server port is written to PORT-FILE-NAME." si::set-documentation symbol-package export)) #2# 131915) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #384=#A(t (11) (swank::mop-helper class-name swank::fn find-class class swank::x swank::to-string #Y(nil nil nil (24 45 5 26 13 0 19 1 1 12 19 1 6 29) #384# #2# 132237) mapcar #Y(swank::mop-helper nil nil (24 45 1 24 45 2 26 13 1 77 19 2 3 45 4 10 0 73 39 15 34 7 12 13 1 13 0 20 1 23 12 19 2 8 43 1 29) #384# #2# 132237) si::fset)) #2# 132237) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 15 0 1 0 16 19 12 19 2 20 29) #385=#A(t (21) (swank::mop type symbol-name swank::*buffer-package* swank::parse-symbol symbol #:g3231 :subclasses clos::class-direct-subclasses swank::mop-helper :superclasses clos::class-direct-superclasses (:subclasses :superclasses) si::ecase-error #Y(swank::mop nil nil (24 45 1 24 45 2 26 13 0 14 3 19 2 4 45 5 10 2 45 6 10 0 42 7 11 13 1 33 8 12 19 2 9 38 20 42 10 11 13 1 33 11 12 19 2 9 38 7 13 0 1 12 17 13 43 1 43 1 29) #385# #2# 132455) si::fset function "Return info about classes using mop.

    When type is:
     :subclasses - return the list of subclasses of class.
     :superclasses - return the list of superclasses of class." si::set-documentation symbol-package export)) #2# 132455) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #386=#A(t (12) (swank::sync-features-to-emacs swank::*slime-features* *features* eq :new-features swank::features-for-emacs swank::send-to-emacs #Y(swank::sync-features-to-emacs nil nil (26 14 1 11 2 17 3 76 73 39 16 11 2 52 1 14 4 19 0 5 6 2 12 19 1 6 29) #386# #2# 132939) si::fset function "Update Emacs if any relevant Lisp state has changed." si::set-documentation)) #2# 132939) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 15 0 15 4 15 5 19 3 6 1 0 73 29) #387=#A(t (7) (swank::features-for-emacs swank::*slime-features* #Y(swank::features-for-emacs nil nil (26 11 1 73 29) #387# #2# 133386) si::fset function "Return `*slime-features*' in a format suitable to send it to Emacs." si::set-documentation)) #2# 133386) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::sync-features-to-emacs swank::*pre-reply-hook* adjoin)) #2# 133512) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*configure-emacs-indentation* si::*make-special boundp t variable "When true, automatically send indentation information to Emacs
after each command." si::set-documentation)) #2# 133567) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 1 0 16 5 12 19 2 6 29) #388=#A(t (7) (swank::update-indentation-information (:update-indentation-information) swank::send-to-indentation-cache #Y(swank::update-indentation-information nil nil (26 15 1 19 1 2 75 73 29) #388# #2# 134079) si::fset symbol-package export)) #2# 134079) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #389=#A(t (10) (swank::sync-indentation-to-emacs swank::*configure-emacs-indentation* :sync-indentation swank::*buffer-package* swank::send-to-indentation-cache #Y(swank::sync-indentation-to-emacs nil nil (26 11 1 73 39 11 14 2 11 3 6 2 12 19 1 4 29) #389# #2# 134203) si::fset function "Send any indentation updates to Emacs via CONNECTION." si::set-documentation)) #2# 134203) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #390=#A(t (16) (swank::send-to-indentation-cache swank::request swank::*emacs-connection* swank::c #:g3234 swank::singlethreaded-connection typep swank::handle-indentation-cache-request swank::multithreaded-connection swank::*slime-interrupts-enabled* swank::mconn.indentation-cache-thread swank-backend::send (swank::singlethreaded-connection swank::multithreaded-connection) si::etypecase-error #Y(swank::send-to-indentation-cache nil nil (24 45 1 26 11 2 45 3 10 0 45 4 13 0 15 5 19 2 6 39 10 13 1 13 2 19 2 7 38 34 13 0 15 8 19 2 6 39 19 75 48 9 13 1 19 1 10 12 13 2 19 2 11 44 1 38 7 13 0 1 12 17 13 43 1 43 1 29) #390# #2# 134457) si::fset)) #2# 134457) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 1 0 73 29) #391=#A(t (33) (swank::indentation-cache-loop swank::connection 0 swank-backend::receive swank::handle-indentation-cache-request #Y(nil nil nil (26 57 2 61 1 1 13 1 19 0 3 12 19 2 4 35 0 0 62 73 29) #391# #2# 134937) function swank::*emacs-connection* eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g3241 #:g3242 #:g3243 swank::swank-error si::temp #Y(nil nil nil (24 45 16 26 10 0 51 2 35 1 0 29) #391# #2# 134937) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 19 26 11 20 73 39 6 13 0 19 1 21 29) #391# #2# 134937) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 24 12 13 5 19 2 25 29) #391# #2# 134937) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(swank::indentation-cache-loop nil nil (24 45 1 26 13 0 34 5 12 46 6 46 1 14 7 10 0 17 8 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 9 49 10 49 7 75 48 11 10 0 45 12 57 13 60 83 75 45 14 57 2 61 1 45 15 15 34 17 3 6 1 12 11 18 3 48 18 15 15 34 22 3 6 1 12 11 18 3 48 18 13 4 19 1 23 12 34 26 12 19 2 27 44 1 36 2 44 1 10 1 45 19 13 4 13 0 19 1 28 12 13 0 19 1 29 12 19 3 30 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #391# #2# 134937) si::fset)) #2# 134937) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #392=#A(t (23) (swank::handle-indentation-cache-request swank::connection swank::request #:|tmp-3254| #:|op-3252| #:|rand-3253| :sync-indentation #:g3255 #:g3256 si::dm-too-few-arguments package si::dm-too-many-arguments swank::need-full-indentation-update-p swank::fullp swank::perform-indentation-update :update-indentation-information #:g3257 #:g3258 t #61# error #Y(swank::handle-indentation-cache-request nil nil (24 45 1 24 45 2 26 10 0 45 3 10 0 4 45 4 10 1 5 45 5 10 1 42 6 62 10 0 45 7 10 0 45 8 10 0 76 39 6 13 1 19 1 9 10 0 4 12 10 0 5 51 0 22 45 10 10 1 39 6 13 2 19 1 11 13 7 19 1 12 45 13 13 8 13 0 13 1 19 3 14 43 1 43 3 38 40 42 15 30 10 0 45 16 10 0 45 17 10 0 39 6 13 1 19 1 11 13 6 14 18 77 19 3 14 43 2 38 8 15 19 13 2 19 2 20 43 3 29) #392# #2# 135092) si::fset)) #2# 135092) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #393=#A(t (10) (swank::need-full-indentation-update-p swank::connection list-all-packages swank::connection.indentation-cache-packages set-difference #Y(swank::need-full-indentation-update-p nil nil (24 45 1 26 19 0 2 12 13 0 19 1 3 12 19 2 4 29) #393# #2# 135443) si::fset function "Return true if the whole indentation cache should be updated.
This is a heuristic to avoid scanning all symbols all the time:
instead, we only do a full scan if the set of packages has changed." si::set-documentation)) #2# 135443) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 15 0 15 19 15 20 19 3 21 1 0 73 29) #394=#A(t (22) (swank::perform-indentation-update swank::connection swank::force package swank::connection.indentation-cache swank::cache clrhash swank::update-indentation/delta-for-emacs swank::delta #:g3263 list-all-packages #:g3264 si::structure-set #:g3265 #:g3266 :indentation-update swank::send-to-emacs #Y(swank::perform-indentation-update nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 45 5 10 2 39 5 10 0 16 6 13 0 13 2 13 1 19 3 7 45 8 10 4 45 9 19 0 10 45 11 13 1 15 1 9 10 13 0 19 4 12 43 1 43 1 10 0 76 76 73 39 34 10 4 45 13 10 2 45 14 13 1 15 1 9 9 13 0 19 4 12 43 1 43 1 14 15 10 0 6 2 12 19 1 16 43 1 43 1 29) #394# #2# 135809) si::fset function "Update the indentation cache in CONNECTION and update Emacs.
If FORCE is true then start again without considering the old cache." si::set-documentation)) #2# 135809) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 15 0 15 31 15 32 19 3 33 1 0 73 29) #395=#A(t (34) (swank::update-indentation/delta-for-emacs swank::cache swank::force package swank::alist symbol swank::symbol-indentation swank::indent gethash equal si::hash-set package-name swank::symbol-packages mapcar string-downcase swank::name swank::pkgs #Y(swank::consider nil nil (24 45 5 26 13 0 19 1 6 45 7 10 0 73 39 66 13 1 13 5 19 2 8 12 10 0 17 9 76 73 39 50 13 1 13 5 13 0 19 3 10 33 11 12 13 1 19 1 12 12 19 2 13 12 13 1 19 1 14 12 46 15 46 16 13 1 13 2 10 0 6 3 12 10 4 3 51 4 73 43 2 43 1 29) #395# #2# 136432) list-all-packages #314# t si::packages-iterator #:g3287 #:g3288 #285# #:g3289 #:g3290 symbol-package eq #Y(swank::update-indentation/delta-for-emacs nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 30 1 17 10 3 39 58 58 60 53 19 0 18 12 15 19 14 20 19 3 21 45 22 75 45 23 75 45 5 38 26 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 32 4 18 1 75 39 -27 43 3 63 38 65 58 60 62 13 3 15 24 14 20 19 3 21 45 25 75 45 26 75 45 5 38 37 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 10 0 16 27 12 10 6 17 28 39 7 13 0 32 4 18 1 75 39 -38 43 3 63 10 1 73 43 1 43 1 29) #395# #2# 136432) si::fset function "Update the cache and return the changes in a (SYMBOL INDENT PACKAGES) list.
If FORCE is true then check all symbols, otherwise only check symbols
belonging to PACKAGE." si::set-documentation)) #2# 136432) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #396=#A(t (10) (swank::package-names package package-name package-nicknames copy-list #Y(swank::package-names nil nil (24 45 1 26 10 0 16 2 12 10 0 16 3 16 4 3 73 29) #396# #2# 137451) si::fset function "Return the name and all nicknames of PACKAGE in a fresh list." si::set-documentation)) #2# 137451) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #397=#A(t (17) (swank::symbol-packages symbol string list-all-packages #:loop-list3294 swank::p #:loop-list-head3295 #:loop-list-tail3296 0 find-symbol eq rplacd #Y(swank::symbol-packages nil nil (24 45 1 26 10 0 16 2 45 2 58 60 82 77 19 0 3 12 46 4 46 5 75 6 1 45 6 10 0 45 7 57 8 61 2 2 45 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 7 13 6 13 3 19 2 9 17 10 39 11 13 1 10 3 6 1 51 1 17 11 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 43 1 29) #397# #2# 137626) si::fset function "Return the  packages where SYMBOL can be found." si::set-documentation)) #2# 137626) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #398=#A(t (10) (swank::cl-symbol-p symbol symbol-package swank::cl-package eq #Y(swank::cl-symbol-p nil nil (24 45 1 26 10 0 16 2 12 11 3 17 4 29) #398# #2# 137864) si::fset function "Is SYMBOL a symbol in the COMMON-LISP package?" si::set-documentation)) #2# 137864) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 15 5 15 6 19 3 7 1 0 73 29) #399=#A(t (8) (swank::known-to-emacs-p symbol swank::cl-symbol-p #Y(swank::known-to-emacs-p nil nil (24 45 1 26 13 0 19 1 2 29) #399# #2# 137991) si::fset function "Return true if Emacs has special rules for indenting SYMBOL." si::set-documentation)) #2# 137991) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #400=#A(t (17) (swank::symbol-indentation symbol macro-function swank::known-to-emacs-p swank-backend::arglist #:g3298 #401=(member :not-available) typep list swank::macro-indentation (#401# list) si::etypecase-error #Y(swank::symbol-indentation nil nil (24 45 1 26 13 0 19 1 2 39 7 13 0 19 1 3 76 39 53 13 0 19 1 4 45 4 10 0 45 5 13 0 15 6 19 2 7 39 5 75 73 38 23 13 0 15 8 19 2 7 39 8 13 1 19 1 9 38 7 13 0 1 10 17 11 43 1 43 1 38 3 75 73 29) #400# #2# 138118) si::fset function "Return a form describing the indentation of SYMBOL.
The form is to be used as the `common-lisp-indent-function' property
in Emacs." si::set-documentation)) #2# 138118) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #402=#A(t (10) (swank::macro-indentation swank-backend::arglist swank::well-formed-list-p &body &optional swank::clean-arglist remove position #Y(swank::macro-indentation nil nil (24 45 1 26 13 0 19 1 2 39 20 15 3 15 4 13 0 19 1 5 12 19 2 6 12 19 2 7 38 3 75 73 29) #402# #2# 138570) si::fset)) #2# 138570) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #403=#A(t (12) (swank::clean-arglist swank-backend::arglist (&whole &environment) member cddr &aux eq #Y(swank::clean-arglist nil nil (24 45 1 26 10 0 76 39 5 75 73 38 49 10 0 4 12 15 2 19 2 3 39 11 10 0 16 4 12 19 1 0 38 28 10 0 4 12 1 5 17 6 39 5 75 73 38 14 10 0 4 12 10 0 5 12 19 1 0 3 73 29) #403# #2# 138726) si::fset function "Remove &whole, &enviroment, and &aux elements from ARGLIST." si::set-documentation)) #2# 138726) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #404=#A(t (12) (swank::well-formed-list-p list #:g3300 null typep t cons #Y(swank::well-formed-list-p nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 6 11 5 73 38 21 13 0 15 6 19 2 4 39 10 10 1 5 12 19 1 0 38 3 75 73 43 1 29) #404# #2# 139069) si::fset function "Is LIST a proper list terminated by NIL?" si::set-documentation)) #2# 139069) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 15 0 15 35 15 36 19 3 37 1 0 73 29) #405=#A(t (38) (swank::print-indentation-lossage *standard-output* stream :test equal make-hash-table swank::table swank::s symbol-name string-downcase #Y(swank::name nil nil (24 45 7 26 10 0 16 8 12 19 1 9 29) #405# #2# 139245) list-all-packages #314# t si::packages-iterator #:g3310 #:g3311 swank::symbol-indentation si::hash-set swank::collisions #:g3315 #:g3316 gethash swank::entry swank::owner swank::indent eq fboundp macro-function adjoin "~&No worries!~%" format "~&Symbols with collisions:~%~{  ~S~%~}" #Y(swank::print-indentation-lossage nil nil (25 40 3 14 1 46 2 26 14 3 15 4 19 2 5 45 6 30 1 10 58 60 68 19 0 11 12 15 12 14 13 19 3 14 45 15 75 45 16 75 45 7 38 41 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 32 4 18 1 12 13 5 13 0 13 0 19 1 17 3 12 19 3 18 75 39 -42 43 3 63 75 45 19 58 60 127 19 0 11 12 15 12 14 13 19 3 14 45 20 75 45 21 75 45 7 38 100 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 32 5 18 1 12 13 6 19 2 22 45 23 10 0 4 45 24 10 1 5 45 25 13 3 10 1 17 26 40 26 13 3 19 1 17 12 10 0 17 4 40 14 10 3 16 27 76 39 7 13 3 19 1 28 76 76 39 19 13 1 13 7 19 2 29 51 7 13 3 13 7 19 2 29 51 7 43 3 75 39 -101 43 3 63 10 0 76 39 10 13 3 15 30 19 2 31 38 10 13 3 15 32 13 0 19 3 31 43 1 43 1 43 1 29) #405# #2# 139245) si::fset function "Return the list of symbols whose indentation styles collide incompatibly.
Collisions are caused because package information is ignored." si::set-documentation)) #2# 139245) #Y(si::bytecodes nil nil (15 0 14 1 19 2 2 52 1 73 29) #A(t (3) (swank::sync-indentation-to-emacs swank::*pre-reply-hook* adjoin)) #2# 140349) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 15 0 1 0 16 25 12 19 2 26 29) #406=#A(t (27) (swank::io-speed-test swank::n swank::m *standard-output* swank::s swank::*log-output* make-broadcast-stream *trace-output* si::%dotimes-var swank::i "~D abcdefghijklm~%" format mod zerop finish-output 1+ < swank::*emacs-connection* (swank-backend::message "done.") swank::eval-in-emacs #Y(nil nil nil (26 10 2 45 8 8 0 45 9 38 31 13 2 15 10 13 0 19 3 11 13 4 10 3 17 12 16 13 39 6 13 2 19 1 14 10 0 16 15 51 0 13 0 13 1 19 2 16 40 -38 43 2 13 0 19 1 14 11 17 73 39 6 15 18 19 1 19 29) #406# #2# 140407) si::do-time terpri #Y(swank::io-speed-test nil nil (25 40 3 9 1000 46 1 25 40 3 9 1 46 2 26 11 3 45 4 13 0 14 5 19 2 6 48 7 34 20 12 19 1 21 14 7 19 1 22 14 7 19 1 14 75 73 43 1 44 1 29) #406# #2# 140407) si::fset symbol-package export)) #2# 140407) #Y(si::bytecodes nil nil (15 0 1 46 12 19 2 47 15 0 1 0 16 48 12 19 2 49 29) #407=#A(t (50) (swank::flow-control-test swank::n swank::delay swank::*emacs-connection* swank::conn string :test-delay swank::send-to-emacs #Y(nil nil nil (26 14 6 10 2 6 2 12 19 1 7 29) #407# #2# 140952) function swank::connection eq swank::*send-counter* swank-backend::*pending-slime-interrupts* swank::*slime-interrupts-enabled* #:g3324 #:g3325 #:g3326 0 swank::swank-error si::temp #Y(nil nil nil (24 45 20 26 10 0 51 2 35 1 0 29) #407# #2# 140952) si::*handler-clusters* condition swank::*debug-on-swank-protocol-error* swank::invoke-default-debugger #Y(nil nil nil (24 45 23 26 11 24 73 39 6 13 0 19 1 25 29) #407# #2# 140952) swank::connection.env swank::swank-debugger-hook swank-backend::call-with-debugger-hook #Y(nil nil nil (26 33 28 12 13 5 19 2 29 29) #407# #2# 140952) swank::call-with-bindings swank::swank-error.condition swank::swank-error.backtrace swank::close-connection #Y(nil nil nil (24 45 5 26 13 1 34 8 12 46 9 46 10 14 3 10 0 17 11 39 8 13 1 20 0 23 38 111 13 0 77 9 0 49 12 49 13 49 3 75 48 14 10 0 45 15 57 16 60 83 75 45 17 57 18 61 1 45 15 19 34 21 3 6 1 12 11 22 3 48 22 15 19 34 26 3 6 1 12 11 22 3 48 22 13 4 19 1 27 12 34 30 12 19 2 31 44 1 36 2 44 1 10 1 45 23 13 4 13 0 19 1 32 12 13 0 19 1 33 12 19 3 34 43 1 36 2 62 73 43 1 63 43 1 44 1 44 3 43 2 29) #407# #2# 140952) swank-backend::make-output-stream stream si::%dotimes-var swank::i print force-output "flow-control-test: ~d" swank::background-message 1+ < #Y(swank::flow-control-test nil nil (24 45 1 24 45 2 26 11 3 45 4 34 35 12 43 1 19 1 36 45 37 10 2 45 38 8 0 45 39 38 27 13 0 13 2 19 2 40 13 2 19 1 41 15 42 13 0 19 2 43 10 0 16 44 51 0 75 13 0 13 1 19 2 45 40 -34 73 43 2 43 1 29) #407# #2# 140952) si::fset symbol-package export)) #2# 140952) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #408=#A(t (11) (swank::before-init swank::version swank::load-path :swank *features* adjoin swank::*swank-wire-protocol-version* swank::*load-path* swank-backend::warn-unimplemented-interfaces #Y(swank::before-init nil nil (24 45 1 24 45 2 26 14 3 14 4 19 2 5 52 4 10 1 52 6 10 0 52 7 19 0 8 29) #408# #2# 141414) si::fset)) #2# 141414) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #409=#A(t (5) (swank::init swank::*after-init-hook* swank::run-hook #Y(swank::init nil nil (26 14 1 19 1 2 29) #409# #2# 141621) si::fset)) #2# 141621))
