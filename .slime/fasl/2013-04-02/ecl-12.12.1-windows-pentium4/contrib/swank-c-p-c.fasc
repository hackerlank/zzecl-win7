(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SWANK" si::select-package)) #1=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/contrib/swank-c-p-c.lisp" 0) #Y(si::bytecodes nil nil (14 0 19 1 1 29) #A(t (2) (:swank-util swank::swank-require)) #1# 350) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 15 21 15 22 19 3 23 15 0 1 0 16 24 12 19 2 25 29) #2=#A(t (26) (swank::completions string swank::default-package-name swank::parse-completion-arguments swank::internal-p package package-name swank::name #\- swank::make-compound-prefix-matcher swank::symbol-completion-set swank::symbol-set (#\. #\-) swank::package-completion-set swank::package-set nconc swank::format-completion-set swank::completion-set swank::longest-compound-prefix #Y(swank::completions nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 47 3 4 47 2 5 47 1 6 45 7 13 0 13 1 13 2 13 3 15 8 19 1 9 12 19 5 10 45 11 13 1 13 2 13 3 13 4 15 12 19 1 9 12 19 5 13 45 14 13 1 13 0 19 2 15 12 13 5 13 3 19 3 16 45 17 10 0 73 39 11 13 0 13 0 19 1 18 6 2 73 43 3 43 4 29) #2# #1# 440) si::fset function "Return a list of completions for a symbol designator STRING.  

The result is the list (COMPLETION-SET COMPLETED-PREFIX), where
COMPLETION-SET is the list of all matching completions, and
COMPLETED-PREFIX is the best (partial) completion of the input
string.

Simple compound matching is supported on a per-hyphen basis:

  (completions \"m-v-\" \"COMMON-LISP\")
    ==> ((\"multiple-value-bind\" \"multiple-value-call\" 
          \"multiple-value-list\" \"multiple-value-prog1\" 
          \"multiple-value-setq\" \"multiple-values-limit\")
         \"multiple-value\")

(For more advanced compound matching, see FUZZY-COMPLETIONS.)

If STRING is package qualified the result list will also be
qualified.  If string is non-qualified the result strings are
also not qualified and are considered relative to
DEFAULT-PACKAGE-NAME.

The way symbols are matched depends on the symbol designator's
format. The cases are as follows:
  FOO      - Symbols with matching prefix and accessible in the buffer package.
  PKG:FOO  - Symbols with matching prefix and external in package PKG.
  PKG::FOO - Symbols with matching prefix and accessible in package PKG.
" si::set-documentation symbol-package export)) #1# 440) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #3=#A(t (15) (swank::symbol-completion-set swank::name package-name package swank::internal-p swank::matchp swank::completion-output-symbol-converter symbol-name swank::find-matching-symbols mapcar #Y(swank::symbol-completion-set nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 4 19 1 6 12 10 2 73 39 27 33 7 12 13 4 13 2 10 1 76 73 39 4 10 3 73 12 13 0 19 4 8 12 19 2 9 12 19 2 9 29) #3# #1# 2292) si::fset function "Return the set of completion-candidates as strings." si::set-documentation)) #1# 2292) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #4=#A(t (11) (swank::package-completion-set swank::name package-name package swank::internal-p swank::matchp swank::completion-output-package-converter swank::find-matching-packages mapcar #Y(swank::package-completion-set nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 4 19 1 6 12 10 3 76 73 39 8 13 4 13 0 19 2 7 12 19 2 8 29) #4# #1# 2699) si::fset)) #1# 2699) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 15 0 15 25 15 26 19 3 27 1 0 73 29) #5=#A(t (28) (swank::find-matching-symbols string package swank::external swank::test swank::completion-output-symbol-converter swank::converter swank::completions symbol swank::symbol-external-p symbol-name #Y(swank::symbol-matches-p nil nil (24 45 8 26 10 4 76 40 8 13 0 13 5 19 2 9 73 39 19 13 3 13 6 13 2 10 0 16 10 12 20 1 23 12 20 2 23 29) #5# #1# 2950) :test eq make-hash-table #:seen-ht3504 (:inherited :internal :external) t si::packages-iterator #:g3505 #:g3506 gethash si::hash-set #Y(swank::find-matching-symbols nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 77 13 3 19 1 5 12 46 6 46 7 30 1 11 14 12 33 13 12 19 2 14 45 15 58 60 79 13 7 15 16 14 17 19 3 18 45 19 75 45 20 75 45 8 38 54 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 13 4 19 2 21 76 39 25 13 0 13 4 14 17 19 3 22 13 0 32 5 18 1 39 8 13 0 10 6 3 51 6 75 39 -55 43 3 63 43 1 43 1 10 0 73 43 2 29) #5# #1# 2950) si::fset function "Return a list of symbols in PACKAGE matching STRING.
TEST is called with two strings.  If EXTERNAL is true, only external
symbols are returned." si::set-documentation)) #1# 2950) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #6=#A(t (17) (swank::find-matching-symbols-in-list string list swank::test swank::completion-output-symbol-converter swank::converter swank::completions symbol symbol-name #Y(swank::symbol-matches-p nil nil (24 45 7 26 13 3 13 5 13 2 10 0 16 8 12 20 1 23 12 20 2 23 29) #6# #1# 3644) si::%dolist-var remove-duplicates #Y(swank::find-matching-symbols-in-list nil nil (24 45 1 24 45 2 24 45 3 26 77 13 2 19 1 4 12 46 5 46 6 30 1 9 10 4 45 10 75 45 7 38 26 10 1 4 51 0 13 0 32 2 18 1 39 8 13 0 10 3 3 51 3 10 1 5 51 1 10 1 40 -28 43 2 43 1 13 0 19 1 11 43 2 29) #6# #1# 3644) si::fset function "Return a list of symbols in LIST matching STRING.
TEST is called with two strings." si::set-documentation)) #1# 3644) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 15 0 15 27 15 28 19 3 29 1 0 73 29) #7=#A(t (30) (swank::find-matching-packages swank::name swank::matcher swank::completion-output-package-converter swank::converter swank::x #Y(nil nil nil (24 45 5 26 13 2 13 3 13 1 13 0 20 1 23 12 20 2 23 29) #7# #1# 4176) swank::pkgname string ":" concatenate #Y(nil nil nil (24 45 7 26 15 8 13 0 15 9 19 3 10 29) #7# #1# 4176) list-all-packages #:loop-list3520 package #:loop-list-head3521 #:loop-list-tail3522 0 #:g3523 swank::package-names #:g3524 rplacd last mapcar remove-if-not #Y(swank::find-matching-packages nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 34 6 12 34 11 12 58 60 93 77 19 0 12 12 46 13 46 14 75 6 1 45 15 10 0 45 16 57 17 61 2 2 56 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 18 13 4 19 1 19 45 20 13 1 10 0 17 21 10 0 43 1 43 1 39 10 10 1 5 12 19 1 22 51 1 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 19 2 23 12 19 2 24 43 1 29) #7# #1# 4176) si::fset function "Return a list of package names matching NAME with MATCHER.
MATCHER is a two-argument predicate." si::set-documentation)) #1# 4176) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #8=#A(t (19) (swank::parse-completion-arguments string swank::default-package-name swank::tokenize-symbol swank::internal-p package-name swank::name "" equal :keyword symbol-name swank::guess-package package swank::*buffer-package* #Y(swank::parse-completion-arguments nil nil (24 45 1 24 45 2 26 13 1 19 1 3 47 2 4 47 1 5 45 6 10 1 39 38 13 1 1 7 17 8 39 7 11 9 16 10 38 4 10 1 73 12 19 1 11 45 12 13 1 13 2 13 0 13 3 72 4 43 1 38 27 13 3 19 1 11 45 12 13 1 13 2 10 0 73 40 4 11 13 73 12 13 3 72 4 43 1 43 3 29) #8# #1# 4743) si::fset function "Parse STRING as a symbol designator.
Return these values:
 SYMBOL-NAME
 PACKAGE-NAME, or nil if the designator does not include an explicit package.
 PACKAGE, generally the package to complete in. (However, if PACKAGE-NAME is 
          NIL, return the respective package of DEFAULT-PACKAGE-NAME instead; 
          if PACKAGE is non-NIL but a package cannot be found under that name,
          return NIL.)
 INTERNAL-P, if the symbol is qualified with `::'." si::set-documentation)) #1# 4743) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 15 0 15 25 15 26 19 3 27 1 0 73 29) #9=#A(t (28) (swank::completion-output-case-converter swank::input swank::with-escaping-p *readtable* readtable-case #:g3526 :upcase lower-case-p some identity string-downcase :invert swank::output swank::determine-case swank::upper swank::lower string-upcase #Y(nil nil nil (24 45 12 26 13 0 19 1 13 47 1 14 45 15 10 0 39 3 10 1 39 6 10 2 73 38 26 10 0 39 8 13 2 19 1 16 38 15 10 1 39 8 13 2 19 1 10 38 4 10 2 73 43 2 29) #9# #1# 6546) :downcase upper-case-p :preserve (:upcase :invert :downcase :preserve) si::ecase-error #Y(swank::completion-output-case-converter nil nil (24 45 1 25 40 2 77 46 2 26 11 3 16 4 45 5 10 0 42 6 26 10 1 40 10 33 7 12 13 2 19 2 8 76 39 6 33 9 73 38 4 33 10 73 38 51 42 11 6 34 17 73 38 43 42 18 26 10 1 40 10 33 19 12 13 2 19 2 8 76 39 6 33 9 73 38 4 33 16 73 38 15 42 20 6 33 9 73 38 7 13 0 1 21 17 22 43 1 29) #9# #1# 6546) si::fset function "Return a function to convert strings for the completion output.
INPUT is used to guess the preferred case." si::set-documentation)) #1# 6546) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 15 5 15 6 19 3 7 1 0 73 29) #10=#A(t (8) (swank::completion-output-package-converter swank::input swank::completion-output-case-converter #Y(swank::completion-output-package-converter nil nil (24 45 1 26 13 0 19 1 2 29) #10# #1# 7479) si::fset function "Return a function to convert strings for the completion output.
INPUT is used to guess the preferred case." si::set-documentation)) #1# 7479) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 15 0 15 29 15 30 19 3 31 1 0 73 29) #11=#A(t (32) (swank::completion-output-symbol-converter swank::input swank::completion-output-case-converter t swank::case-converter-with-escaping swank::case-converter swank::str swank::determine-case swank::uppercase swank::lowercase *readtable* readtable-case :upcase :downcase swank::el (#\: #\  #\Newline #\Tab) member get-macro-character swank::nonterminating swank::macrofun #Y(nil nil nil (24 45 14 26 13 0 15 15 19 2 16 73 40 22 13 0 19 1 17 47 1 18 45 19 10 0 73 39 5 10 1 76 73 43 2 29) #11# #1# 7691) some string "|" "|" concatenate #Y(nil nil nil (24 45 6 26 13 0 19 1 7 47 1 8 45 9 11 10 16 11 42 12 5 10 0 38 9 42 13 5 10 1 38 2 75 43 2 40 9 34 20 12 13 0 19 2 21 39 20 15 22 15 23 13 2 13 0 20 1 23 12 15 24 19 4 25 38 8 13 1 13 0 20 1 23 29) #11# #1# 7691) #Y(swank::completion-output-symbol-converter nil nil (24 45 1 26 13 0 19 1 2 12 13 0 14 3 19 2 2 12 46 4 46 5 34 26 73 43 2 29) #11# #1# 7691) si::fset function "Return a function to convert strings for the completion output.
INPUT is used to guess the preferred case. Escape symbols when needed." si::set-documentation)) #1# 7691) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 15 0 15 7 15 8 19 3 9 1 0 73 29) #12=#A(t (10) (swank::determine-case string lower-case-p some upper-case-p #Y(swank::determine-case nil nil (24 45 1 26 33 2 12 13 0 19 2 3 12 33 4 12 13 0 19 2 3 12 72 2 29) #12# #1# 8936) si::fset function "Return two booleans LOWER and UPPER indicating whether STRING
contains lower or upper case characters." si::set-documentation)) #1# 8936) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 15 0 15 39 15 40 19 3 41 1 0 73 29) #13=#A(t (42) (swank::make-compound-prefix-matcher swank::delimiter (nil :test) char= swank::test #:g3534 character typep cons (every #'characterp swank::delimiter) si::assert-failure characterp every (character cons) si::etypecase-error swank::delimiters swank::prefix swank::target #:loop-across-list3537 #:loop-across-index-3536 #:loop-across-vector-3535 swank::ch swank::tpos 0 length >= aref 1+ < :test member :start position #:g3540 + t #Y(nil nil nil (24 45 16 24 45 17 26 58 60 158 77 13 2 9 0 9 0 46 18 46 19 46 20 46 21 8 0 45 22 57 23 61 2 8 121 10 3 16 24 51 5 13 4 13 5 19 2 25 39 4 35 0 1 13 3 13 4 19 2 26 51 2 10 4 16 27 51 4 13 1 10 7 16 24 12 19 2 28 39 51 13 2 13 9 14 29 13 10 19 4 30 4 45 1 10 0 39 16 13 0 13 8 14 31 13 2 19 4 32 51 2 38 16 13 11 13 3 13 8 13 2 19 2 26 12 20 2 23 43 1 76 39 5 75 73 36 6 8 1 45 33 13 2 13 0 19 2 34 51 2 43 1 35 0 0 11 35 73 36 6 62 73 43 1 43 4 63 29) #13# #1# 9163) #Y(swank::make-compound-prefix-matcher nil nil (24 45 1 28 2 22 40 4 33 3 12 46 4 10 1 45 5 13 0 15 6 19 2 7 39 7 10 2 6 1 38 38 13 0 15 8 19 2 7 39 23 38 6 15 9 19 1 10 33 11 12 13 2 19 2 12 76 40 -15 10 2 38 7 13 0 1 13 17 14 43 1 45 15 34 36 73 43 1 29) #13# #1# 9163) si::fset function "Returns a matching function that takes a `prefix' and a
`target' string and which returns T if `prefix' is a
compound-prefix of `target', and otherwise NIL.

Viewing each of `prefix' and `target' as a series of substrings
delimited by DELIMITER, if each substring of `prefix' is a prefix
of the corresponding substring in `target' then we call `prefix'
a compound-prefix of `target'.

DELIMITER may be a character, or a list of characters." si::set-documentation)) #1# 9163) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #14=#A(t (24) (swank::longest-compound-prefix swank::completions #\- swank::delimiter string swank::tokenize-completion #Y(swank::tokenizer nil nil (24 45 4 26 13 0 13 1 19 2 5 29) #14# #1# 10290) mapcar swank::transpose-lists #:loop-list3544 swank::token-list #:loop-list-head3545 #:loop-list-tail3546 0 string= notevery swank::longest-common-prefix rplacd swank::untokenize-completion #Y(swank::longest-compound-prefix nil nil (24 45 1 25 40 3 15 2 46 3 26 30 1 6 58 60 111 77 32 1 12 13 3 19 2 7 12 19 1 8 12 46 9 46 10 75 6 1 45 11 10 0 45 12 57 13 61 2 2 65 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 33 14 12 13 3 10 3 5 12 19 3 15 39 19 13 1 13 3 19 1 16 6 1 51 1 17 17 35 0 1 38 12 13 1 10 3 4 6 1 51 1 17 17 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 13 1 19 2 18 43 1 29) #14# #1# 10290) si::fset function "Return the longest compound _prefix_ for all COMPLETIONS." si::set-documentation)) #1# 10290) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #15=#A(t (20) (swank::tokenize-completion string swank::delimiter swank::end swank::start #:loop-list-head3549 #:loop-list-tail3550 0 length > :start position subseq rplacd 1+ #Y(swank::tokenize-completion nil nil (24 45 1 24 45 2 26 58 60 101 75 45 3 75 45 4 75 6 1 45 5 10 0 45 6 57 7 61 2 6 65 8 0 51 3 13 3 10 7 16 8 12 19 2 9 39 4 35 0 1 13 6 13 7 14 10 13 3 19 4 11 40 5 10 7 16 8 51 4 13 1 13 7 13 3 13 4 19 3 12 6 1 51 1 17 13 10 4 16 14 51 3 35 0 0 10 2 5 73 36 5 62 73 43 2 43 1 43 1 63 29) #15# #1# 11024) si::fset function "Return all substrings of STRING delimited by DELIMITER." si::set-documentation)) #1# 11024) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #16=#A(t (8) (swank::untokenize-completion swank::tokens #\- swank::delimiter "~~{~~A~~^~a~~}" format #Y(swank::untokenize-completion nil nil (24 45 1 25 40 3 15 2 46 3 26 77 77 15 4 13 0 19 3 5 12 13 1 19 3 5 29) #16# #1# 11360) si::fset)) #1# 11360) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #17=#A(t (12) (swank::transpose-lists swank::lists null some car mapcar cdr #Y(swank::transpose-lists nil nil (24 45 1 26 10 0 76 39 5 75 73 38 38 33 2 12 13 0 19 2 3 39 5 75 73 38 24 33 4 12 13 0 19 2 5 12 33 6 12 13 0 19 2 5 12 19 1 0 3 73 29) #17# #1# 11491) si::fset function "Turn a list-of-lists on its side.
If the rows are of unequal length, truncate uniformly to the shortest.

For example:
(transpose-lists '((ONE TWO THREE) (1 2)))
  => ((ONE 1) (TWO 2))" si::set-documentation)) #1# 11491) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 15 0 1 0 16 15 12 19 2 16 29) #18=#A(t (17) (swank::completions-for-character swank::prefix #\_ :test char-equal swank::make-compound-prefix-matcher swank::matcher swank-backend::character-completion-set swank::completion-set string< sort swank::completions swank::longest-compound-prefix #Y(swank::completions-for-character nil nil (24 45 1 26 15 2 14 3 33 4 12 19 3 5 45 6 13 1 13 0 19 2 7 45 8 13 0 33 9 12 19 2 10 45 11 13 0 13 0 15 2 19 2 12 6 2 73 43 3 29) #18# #1# 11884) si::fset symbol-package export)) #1# 11884) #Y(si::bytecodes nil nil (11 0 16 1 29) #A(t (2) (:swank-c-p-c provide)) #1# 12245))
