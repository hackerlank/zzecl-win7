(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) (#1="SWANK" si::select-package)) #2=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/contrib/swank-presentation-streams.lisp" 0) #Y(si::bytecodes nil nil (14 0 19 1 1 29) #A(t (2) (:swank-presentations swank::swank-require)) #2# 464) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*enable-presenting-readable-objects* si::*make-special boundp t variable "set this to enable automatically printing presentations for some
subset of readable objects, such as pathnames." si::set-documentation)) #2# 504) #Y(si::bytecodes nil nil (15 0 1 11 12 14 12 9 3 19 4 13 15 0 15 9 15 14 19 3 15 1 0 73 29) #3=#A(t (16) (swank::presenting-object #:g5655 #:g5654 #:g5656 si::dm-too-few-arguments swank::object stream swank::body swank::presenting-object-1 function lambda #Y(swank::presenting-object nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 13 2 13 1 15 9 15 10 77 10 0 7 3 6 2 6 4 73 29) #3# #2# 2115) t si::fset "What you use in your code. Wrap this around some printing and that text will
be sensitive and remember what object it is in the repl" si::set-documentation)) #2# 2115) #Y(si::bytecodes nil nil (15 0 1 17 12 14 18 9 4 19 4 19 15 0 15 12 15 20 19 3 21 1 0 73 29) #4=#A(t (22) (swank::presenting-object-if #:g5658 #:g5657 #:g5659 si::dm-too-few-arguments swank::predicate swank::object stream swank::body gensym continue let function lambda if swank::presenting-object-1 funcall #Y(swank::presenting-object-if nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 76 39 6 13 4 19 1 4 10 2 4 12 10 2 5 51 2 22 45 7 10 3 45 8 19 0 9 45 10 15 11 13 0 15 12 15 13 77 10 1 7 3 6 2 6 2 6 1 12 15 14 13 4 15 15 13 3 13 2 10 0 6 4 12 15 16 10 0 6 2 6 4 6 3 73 43 1 29) #4# #2# 2391) t si::fset "What you use in your code. Wrap this around some printing and that text will
be sensitive and remember what object it is in the repl if predicate is true" si::set-documentation)) #2# 2391) #Y(si::bytecodes nil nil (77 77 46 0 46 1 15 2 34 19 12 19 2 20 15 2 15 21 15 22 19 3 23 1 2 73 43 2 29) #5=#A(t (24) (swank::last-answer swank::last-stream swank::slime-stream-p stream eq t *standard-output* swank::*connections* #:loop-list5662 swank::connection #:loop-it-5663 0 swank::connection.dedicated-output :dedicated swank::connection.socket-io swank::connection.user-output swank::connection.user-io swank::connection.repl-results :repl-result #Y(swank::slime-stream-p nil nil (24 45 3 26 13 1 10 0 17 4 39 6 10 2 73 38 136 10 0 51 1 13 0 11 5 17 4 39 5 11 6 51 0 58 60 114 77 14 7 46 8 46 9 75 45 10 57 11 61 2 2 92 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 5 13 2 19 1 12 17 4 39 3 11 13 40 47 13 5 13 2 19 1 14 17 4 40 36 13 5 13 2 19 1 15 17 4 40 25 13 5 13 2 19 1 16 17 4 40 14 13 5 13 2 19 1 17 17 4 39 3 11 18 51 1 39 6 10 1 73 36 4 35 0 0 62 43 1 43 2 63 51 2 73 29) #5# #2# 2792) si::fset function "Check if stream is one of the slime streams, since if it isn't we
don't want to present anything.
Two special return values: 
:DEDICATED -- Output ends up on a dedicated output stream
:REPL-RESULT -- Output ends up on the :repl-results target.
" si::set-documentation)) #2# 2792) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #6=#A(t (5) (swank::can-present-readable-objects stream swank::*enable-presenting-readable-objects* #Y(swank::can-present-readable-objects nil nil (25 40 2 77 46 1 26 11 2 73 29) #6# #2# 5868) si::fset)) #2# 5868) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #7=#A(t (6) (swank::write-annotation stream function swank::arg #Y(swank::write-annotation nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 0 13 2 77 20 3 23 29) #7# #2# 5996) si::fset)) #2# 5996) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 3 77 77 15 6 19 15 7 15 0 19 1 17 78 13 15 8 1 15 12 19 2 16 1 0 73 29) #8=#A(t (18) (swank::presentation-record "PRESENTATION-RECORD-" ((swank::id) (swank::printed-p) (swank::target)) ((swank::id nil t nil 0 nil) (swank::printed-p nil t nil 1 nil) (swank::target nil t nil 2 nil)) swank::copy-presentation-record (swank::make-presentation-record) swank::presentation-record-p si::define-structure swank::make-presentation-record (nil :target :printed-p :id) #:id #:printed-p #:target 0 si::make-structure #Y(swank::make-presentation-record nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 15 13 13 2 13 1 13 0 19 4 14 29) #8# #2# 7061) si::fset find-class)) #2# 7061) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #9=#A(t (23) (swank::presentation-start swank::record stream swank::truncatep swank::presentation-record-id swank::presentation-record-target swank::target swank::pid :dedicated "<" write-string prin1 "" finish-output :presentation-start swank::send-to-emacs #:g5666 t #:g5667 swank::presentation-record si::structure-set #Y(swank::presentation-start nil nil (24 45 1 24 45 2 24 45 3 26 10 0 76 73 39 87 13 2 19 1 4 12 13 2 19 1 5 12 46 6 46 7 10 1 42 8 24 15 9 13 3 19 2 10 13 0 13 3 19 2 11 15 12 13 3 19 2 10 38 18 13 3 19 1 13 14 14 13 0 10 1 6 3 12 19 1 15 43 2 10 2 45 16 11 17 45 18 13 1 15 19 9 1 13 0 19 4 20 43 1 43 1 29) #9# #2# 7132) si::fset)) #2# 7132) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #10=#A(t (19) (swank::presentation-end swank::record stream swank::truncatep swank::presentation-record-printed-p swank::presentation-record-id swank::presentation-record-target swank::target swank::pid :dedicated ">" write-string prin1 "" finish-output :presentation-end swank::send-to-emacs #Y(swank::presentation-end nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 73 39 64 13 2 19 1 5 12 13 2 19 1 6 12 46 7 46 8 10 1 42 9 24 15 10 13 3 19 2 11 13 0 13 3 19 2 12 15 13 13 3 19 2 11 38 18 13 3 19 1 14 14 15 13 0 10 1 6 3 12 19 1 16 43 2 29) #10# #2# 7699) si::fset)) #2# 7699) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 15 0 15 20 15 21 19 3 22 1 0 73 29) #11=#A(t (23) (swank::presenting-object-1 swank::object stream continue swank::*record-repl-results* swank::slime-stream-p swank::save-presented-object swank::pid :id :printed-p :target :repl-result eq swank::make-presentation-record swank::record swank::presentation-start swank::write-annotation swank::presentation-end #Y(swank::presenting-object-1 nil nil (24 45 1 24 45 2 24 45 3 26 11 4 39 6 13 1 19 1 5 45 5 10 0 39 69 13 3 19 1 6 45 7 14 8 13 0 14 9 77 14 10 13 1 11 11 17 12 39 6 11 11 73 38 3 75 73 12 19 6 13 45 14 13 4 33 15 12 13 0 19 3 16 13 3 20 0 23 69 13 4 33 17 12 13 0 19 3 16 70 43 2 38 6 13 1 20 0 23 43 1 29) #11# #2# 8221) si::fset function "Uses the bridge mechanism with two messages >id and <id. The first one
says that I am starting to print an object with this id. The second says I am finished" si::set-documentation)) #2# 8221) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #12=#A(t (17) (swank::present-repl-results-via-presentation-streams values swank::*emacs-connection* swank::connection.repl-results swank::repl-results swank::value prin1 #Y(nil nil nil (26 13 0 13 1 19 2 6 29) #12# #2# 9183) swank::presenting-object-1 terpri #Y(swank-backend::send nil nil (24 45 5 26 13 0 13 1 34 7 12 19 3 8 13 1 19 1 9 29) #12# #2# 9183) "; No value" princ mapc finish-output #Y(swank::present-repl-results-via-presentation-streams nil nil (24 45 1 26 14 2 19 1 3 45 4 30 1 10 10 2 76 39 15 15 11 13 1 19 2 12 13 1 19 1 9 38 9 32 0 12 13 2 19 2 13 43 1 13 0 19 1 14 43 1 29) #12# #2# 9183) si::fset)) #2# 9183) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) (#1# si::select-package)) #2# 9728) #Y(si::bytecodes nil nil (1 0 52 1 73 29) #A(t (2) (swank::present-repl-results-via-presentation-streams swank::*send-repl-results-function*)) #2# 10806) #Y(si::bytecodes nil nil (11 0 16 1 29) #A(t (2) (:swank-presentation-streams provide)) #2# 12603))
