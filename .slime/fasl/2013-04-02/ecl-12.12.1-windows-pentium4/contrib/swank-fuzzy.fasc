(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SWANK" si::select-package)) #1=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/contrib/swank-fuzzy.lisp" 0) #Y(si::bytecodes nil nil (14 0 19 1 1 14 2 19 1 1 29) #A(t (3) (:swank-util swank::swank-require :swank-c-p-c)) #1# 238) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 15 0 15 18 15 19 19 3 20 15 0 1 0 16 21 12 19 2 22 29) #2=#A(t (23) (swank::fuzzy-completions string swank::default-package-name (nil :time-limit-in-msec :limit) swank::limit swank::time-limit-in-msec zerop swank::no-time-limit-p swank::time-limit :limit :time-limit-in-msec swank::fuzzy-completion-set swank::interrupted-p swank::completion-set list coerce #Y(swank::fuzzy-completions nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 2 77 46 5 10 0 76 40 5 10 0 16 6 45 7 10 0 39 4 75 38 3 10 1 45 8 13 5 13 4 14 9 13 3 14 10 13 0 19 6 11 47 1 12 45 13 13 0 1 14 17 15 12 10 1 6 2 73 43 2 43 2 29) #2# #1# 360) si::fset function "Returns a list of two values:

  An (optionally limited to LIMIT best results) list of fuzzy
  completions for a symbol designator STRING. The list will be
  sorted by score, most likely match first.

  A flag that indicates whether or not TIME-LIMIT-IN-MSEC has
  been exhausted during computation. If that parameter's value is
  NIL or 0, no time limit is assumed.

The main result is a list of completion objects, where a completion
object is:

    (COMPLETED-STRING SCORE (&rest CHUNKS) CLASSIFICATION-STRING)

where a CHUNK is a description of a matched substring:

    (OFFSET SUBSTRING)

and FLAGS is short string describing properties of the symbol (see
SYMBOL-CLASSIFICATION-STRING).

E.g., completing \"mvb\" in a package that uses COMMON-LISP would
return something like:

    ((\"multiple-value-bind\" 26.588236 ((0 \"m\") (9 \"v\") (15 \"b\"))
     (:FBOUNDP :MACRO))
     ...)

If STRING is package qualified the result list will also be
qualified.  If string is non-qualified the result strings are
also not qualified and are considered relative to
DEFAULT-PACKAGE-NAME.

Which symbols are candidates for matching depends on the symbol
designator's format. The cases are as follows:
  FOO      - Symbols accessible in the buffer package.
  PKG:FOO  - Symbols external in package PKG.
  PKG::FOO - Symbols accessible in package PKG." si::set-documentation symbol-package export)) #1# 360) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 6 77 77 15 6 19 15 7 15 0 19 1 20 78 16 15 8 1 18 12 19 2 19 1 0 73 29) #3=#A(t (21) (swank::fuzzy-matching swank::fuzzy-matching. (symbol swank::symbol-p package-name swank::score swank::package-chunks swank::symbol-chunks) ((symbol nil t nil 0 nil) (swank::symbol-p nil t nil 1 nil) (package-name nil t nil 2 nil) (swank::score nil t nil 3 nil) (swank::package-chunks nil t nil 4 nil) (swank::symbol-chunks nil t nil 5 nil)) swank::copy-fuzzy-matching (swank::%make-fuzzy-matching) swank::fuzzy-matching-p si::define-structure swank::%make-fuzzy-matching (nil :symbol-chunks :package-chunks :score :package-name :symbol-p :symbol) #:symbol #:symbol-p #:package-name #:score #:package-chunks #:symbol-chunks 0 si::make-structure #Y(swank::%make-fuzzy-matching nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 15 16 13 5 13 4 13 3 13 2 13 1 13 0 19 7 17 29) #3# #1# 3010) si::fset find-class)) #1# 3010) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #4=#A(t (18) (swank::make-fuzzy-matching symbol package-name swank::score swank::package-chunks swank::symbol-chunks (nil :symbol-p) t swank::symbol-p :symbol :package-name :score :package-chunks :symbol-chunks :symbol-p swank::%make-fuzzy-matching #Y(swank::make-fuzzy-matching nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 28 6 22 40 3 14 7 46 8 14 9 13 5 14 10 13 4 14 11 13 3 14 12 13 2 14 13 13 1 14 14 13 0 19 12 15 29) #4# #1# 3968) si::fset)) #1# 3968) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 1 0 73 29) #5=#A(t (40) (swank::%fuzzy-extract-matching-info swank::fuzzy-matching swank::user-input-string swank::parse-completion-arguments swank::input-internal-p swank::__ swank::user-package-name swank::_ #6=#:oo-4800 #:g4802 #:g4801 (swank::fuzzy-matching.score #6#) #:g4804 #:g4803 (swank::fuzzy-matching.symbol #6#) #:g4806 #:g4805 (swank::fuzzy-matching.package-name #6#) #:g4808 #:g4807 (swank::fuzzy-matching.package-chunks #6#) #:g4810 #:g4809 (swank::fuzzy-matching.symbol-chunks #6#) #:g4812 #:g4811 (swank::fuzzy-matching.symbol-p #6#) swank::internal-p swank::real-package-name symbol-name swank::fuzzy-matching.symbol-p swank::fuzzy-matching.symbol keywordp "" swank::fuzzy-matching.package-name "" swank::completion-output-symbol-converter swank::completion-output-package-converter #Y(swank::%fuzzy-extract-matching-info nil nil (24 45 1 24 45 2 26 13 0 77 19 2 3 47 3 4 47 2 5 47 1 6 45 7 10 5 45 8 77 77 77 46 27 46 28 46 29 13 3 19 1 30 39 44 13 3 19 1 31 16 29 51 0 10 7 51 2 13 3 19 1 31 16 32 39 5 1 33 38 14 10 5 76 39 4 75 38 6 13 3 19 1 34 51 1 38 23 1 35 51 0 13 3 19 1 34 51 1 10 5 39 5 10 7 38 2 75 51 2 13 0 13 1 10 5 39 6 10 2 73 38 3 75 73 12 13 8 19 1 36 12 13 8 19 1 37 12 72 5 43 3 43 1 43 4 29) #5# #1# 4422) si::fset)) #1# 4422) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #7=#A(t (17) (swank::fuzzy-format-matching swank::fuzzy-matching swank::user-input-string swank::%fuzzy-extract-matching-info swank::package-converter swank::symbol-converter swank::internal-p package-name symbol-name swank::untokenize-symbol swank::result search #Y(swank::fuzzy-format-matching nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 47 4 4 47 3 5 47 2 6 47 1 7 45 8 10 0 39 8 13 3 13 0 20 1 23 51 0 10 1 39 8 13 4 13 1 20 1 23 51 1 13 1 13 2 13 0 19 3 9 45 10 13 0 13 1 13 0 19 2 11 12 72 2 43 1 43 5 29) #7# #1# 5916) si::fset function "Returns the completion (\"foo:bar\") that's represented by FUZZY-MATCHING." si::set-documentation)) #1# 5916) #Y(si::bytecodes nil nil (15 0 1 39 12 19 2 40 15 0 15 41 15 42 19 3 43 1 0 73 29) #8=#A(t (44) (swank::fuzzy-convert-matching-for-emacs swank::fuzzy-matching swank::user-input-string #9=#:oo-4830 #:g4832 #:g4831 (swank::fuzzy-matching.symbol #9#) #:g4834 #:g4833 (swank::fuzzy-matching.score #9#) #:g4836 #:g4835 (swank::fuzzy-matching.package-chunks #9#) #:g4838 #:g4837 (swank::fuzzy-matching.symbol-chunks #9#) #:g4840 #:g4839 (swank::fuzzy-matching.symbol-p #9#) swank::fuzzy-format-matching swank::added-length swank::name "~,2f" swank::fuzzy-matching.score format swank::fuzzy-matching.package-chunks swank::chunk second string swank::offset + #Y(nil nil nil (24 45 26 26 10 0 4 12 10 0 16 27 12 46 28 46 29 13 4 13 0 19 2 30 12 10 1 6 2 73 43 2 29) #8# #1# 6687) swank::fuzzy-matching.symbol-chunks mapcar append swank::fuzzy-matching.symbol-p swank::fuzzy-matching.symbol swank::symbol-classification-string "-------p" #Y(swank::fuzzy-convert-matching-for-emacs nil nil (24 45 1 24 45 2 26 10 1 45 3 13 2 13 1 19 2 19 47 1 20 45 21 13 0 77 15 22 13 2 19 1 23 12 19 3 24 12 13 2 19 1 25 12 34 31 12 13 2 19 1 32 12 19 2 33 12 19 2 34 12 13 2 19 1 35 39 12 13 2 19 1 36 12 19 1 37 38 3 1 38 6 4 73 43 2 43 1 29) #8# #1# 6687) si::fset function "Converts a result from the fuzzy completion core into something
that emacs is expecting.  Converts symbols to strings, fixes case
issues, and adds information (as a string) describing if the symbol is
bound, fbound, a class, a macro, a generic-function, a
special-operator, or a package." si::set-documentation)) #1# 6687) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 15 0 15 28 15 29 19 3 30 1 0 73 29) #10=#A(t (31) (swank::fuzzy-completion-set string swank::default-package-name (nil :time-limit-in-msec :limit) swank::limit swank::time-limit-in-msec #:g4848 (or null (integer 0 536870910)) typep si::do-check-type #:g4850 (or null (integer 0 536870910)) swank::fuzzy-generate-matchings swank::interrupted-p swank::matchings > length < array-has-fill-pointer-p si::fill-pointer-set :displaced-to make-array swank::m swank::fuzzy-convert-matching-for-emacs #Y(nil nil nil (24 45 22 26 13 0 13 6 19 2 23 29) #10# #1# 7956) map-into #Y(swank::fuzzy-completion-set nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 2 77 46 5 10 1 45 6 13 0 15 7 19 2 8 76 39 13 13 0 15 7 77 15 4 19 4 9 51 2 43 1 10 0 45 10 13 0 15 11 19 2 8 76 39 13 13 0 15 11 77 15 5 19 4 9 51 1 43 1 13 3 13 2 13 0 19 3 12 47 1 13 45 14 10 3 39 20 13 3 9 0 19 2 15 39 11 13 3 10 0 16 16 12 19 2 17 39 26 10 0 16 18 39 9 13 0 10 3 17 19 38 12 13 3 14 20 13 0 19 3 21 51 0 13 0 34 24 12 13 0 19 3 25 13 0 13 1 72 2 43 2 29) #10# #1# 7956) si::fset function "Returns two values: an array of completion objects, sorted by
their score, that is how well they are a match for STRING
according to the fuzzy completion algorithm.  If LIMIT is set,
only the top LIMIT results will be returned. Additionally, a flag
is returned that indicates whether or not TIME-LIMIT-IN-MSEC was
exhausted." si::set-documentation)) #1# 7956) #Y(si::bytecodes nil nil (15 0 1 83 12 19 2 84 15 0 15 85 15 86 19 3 87 1 0 73 29) #11=#A(t (88) (swank::fuzzy-generate-matchings string swank::default-package-name swank::time-limit-in-msec swank::parse-completion-arguments swank::internal-p package swank::parsed-package-name swank::parsed-symbol-name swank::matchings swank::parent-package-matching swank::p swank::fuzzy-matching.package-name swank::p.name swank::fuzzy-matching.score swank::p.score swank::fuzzy-matching.package-chunks swank::p.chunks swank::m swank::m.score #:g4899 #:g4900 swank::fuzzy-matching si::structure-set #:g4901 #:g4902 #:g4903 "" equal / + #:g4904 #Y(nil nil nil (24 45 18 26 13 0 19 1 14 45 19 10 1 45 20 10 5 45 21 13 1 15 22 9 2 13 0 19 4 23 43 1 43 1 10 1 45 24 10 3 45 25 13 1 15 22 9 4 13 0 19 4 23 43 1 43 1 10 1 45 26 13 9 1 27 17 28 39 10 13 4 9 100 19 2 29 38 8 13 4 13 1 19 2 30 45 31 13 1 15 22 9 3 13 0 19 4 23 43 1 43 1 10 1 73 43 1 29) #11# #1# 9160) map-into #Y(swank::fix-up nil nil (24 45 9 24 45 10 26 10 0 45 11 13 0 19 1 12 45 13 13 1 19 1 14 45 15 13 2 19 1 16 45 17 13 5 34 32 12 13 5 19 3 33 43 4 29) #11# #1# 9160) swank::designator swank::time-limit swank::filter :time-limit-in-msec :external-only :filter identity swank::fuzzy-find-matching-symbols #Y(swank::find-symbols nil nil (24 45 35 24 45 6 24 45 36 25 40 2 77 46 37 26 13 3 13 2 14 38 13 1 14 39 10 7 76 12 14 40 10 0 73 40 4 33 41 73 12 19 8 42 29) #11# #1# 9160) swank::fuzzy-find-matching-packages #Y(swank::find-packages nil nil (24 45 35 24 45 36 26 13 1 14 38 13 0 19 3 44 29) #11# #1# 9160) swank::results swank::packages swank::symbols #:g4905 #:g4906 #:g4907 #:g4908 "" string= #:g4909 #:g4910 swank::rest-time-limit swank::symbol-packages swank::fuzzy-matching-greaterp sort #:loop-across-list4914 #:loop-across-index-4913 #:loop-across-vector-4912 swank::package-matching 0 length >= aref 1+ find-package > remove swank::%make-duplicate-symbols-filter swank::remaining-time vector concatenate swank::%guess-sort-duration swank::guessed-sort-duration <= #:g4926 - "" #Y(swank::fuzzy-generate-matchings nil nil (24 45 1 24 45 2 24 45 3 26 13 2 13 1 19 2 4 47 3 5 47 2 6 47 1 7 45 8 30 3 34 43 45 13 7 77 77 77 46 46 46 47 46 48 46 36 10 8 76 39 51 13 7 13 0 32 4 18 2 47 1 49 45 50 10 0 51 4 10 1 51 2 43 2 13 7 13 9 13 0 32 5 18 3 47 1 51 45 52 10 0 51 3 10 1 51 2 43 2 38 263 13 8 15 53 19 2 54 39 28 13 7 13 9 13 0 32 5 18 3 47 1 55 45 56 10 0 51 3 10 1 51 2 43 2 38 227 13 8 13 11 32 4 18 2 47 1 57 45 58 13 0 33 59 12 19 2 60 51 0 77 13 0 9 0 9 0 46 61 46 62 46 63 46 64 75 45 6 57 65 61 2 8 157 10 3 16 66 51 5 13 4 13 5 19 2 67 39 4 35 0 1 13 3 13 4 19 2 68 51 2 10 4 16 69 51 4 13 2 19 1 12 16 70 51 1 10 8 76 40 8 13 7 9 0 19 2 71 76 39 4 35 0 1 13 15 13 1 13 7 13 2 13 6 19 2 72 12 19 1 73 12 32 13 18 4 47 1 74 45 9 13 0 13 4 32 16 18 2 51 0 15 75 13 11 13 0 19 3 76 51 11 10 1 51 9 10 11 16 66 12 19 1 77 45 78 13 10 13 0 19 2 79 39 19 10 0 45 80 13 11 13 0 19 2 81 51 11 43 1 35 3 1 43 1 43 2 35 0 0 10 7 51 8 13 15 1 82 17 28 39 5 10 6 51 10 62 43 1 43 4 43 2 15 75 13 1 13 2 19 3 76 51 3 13 3 33 59 12 19 2 60 51 3 13 3 10 0 73 39 8 13 0 9 0 19 2 79 12 72 2 43 4 43 3 43 4 29) #11# #1# 9160) si::fset function "Does all the hard work for FUZZY-COMPLETION-SET. If
TIME-LIMIT-IN-MSEC is NIL, an infinite time limit is assumed." si::set-documentation)) #1# 9160) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #12=#A(t (10) (swank::%guess-sort-duration length zerop 3.8 log * swank::comparasions expt #Y(swank::%guess-sort-duration nil nil (24 45 1 26 10 0 16 2 39 6 8 0 73 38 42 15 3 13 0 13 0 9 2 19 2 4 12 19 2 5 12 19 2 5 45 6 9 1000 13 0 9 10 8 -7 17 7 12 19 2 5 12 19 2 5 43 1 29) #12# #1# 15172) si::fset)) #1# 15172) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #13=#A(t (16) (swank::%make-duplicate-symbols-filter swank::fuzzy-package-matchings swank::m swank::fuzzy-matching.package-name find-package #Y(nil nil nil (24 45 2 26 13 0 19 1 3 16 4 29) #13# #1# 15628) list coerce mapcar swank::packages symbol symbol-package member #Y(nil nil nil (24 45 10 26 10 0 16 11 12 13 1 19 2 12 76 73 29) #13# #1# 15628) #Y(swank::%make-duplicate-symbols-filter nil nil (24 45 1 26 34 5 12 13 0 1 6 17 7 12 19 2 8 45 9 34 13 73 43 1 29) #13# #1# 15628) si::fset)) #1# 15628) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #14=#A(t (19) (swank::fuzzy-matching-greaterp swank::m1 swank::m2 swank::fuzzy-matching.score swank::score2 swank::score1 > t < swank::fuzzy-matching.symbol symbol-name swank::name2 swank::name1 string< #Y(swank::fuzzy-matching-greaterp nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 13 0 19 1 3 12 46 4 46 5 13 0 13 1 19 2 6 39 6 11 7 73 38 43 13 0 13 1 19 2 8 39 5 75 73 38 30 13 3 19 1 9 16 10 12 13 2 19 1 9 16 10 12 46 11 46 12 13 0 13 1 19 2 13 43 2 43 2 29) #14# #1# 16167) si::fset function "Returns T if fuzzy-matching M1 should be sorted before M2.
Basically just the scores of the two matchings are compared, and
the match with higher score wins. For the case that the score is
equal, the one which comes alphabetically first wins." si::set-documentation)) #1# 16167) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function nil (integer 0)) swank::get-real-time-msecs) proclaim)) #1# 16868) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #15=#A(t (8) (swank::get-real-time-in-msecs internal-time-units-per-second floor max swank::units-per-msec get-internal-real-time #Y(swank::get-real-time-in-msecs nil nil (26 9 1 14 1 9 1000 19 2 2 12 19 2 3 45 4 19 0 5 12 13 0 19 2 2 12 72 1 43 1 29) #15# #1# 16935) si::fset)) #1# 16935) #Y(si::bytecodes nil nil (15 0 1 56 12 19 2 57 15 0 15 58 15 59 19 3 60 1 0 73 29) #16=#A(t (61) (swank::fuzzy-find-matching-symbols string package (nil :time-limit-in-msec :external-only :filter) identity swank::filter swank::external-only swank::time-limit-in-msec t swank::get-real-time-in-msecs package-name count swank::rtime-at-start swank::time-limit swank::time-limit-p swank::old-remaining-time > 1+ mod - swank::elapsed-time swank::remaining <= #Y(swank::recompute-remaining-time nil nil (24 45 15 26 10 1 76 39 7 77 77 72 2 38 62 13 5 9 0 19 2 16 39 19 10 5 16 17 12 8 128 17 18 51 5 77 13 0 72 2 38 35 19 0 9 12 13 3 19 2 19 45 20 13 3 13 0 19 2 19 45 21 13 0 9 0 19 2 22 12 13 0 72 2 43 2 29) #16# #1# 17112) symbol-name swank::completion-output-symbol-converter swank::converter swank::converted-symbol-name swank::compute-highest-scoring-completion #Y(swank::perform-fuzzy-match nil nil (24 45 1 24 45 24 26 13 1 19 1 25 45 26 13 0 13 1 20 1 23 45 27 13 3 13 0 19 2 28 43 2 29) #16# #1# 17112) :adjustable :fill-pointer make-array swank::rest-time-limit swank::completions :test eq make-hash-table #:seen-ht4942 (:inherited :internal :external) si::packages-iterator #:g4943 #:g4944 symbol gethash si::hash-set swank::remaining-time swank::exhausted? swank::symbol-external-p "" string= 0.0 swank::make-fuzzy-matching vector-push-extend swank::score swank::match-result #Y(swank::fuzzy-find-matching-symbols nil nil (24 45 1 24 45 2 28 3 22 40 4 33 4 12 46 5 22 40 2 77 46 6 22 40 2 77 46 7 10 0 73 39 4 11 8 73 12 10 0 73 40 4 8 0 73 12 19 0 9 12 10 3 16 10 12 9 0 46 11 46 10 46 12 46 13 46 14 30 2 23 29 9 256 14 30 14 8 14 31 9 0 19 5 32 12 13 3 46 33 46 34 14 35 33 36 12 19 2 37 45 38 58 60 183 13 14 15 39 14 8 19 3 40 45 41 75 45 42 75 45 43 38 158 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 13 4 19 2 44 76 39 129 13 0 13 4 14 8 19 3 45 13 6 32 8 18 1 47 1 46 45 47 10 1 51 8 10 0 39 7 75 73 36 5 38 93 10 17 76 40 8 13 2 13 19 19 2 48 39 8 13 18 13 2 20 1 23 76 40 69 15 49 13 20 19 2 50 39 20 13 2 13 14 15 51 77 77 19 5 52 12 13 7 19 2 53 38 41 13 20 10 2 16 24 12 32 9 18 2 47 1 54 45 55 10 0 39 19 13 4 13 16 13 1 77 13 0 19 5 52 12 13 9 19 2 53 43 2 43 2 75 39 -159 43 3 63 43 1 13 0 13 1 72 2 43 2 43 2 43 5 29) #16# #1# 17112) si::fset function "Returns two values: a vector of fuzzy matchings for matching
symbols in PACKAGE, using the fuzzy completion algorithm, and the
remaining time limit.

Only those symbols are considered of which FILTER does return T.

If EXTERNAL-ONLY is true, only external symbols are considered. A
TIME-LIMIT-IN-MSEC of NIL is considered no limit; if it's zero or
negative, perform a NOP." si::set-documentation)) #1# 17112) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 15 0 15 40 15 41 19 3 42 1 0 73 29) #17=#A(t (43) (swank::fuzzy-find-matching-packages swank::name (nil :time-limit-in-msec) swank::time-limit-in-msec t swank::get-real-time-in-msecs swank::completion-output-package-converter :adjustable :fill-pointer make-array swank::completions swank::converter swank::rtime-at-start swank::time-limit swank::time-limit-p <= #A(t (0) ()) list-all-packages #:loop-list4957 package 0 "" swank::max-pkg-name swank::max-result swank::max-score swank::package-names #:loop-list4958 package-name swank::converted-name swank::compute-highest-scoring-completion swank::score swank::result > :symbol-p swank::make-fuzzy-matching vector-push-extend - swank::elapsed-time #Y(swank::fuzzy-find-matching-packages nil nil (24 45 1 28 2 22 40 2 77 46 3 10 0 73 39 4 11 4 73 12 10 0 73 40 4 8 0 73 12 19 0 5 12 13 1 19 1 6 12 9 32 14 7 14 4 14 8 9 0 19 5 9 12 46 10 46 11 46 12 46 13 46 14 10 0 39 8 13 1 9 0 19 2 15 39 9 15 16 13 1 72 2 38 212 58 60 209 77 19 0 17 12 46 18 46 19 57 20 61 2 2 157 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 1 21 45 22 75 45 23 8 0 45 24 77 13 4 19 1 25 12 46 26 46 27 75 45 28 57 20 61 2 2 70 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 14 13 2 20 1 23 51 1 13 17 13 1 19 2 29 47 1 30 45 31 10 0 39 8 13 1 13 6 19 2 32 39 13 10 4 51 8 10 0 51 7 10 1 51 6 43 2 35 0 0 10 5 39 21 77 13 6 13 4 13 5 77 14 33 77 19 7 34 12 13 15 19 2 35 62 43 1 43 2 43 1 43 1 43 1 35 0 0 13 8 10 4 73 39 21 19 0 5 12 13 6 19 2 36 45 37 13 6 13 0 19 2 36 43 1 12 72 2 36 3 62 73 43 2 63 43 5 29) #17# #1# 20284) si::fset function "Returns a vector of fuzzy matchings for each package that is
similiar to NAME, and the remaining time limit.
Cf. FUZZY-FIND-MATCHING-SYMBOLS." si::set-documentation)) #1# 20284) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 15 5 15 6 19 3 7 15 0 1 0 16 8 12 19 2 9 29) #18=#A(t (10) (swank::fuzzy-completion-selected swank::original-string swank::completion #Y(swank::fuzzy-completion-selected nil nil (24 45 1 24 45 2 26 75 73 29) #18# #1# 22531) si::fset function "This function is called by Slime when a fuzzy completion is
selected by the user.  It is for future expansion to make
testing, say, a machine learning algorithm for completion scoring
easier.

ORIGINAL-STRING is the string the user completed from, and
COMPLETION is the completion object (see docstring for
SWANK:FUZZY-COMPLETIONS) corresponding to the completion that the
user selected." si::set-documentation symbol-package export)) #1# 22531) #Y(si::bytecodes nil nil (1 0 16 1 8 30 52 0 15 0 15 2 15 3 19 3 4 1 0 73 29) #A(t (5) (swank::*fuzzy-recursion-soft-limit* si::*make-special variable "This is a soft limit for recursion in
RECURSIVELY-COMPUTE-MOST-COMPLETIONS.  Without this limit,
completing a string such as \"ZZZZZZ\" with a symbol named
\"ZZZZZZZZZZZZZZZZZZZZZZZ\" will result in explosive recursion to
find all the ways it can match.

Most natural language searches and symbols do not have this
problem -- this is only here as a safeguard." si::set-documentation)) #1# 23062) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((fixnum swank::*fuzzy-recursion-soft-limit*) proclaim)) #1# 23517) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #19=#A(t (19) (swank::compute-highest-scoring-completion swank::short swank::full swank::result swank::score-completion #Y(nil nil nil (24 45 3 26 13 0 13 2 13 1 19 3 4 12 10 0 3 73 29) #19# #1# 23566) swank::compute-most-completions mapcar swank::scored-results > :key first sort swank::winner #Y(swank::compute-highest-scoring-completion nil nil (24 45 1 24 45 2 26 34 5 12 13 1 13 0 19 2 6 12 19 2 7 45 8 13 0 33 9 12 14 10 33 11 12 19 4 12 4 45 13 10 0 5 12 10 0 4 12 72 2 43 2 29) #19# #1# 23566) si::fset function "Finds the highest scoring way to complete the abbreviation
SHORT onto the string FULL, using CHAR= as a equality function for
letters.  Returns two values:  The first being the completion
chunks of the highest scorer, and the second being the score." si::set-documentation)) #1# 23566) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 15 0 15 8 15 9 19 3 10 1 0 73 29) #20=#A(t (11) (swank::compute-most-completions swank::short swank::full swank::*all-chunks* t swank::recursively-compute-most-completions #Y(swank::compute-most-completions nil nil (24 45 1 24 45 2 26 75 48 3 13 1 13 0 9 0 9 0 77 77 77 14 4 19 8 5 11 3 73 44 1 29) #20# #1# 24192) si::fset function "Finds most possible ways to complete FULL with the letters in SHORT.
Calls RECURSIVELY-COMPUTE-MOST-COMPLETIONS recursively.  Returns
a list of (&rest CHUNKS), where each CHUNKS is a description of
how a completion matches." si::set-documentation)) #1# 24192) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 15 0 15 35 15 36 19 3 37 1 0 73 29) #21=#A(t (38) (swank::recursively-compute-most-completions swank::short swank::full swank::short-index swank::initial-full-index swank::chunks swank::current-chunk swank::current-chunk-pos swank::recurse-p length = aref #Y(swank::short-cur nil nil (26 13 5 10 7 16 9 12 19 2 10 39 5 75 73 38 8 13 7 13 5 19 2 11 29) #21# #1# 24632) char swank::pos #Y(swank::add-to-chunk nil nil (24 45 13 24 45 14 26 10 4 76 39 5 10 0 51 3 13 1 10 4 3 51 4 73 29) #21# #1# 24632) :element-type character :initial-contents make-array nreverse swank::current-chunk-as-string #Y(swank::collect-chunk nil nil (26 10 2 73 39 42 10 2 16 9 12 14 16 15 17 14 18 13 2 19 5 19 16 20 45 21 13 2 10 0 6 2 12 10 4 3 51 4 75 51 3 75 51 2 73 43 1 29) #21# #1# 24632) swank::cur-char char= 1+ swank::*all-chunks* swank::*fuzzy-recursion-soft-limit* > #:g4993 + reverse swank::rev-chunks #Y(swank::recursively-compute-most-completions nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 24 45 7 24 45 8 26 30 3 12 15 22 10 5 39 5 32 0 18 0 10 7 45 14 38 102 13 10 13 0 19 2 11 45 23 32 4 18 0 39 11 13 0 32 4 18 0 12 19 2 24 39 62 10 5 39 33 13 12 13 11 13 10 10 1 16 25 12 13 8 13 7 13 6 11 26 16 9 12 14 27 19 2 28 76 12 19 8 0 8 1 45 29 13 11 13 0 19 2 30 51 11 43 1 13 0 13 1 32 3 18 2 38 5 32 2 18 0 43 1 10 0 16 25 12 53 0 13 0 10 10 16 9 12 19 2 10 39 -112 43 1 32 0 18 0 32 2 18 0 39 5 75 73 38 19 10 6 16 31 45 32 13 0 11 26 3 52 26 10 0 73 43 1 43 3 29) #21# #1# 24632) si::fset function "Recursively (if RECURSE-P is true) find /most/ possible ways
to fuzzily map the letters in SHORT onto FULL, using CHAR= to
determine if two letters match.

A chunk is a list of elements that have matched consecutively.
When consecutive matches stop, it is coerced into a string,
paired with the starting position of the chunk, and pushed onto
CHUNKS.

Whenever a letter matches, if RECURSE-P is true,
RECURSIVELY-COMPUTE-MOST-COMPLETIONS calls itself with a position
one index ahead, to find other possibly higher scoring
possibilities.  If there are less than
*FUZZY-RECURSION-SOFT-LIMIT* results in *ALL-CHUNKS* currently,
this call will also recurse.

Once a word has been completely matched, the chunks are pushed
onto the special variable *ALL-CHUNKS* and the function returns." si::set-documentation)) #1# 24632) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*fuzzy-completion-symbol-prefixes* si::*make-special boundp "*+-%&?<" variable "Letters that are likely to be at the beginning of a symbol.
Letters found after one of these prefixes will be scored as if
they were at the beginning of ths symbol." si::set-documentation)) #1# 28089) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*fuzzy-completion-symbol-suffixes* si::*make-special boundp "*+->" variable "Letters that are likely to be at the end of a symbol.
Letters found before one of these suffixes will be scored as if
they were at the end of the symbol." si::set-documentation)) #1# 28354) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*fuzzy-completion-word-separators* si::*make-special boundp "-/." variable "Letters that separate different words in symbols.  Letters
after one of these symbols will be scores more highly than other
letters." si::set-documentation)) #1# 28567) #Y(si::bytecodes nil nil (15 0 1 46 12 19 2 47 15 0 15 48 15 49 19 3 50 1 0 73 29) #22=#A(t (51) (swank::score-completion swank::completion swank::short swank::full swank::pos = #Y(swank::at-beginning-p nil nil (24 45 4 26 13 0 9 0 19 2 5 29) #22# #1# 28758) aref swank::*fuzzy-completion-symbol-prefixes* find #Y(swank::after-prefix-p nil nil (24 45 4 26 13 0 9 1 19 2 5 73 39 14 13 10 9 0 19 2 7 12 14 8 19 2 9 29) #22# #1# 28758) swank::*fuzzy-completion-word-separators* #Y(swank::word-separator-p nil nil (24 45 4 26 13 10 13 0 19 2 7 12 14 11 19 2 9 29) #22# #1# 28758) 1- #Y(swank::after-word-separator-p nil nil (24 45 4 26 13 10 10 0 16 13 12 19 2 7 12 14 11 19 2 9 29) #22# #1# 28758) length #Y(swank::at-end-p nil nil (24 45 4 26 13 0 10 10 16 15 16 13 12 19 2 5 29) #22# #1# 28758) - swank::*fuzzy-completion-symbol-suffixes* #Y(swank::before-suffix-p nil nil (24 45 4 26 13 0 10 10 16 15 12 9 2 19 2 17 12 19 2 5 73 39 19 13 10 10 10 16 15 16 13 12 19 2 7 12 14 18 19 2 9 29) #22# #1# 28758) swank::base-score swank::chunk-pos zerop 0.85 * 1.2 expt + max #Y(swank::score-or-percentage-of-previous nil nil (24 45 20 24 45 4 24 45 21 26 10 0 16 22 39 6 10 2 73 38 38 13 2 10 1 16 13 12 10 0 16 13 12 32 4 18 2 12 15 23 19 2 24 12 15 25 10 0 17 26 12 19 2 27 12 19 2 28 29) #22# #1# 28758) #Y(swank::score-char nil nil (24 45 4 24 45 21 26 13 1 32 10 18 1 39 6 8 10 73 38 69 13 1 32 9 18 1 39 6 8 10 73 38 56 13 1 32 8 18 1 39 6 8 1 73 38 43 13 1 32 7 18 1 39 6 8 8 73 38 30 13 1 32 6 18 1 39 6 8 6 73 38 17 13 1 32 5 18 1 39 6 8 6 73 38 4 8 1 73 12 13 1 13 0 32 4 18 3 29) #22# #1# 28758) swank::chunk second #:loop-limit5001 #:loop-sum-5002 0 >= 1+ #Y(swank::score-chunk nil nil (24 45 31 26 58 60 98 10 1 16 32 16 15 12 9 0 46 21 46 33 10 3 4 45 4 8 0 45 34 57 35 61 2 14 56 13 4 13 3 19 2 36 39 4 35 0 1 13 1 13 2 13 4 32 8 18 2 12 19 2 27 51 1 10 4 16 37 51 4 13 4 13 3 19 2 36 39 4 35 0 1 10 2 16 37 51 2 35 0 0 10 1 73 36 5 62 73 43 1 43 1 43 2 63 29) #22# #1# 28758) mapcar swank::chunk-scores 10.0 / swank::length-score reduce list #Y(swank::score-completion nil nil (24 45 1 24 45 2 24 45 3 26 31 9 6 10 12 14 16 19 29 30 38 32 0 12 13 11 19 2 39 45 40 15 41 10 10 16 15 12 10 11 16 15 12 19 2 17 16 37 12 19 2 42 45 43 33 27 12 13 1 19 2 44 12 13 0 19 2 27 12 33 45 12 13 1 13 13 19 3 39 12 10 0 6 2 12 72 2 43 2 43 9 29) #22# #1# 28758) si::fset function "Scores the completion chunks COMPLETION as a completion from
the abbreviation SHORT to the full string FULL.  COMPLETION is a
list like:
    ((0 \"mul\") (9 \"v\") (15 \"b\"))
Which, if SHORT were \"mulvb\" and full were \"multiple-value-bind\",
would indicate that it completed as such (completed letters
capitalized):
    MULtiple-Value-Bind

Letters are given scores based on their position in the string.
Letters at the beginning of a string or after a prefix letter at
the beginning of a string are scored highest.  Letters after a
word separator such as #- are scored next highest.  Letters at
the end of a string or before a suffix letter at the end of a
string are scored medium, and letters anywhere else are scored
low.

If a letter is directly after another matched letter, and its
intrinsic value in that position is less than a percentage of the
previous letter's value, it will use that percentage instead.

Finally, a small scaling factor is applied to favor shorter
matches, all other things being equal." si::set-documentation)) #1# 28758) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #23=#A(t (19) (swank::highlight-completion swank::completion swank::full copy-seq nstring-downcase swank::highlit si::%dolist-var swank::chunk :start :end second length + nstring-upcase #Y(swank::highlight-completion nil nil (24 45 1 24 45 2 26 10 0 16 3 12 19 1 4 45 5 10 2 45 6 75 45 7 38 41 10 1 4 51 0 13 2 14 8 10 0 4 12 14 9 10 0 4 12 10 0 16 10 16 11 12 19 2 12 12 19 5 13 51 2 10 1 5 51 1 10 1 40 -43 43 2 10 0 73 43 1 29) #23# #1# 31826) si::fset function "Given a chunk definition COMPLETION and the string FULL,
HIGHLIGHT-COMPLETION will create a string that demonstrates where
the completion matched in the string.  Matches will be
capitalized, while the rest of the string will be lower-case." si::set-documentation)) #1# 31826) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #24=#A(t (25) (swank::format-fuzzy-completion-set swank::winners #:loop-list5012 swank::winner #:loop-maxmin-flag-5015 #:loop-maxmin-temp-5014 #:loop-maxmin-5013 0 length > t swank::max-len #:loop-list5016 swank::result swank::score swank::sym #:loop-desetq-temp "~&~VA  score ~8,2F  ~A" swank::highlight-completion format #Y(swank::format-fuzzy-completion-set nil nil (24 45 1 26 58 60 86 77 13 1 46 2 46 3 9 0 9 0 77 46 4 46 5 46 6 57 7 61 2 2 51 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 10 4 4 16 8 51 2 10 3 76 40 8 13 2 13 1 19 2 9 39 9 11 10 51 3 10 2 51 1 35 0 0 10 1 73 36 6 62 43 3 43 2 63 45 11 77 77 77 13 1 46 12 46 13 46 14 46 15 57 7 61 2 2 70 10 4 2 39 4 35 0 1 10 4 4 45 16 10 0 4 51 2 10 0 5 51 0 10 0 4 51 3 10 0 5 51 0 10 0 4 51 4 43 1 10 4 5 51 4 14 10 15 17 13 5 13 3 13 1 19 2 18 12 13 2 13 3 19 6 19 35 0 0 62 73 43 4 43 1 29) #24# #1# 32460) si::fset function "Given a list of completion objects such as on returned by
FUZZY-COMPLETION-SET, format the list into user-readable output
for interactive debugging purpose." si::set-documentation)) #1# 32460) #Y(si::bytecodes nil nil (11 0 16 1 29) #A(t (2) (:swank-fuzzy provide)) #1# 32938))
