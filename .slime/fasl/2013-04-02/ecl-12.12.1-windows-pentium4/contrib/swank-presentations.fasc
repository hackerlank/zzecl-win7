(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SWANK" si::select-package)) #1=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/contrib/swank-presentations.lisp" 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*record-repl-results* si::*make-special boundp t variable "Non-nil means that REPL results are saved for later lookup." si::set-documentation)) #1# 416) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 10 14 3 15 4 19 2 5 52 0 15 0 15 6 15 7 19 3 8 1 0 73 29) #A(t (9) (swank::*object-to-presentation-id* si::*make-special boundp :test eq swank-backend::make-weak-key-hash-table variable "Store the mapping of objects to numeric identifiers" si::set-documentation)) #1# 573) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 10 14 3 15 4 19 2 5 52 0 15 0 15 6 15 7 19 3 8 1 0 73 29) #A(t (9) (swank::*presentation-id-to-object* si::*make-special boundp :test eql swank-backend::make-weak-value-hash-table variable "Store the mapping of numeric identifiers to objects" si::set-documentation)) #1# 711) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #2=#A(t (6) (swank::clear-presentation-tables swank::*object-to-presentation-id* clrhash swank::*presentation-id-to-object* #Y(swank::clear-presentation-tables nil nil (26 11 1 16 2 11 3 16 2 29) #2# #1# 852) si::fset)) #1# 852) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 15 0 15 3 15 4 19 3 5 1 0 73 29) #A(t (6) (swank::*presentation-counter* si::*make-special boundp variable "identifier counter" si::set-documentation)) #1# 974) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 7 1 3 16 4 52 0 1 0 73 29) #A(t (5) (swank::*nil-surrogate* si::*make-special boundp "nil-surrogate" make-symbol)) #1# 1032) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #3=#A(t (16) (swank::save-presented-object swank::object swank::*nil-surrogate* swank::*object-to-presentation-id* gethash #:g5589 swank::*presentation-counter* + swank::id swank::*presentation-id-to-object* si::hash-set #Y(swank::save-presented-object nil nil (24 45 1 26 10 0 76 39 5 11 2 38 3 10 0 45 1 13 0 14 3 19 2 4 73 40 41 8 1 45 5 14 6 13 0 19 2 7 52 6 43 1 45 8 13 0 14 9 13 1 19 3 10 13 1 14 3 13 0 19 3 10 10 0 73 43 1 43 1 29) #3# #1# 1090) si::fset function "Save OBJECT and return the assigned id.
If OBJECT was saved previously return the old id." si::set-documentation)) #1# 1090) #Y(si::bytecodes nil nil (15 0 1 48 12 19 2 49 15 0 15 50 15 51 19 3 52 15 0 1 0 16 53 12 19 2 54 29) #4=#A(t (55) (swank::lookup-presented-object swank::id #:g5607 integer typep swank::*presentation-id-to-object* gethash swank::foundp swank::object swank::*nil-surrogate* eql t cons #:|tmp-5610| #:|op-5608| #:|rand-5609| :frame-var #:g5611 #:g5612 si::dm-too-few-arguments swank-backend::thread-id swank::frame swank::index si::dm-too-many-arguments #:error-return swank::value #Y(nil nil nil (24 45 25 26 13 0 14 11 72 2 29) #4# #1# 1796) #:normal-return #:g5613 #:g5614 0 si::temp #Y(nil nil nil (24 45 31 26 10 0 51 2 35 1 0 29) #4# #1# 1796) si::*handler-clusters* swank-backend::frame-var-value condition :inspected-part #:g5616 #:g5617 swank::part-index swank::*inspectee-parts* length < swank::inspector-nth-part "destructure-case failed: ~S" error (integer cons) si::etypecase-error #Y(swank::lookup-presented-object nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 49 13 1 14 5 19 2 6 47 1 7 45 8 13 0 11 9 17 10 39 8 77 14 11 72 2 38 18 10 0 76 39 7 77 77 72 2 38 7 13 0 13 1 72 2 43 2 38 280 13 0 15 12 19 2 4 39 265 10 1 45 13 10 0 4 45 14 10 1 5 45 15 10 1 42 16 161 10 0 45 17 10 0 45 18 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 20 10 1 76 39 6 13 2 19 1 19 10 1 4 12 10 1 5 51 1 22 45 21 10 2 76 39 6 13 3 19 1 19 10 2 4 12 10 2 5 51 2 22 45 22 10 3 39 6 13 4 19 1 23 57 24 60 70 34 26 12 57 27 60 59 57 28 60 52 75 45 29 57 30 61 1 27 15 11 34 32 3 6 1 12 11 33 3 48 33 13 6 13 5 19 2 34 36 3 36 2 44 1 10 1 45 35 77 77 72 2 43 1 36 2 62 73 43 1 63 36 1 63 69 21 23 63 43 5 38 82 42 36 72 10 0 45 37 10 0 45 38 10 0 76 39 6 13 1 19 1 19 10 0 4 12 10 0 5 51 0 22 45 39 10 1 39 6 13 2 19 1 23 13 0 11 40 16 41 12 19 2 42 39 13 13 0 19 1 43 12 14 11 72 2 38 5 77 77 72 2 43 3 38 8 15 44 13 2 19 2 45 43 3 38 7 13 0 1 46 17 47 43 1 29) #4# #1# 1796) si::fset function "Retrieve the object corresponding to ID.
The secondary value indicates the absence of an entry." si::set-documentation symbol-package export)) #1# 1796) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 15 0 1 0 16 12 12 19 2 13 29) #5=#A(t (14) (swank::lookup-presented-object-or-lose swank::id swank::lookup-presented-object swank::foundp swank::object "Attempt to access unrecorded object (id ~D)." error #Y(swank::lookup-presented-object-or-lose nil nil (24 45 1 26 13 0 19 1 2 47 1 3 45 4 10 1 39 6 10 0 73 38 8 15 5 13 2 19 2 6 43 2 29) #5# #1# 3011) si::fset function "Get the result of the previous REPL evaluation with ID." si::set-documentation symbol-package export)) #1# 3011) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 15 0 15 5 15 6 19 3 7 15 0 1 0 16 8 12 19 2 9 29) #6=#A(t (10) (swank::clear-repl-results swank::clear-presentation-tables t #Y(swank::clear-repl-results nil nil (26 19 0 1 11 2 73 29) #6# #1# 3297) si::fset function "Forget the results of all previous REPL evaluations." si::set-documentation symbol-package export)) #1# 3297) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #7=#A(t (21) (swank::present-repl-results values swank::value swank::*record-repl-results* swank::save-presented-object swank::id :presentation-start :repl-result swank::send-to-emacs :write-string prin1-to-string :presentation-end #\Newline string #Y(swank-backend::send nil nil (24 45 2 26 11 3 39 6 13 0 19 1 4 45 5 14 6 13 0 11 7 6 3 12 19 1 8 14 9 10 1 16 10 12 11 7 6 3 12 19 1 8 14 11 13 0 11 7 6 3 12 19 1 8 14 9 1 12 16 13 12 11 7 6 3 12 19 1 8 43 1 29) #7# #1# 3430) fresh-line finish-output (:write-string "; No value" :repl-result) mapc #Y(swank::present-repl-results nil nil (24 45 1 26 30 1 14 19 0 15 19 0 16 10 1 76 39 8 15 17 19 1 8 38 9 32 0 12 13 1 19 2 18 43 1 29) #7# #1# 3430) si::fset)) #1# 3430) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (swank::*presentation-active-menu* si::*make-special boundp)) #1# 4174) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #8=#A(t (13) (swank::menu-choices-for-presentation-id swank::id swank::lookup-presented-object swank::presentp swank::ob swank::not-present swank::menu-choices-for-presentation swank::menu-and-actions swank::*presentation-active-menu* car mapcar #Y(swank::menu-choices-for-presentation-id nil nil (24 45 1 26 13 0 19 1 2 47 1 3 45 4 10 1 76 39 6 1 5 73 38 24 13 0 19 1 6 45 7 13 3 10 0 3 52 8 15 9 13 0 19 2 10 43 1 43 2 29) #8# #1# 4874) si::fset)) #1# 4874) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #9=#A(t (12) (swank::swank-ioify swank::thing keywordp symbolp #\: symbol-name find swank::swank-io-package intern consp #Y(swank::swank-ioify nil nil (24 45 1 26 10 0 16 2 39 6 10 0 73 38 60 10 0 16 3 39 12 15 4 10 0 16 5 12 19 2 6 76 39 13 10 0 16 5 12 15 7 19 2 8 38 29 10 0 16 9 39 20 10 0 4 12 19 1 0 12 10 0 5 12 19 1 0 3 73 38 4 10 0 73 29) #9# #1# 5214) si::fset)) #1# 5214) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #10=#A(t (18) (swank::execute-menu-choice-for-presentation-id swank::id count swank::item swank::lookup-presented-object swank::ob (equal swank::id (car swank::*presentation-active-menu*)) "Bug: Execute menu call for id ~a  but menu has id ~a" swank::*presentation-active-menu* si::assert-failure equal 1- nth second swank::action swank::swank-ioify #Y(swank::execute-menu-choice-for-presentation-id nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 45 5 38 16 15 6 77 77 15 7 13 3 11 8 4 12 19 6 9 13 3 11 8 4 17 10 76 40 -24 10 2 16 11 12 11 8 5 17 12 16 13 45 14 13 0 13 2 13 1 13 4 20 3 23 12 19 1 15 43 1 43 1 29) #10# #1# 5481) si::fset)) #1# 5481) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 15 0 15 0 77 15 6 15 7 1 9 12 14 2 19 6 10 12 19 2 11 29) #11=#A(t (12) (swank::menu-choices-for-presentation :delete-methods t :lambda-list (swank::object) ensure-generic-function (t) (swank::ob) swank::ob #Y(nil nil nil (24 45 8 26 75 73 29) #11# #1# 5888) clos::install-method clos::associate-methods-to-gfun)) #1# 5888) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 63 12 14 64 19 6 65 29) #12=#A(t (66) (swank::menu-choices-for-presentation (pathname) (swank::ob) swank::ob #:g5645 #:g5646 0 error si::temp #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #12# #1# 5989) si::*handler-clusters* probe-file condition swank::file-exists :type "lisp" make-pathname swank::lisp-type pathname-type ("lisp" "cl") :test equal member merge-pathnames swank::source #:g5648 #:g5649 #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #12# #1# 5989) swank::source-file #:g5651 #:g5652 #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #12# #1# 5989) compile-file-pathname truename namestring swank::fasl-file "Edit this file" swank::choice swank::object swank::id swank::ed-in-emacs #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 10 1 16 33 16 34 12 19 1 40 75 73 29) #12# #1# 5989) "Dired containing directory" :name "" "" #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 14 43 15 44 14 14 15 45 19 4 16 12 13 1 19 2 23 16 33 16 34 12 19 1 40 75 73 29) #12# #1# 5989) "Load this fasl file" load #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 13 7 19 1 48 75 73 29) #12# #1# 5989) "Delete this fasl file" swank::nt "Delete ~a? " swank::y-or-n-p-in-emacs delete-file #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 10 7 16 33 16 34 45 51 15 52 13 0 19 2 53 39 5 10 0 16 54 43 1 75 73 29) #12# #1# 5989) "Edit lisp source file" #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 10 4 16 33 16 34 12 19 1 40 75 73 29) #12# #1# 5989) "Load lisp source file" #Y(nil nil nil (24 45 37 24 45 38 24 45 39 26 13 4 19 1 48 75 73 29) #12# #1# 5989) next-method-p call-next-method remove #Y(nil nil nil (24 45 3 26 57 4 60 47 75 45 5 57 6 61 1 22 15 7 34 9 3 6 1 12 11 10 3 48 10 10 3 16 11 36 2 44 1 10 1 45 12 77 13 0 72 2 43 1 36 2 62 43 1 63 45 13 14 14 15 15 19 2 16 45 17 13 2 19 1 18 12 15 19 14 20 15 21 19 4 22 76 39 66 13 0 13 2 19 2 23 45 24 57 25 60 47 75 45 26 57 6 61 1 22 15 7 34 27 3 6 1 12 11 10 3 48 10 10 3 16 11 36 2 44 1 10 1 45 12 77 13 0 72 2 43 1 36 2 62 43 1 63 39 3 10 0 43 1 45 28 10 2 39 72 57 29 60 59 75 45 30 57 6 61 1 33 15 7 34 31 3 6 1 12 11 10 3 48 10 13 4 13 6 19 2 23 12 19 1 32 16 33 16 34 36 2 44 1 10 1 45 12 77 13 0 72 2 43 1 36 2 62 73 43 1 63 12 10 3 16 33 16 34 17 21 45 35 77 10 3 39 4 10 0 76 73 39 8 15 36 34 41 6 2 73 12 10 3 73 39 8 15 42 34 46 6 2 73 12 10 0 73 39 8 15 47 34 49 6 2 73 12 10 0 73 39 8 15 50 34 55 6 2 73 12 10 1 73 39 8 15 56 34 57 6 2 73 12 10 1 73 39 8 15 58 34 59 6 2 73 12 19 0 60 39 4 19 0 61 7 7 12 19 2 62 43 4 29) #12# #1# 5989) t clos::install-method)) #1# 5989) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 10 12 14 11 19 6 12 29) #13=#A(t (13) (swank::menu-choices-for-presentation (function) (swank::ob) swank::ob "Disassemble" swank::choice swank::object swank::id disassemble #Y(nil nil nil (24 45 5 24 45 6 24 45 7 26 10 1 16 8 29) #13# #1# 7954) #Y(nil nil nil (24 45 3 26 15 4 34 9 6 2 6 1 73 29) #13# #1# 7954) t clos::install-method)) #1# 7954) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 1 0 16 9 12 19 2 10 29) #14=#A(t (11) (swank::inspect-presentation swank::id swank::reset-p swank::lookup-presented-object-or-lose swank::what swank::reset-inspector swank::inspect-object #Y(swank::inspect-presentation nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 10 1 39 4 19 0 5 13 0 19 1 6 43 1 29) #14# #1# 8175) si::fset symbol-package export)) #1# 8175) #Y(si::bytecodes nil nil (1 0 52 1 73 29) #A(t (2) (swank::present-repl-results swank::*send-repl-results-function*)) #1# 8353) #Y(si::bytecodes nil nil (11 0 16 1 29) #A(t (2) (:swank-presentations provide)) #1# 8416))
