(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SWANK" si::select-package)) #1=#P"c:/zznix/home/zhoujd/zzemacs/site-lisp/slime/contrib/swank-fancy-inspector.lisp" 0) #Y(si::bytecodes nil nil (14 0 19 1 1 29) #A(t (2) (:swank-util swank::swank-require)) #1# 177) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 89 12 14 90 19 6 91 29) #2=#A(t (92) (swank-backend::emacs-inspect (symbol) (symbol) symbol symbol-package package string find-symbol swank::status swank::_symbol "Its name is" symbol-name swank-backend::label-value-line boundp constantp "It is a constant of value" "It is a global variable bound to" symbol-value :newline " " :action "[unbind]" makunbound #Y(nil nil nil (26 10 3 16 22 29) #2# #1# 267) ((:newline)) append ("It is unbound." (:newline)) "Documentation" variable swank::docstring-ispec macroexpand swank::definedp swank::expansion "It is a symbol macro with expansion" fboundp macro-function "It a macro with macro-function: " :value "It is a function: " symbol-function " " "[unbind]" fmakunbound #Y(nil nil nil (26 10 3 16 42 29) #2# #1# 267) ((:newline)) ("It has no function value." (:newline)) "Function documentation" function compiler-macro-function "It also names the compiler macro" " " "[remove]" #:g5029 #:g5030 compiler-macro si::put-sysprop #Y(nil nil nil (26 10 3 45 52 75 45 53 13 1 15 54 13 0 19 3 55 43 1 43 1 29) #2# #1# 267) (:newline) "Compiler macro documentation" "It is " string-downcase " to the package: " package-name :internal eq " " "[export]" export #Y(nil nil nil (26 13 3 13 2 19 2 67 29) #2# #1# 267) " " "[unintern]" unintern #Y(nil nil nil (26 13 3 13 2 19 2 71 29) #2# #1# 267) (:newline) ("It is a non-interned symbol." (:newline)) "Property list" symbol-plist find-class "It names the class " " " "[remove]" #:g5031 #:g5032 clos::setf-find-class #Y(nil nil nil (26 10 3 45 81 75 45 82 13 0 13 1 19 2 83 43 1 43 1 29) #2# #1# 267) (:newline) find-package "It names the package" swank::inspect-type-specifier #Y(nil nil nil (24 45 3 26 10 0 16 4 45 5 10 0 73 39 11 10 1 16 6 12 13 0 19 2 7 47 1 8 45 9 15 10 10 3 16 11 12 19 2 12 12 10 3 16 13 39 49 13 3 19 1 14 39 6 1 15 73 38 4 1 16 73 12 10 3 16 17 12 14 18 77 19 4 12 12 15 19 14 20 15 21 34 23 6 3 6 2 12 15 24 19 3 25 38 4 1 26 73 12 15 27 13 3 15 28 19 3 29 12 13 3 19 1 30 47 1 31 45 32 10 1 73 39 8 15 33 13 0 19 2 12 12 43 2 10 3 16 34 39 58 13 3 19 1 35 39 17 15 36 14 37 13 3 19 1 35 6 2 6 2 73 38 14 15 38 14 37 10 3 16 39 6 2 6 2 73 12 15 40 14 20 15 41 34 43 6 3 6 2 12 15 44 19 3 25 38 4 1 45 73 12 15 46 13 3 15 47 19 3 29 12 13 3 19 1 48 73 39 35 15 49 13 3 19 1 48 12 14 18 77 19 4 12 12 15 50 14 20 15 51 34 56 6 3 12 1 57 6 3 12 19 2 25 12 15 58 13 3 15 54 19 3 29 12 10 2 39 72 15 59 10 1 16 6 12 19 1 60 12 15 61 14 37 13 2 10 2 16 62 6 3 12 14 63 10 1 17 64 73 39 14 15 65 14 20 15 66 34 68 6 3 6 2 73 12 15 69 14 20 15 70 34 72 6 3 12 1 73 6 3 12 19 2 25 7 5 73 38 4 1 74 73 12 15 75 10 3 16 76 12 19 2 12 12 13 3 77 19 2 77 73 39 34 15 78 14 37 13 3 19 1 77 12 10 3 16 6 6 3 12 15 79 14 20 15 80 34 84 6 3 12 1 85 6 5 73 12 10 3 16 86 73 39 11 15 87 10 3 16 86 12 19 2 12 12 13 3 19 1 88 12 19 13 25 43 2 43 1 29) #2# #1# 267) t clos::install-method)) #1# 267) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #3=#A(t (4) (swank::inspect-type-specifier symbol #Y(swank::inspect-type-specifier nil nil (24 45 1 26 75 73 29) #3# #1# 3966) si::fset)) #1# 3966) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #4=#A(t (20) (swank::docstring-ispec swank::label swank::object swank::kind documentation swank::docstring length + < ": " (:newline) ":" (:newline) "  " (:newline) #Y(swank::docstring-ispec nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 0 19 2 4 45 5 10 0 76 39 5 75 73 38 50 10 3 16 6 12 10 0 16 6 12 19 2 7 12 9 75 19 2 8 39 14 13 3 15 9 13 0 1 10 6 4 73 38 16 13 3 15 11 15 12 15 13 13 0 1 14 6 6 73 43 1 29) #4# #1# 4046) si::fset function "Return a inspector spec if OBJECT has a docstring of of kind KIND." si::set-documentation)) #1# 4046) #Y(si::bytecodes nil nil (33 0 12 77 15 1 19 1 2 6 1 12 77 19 4 3 76 73 39 16 15 0 77 15 4 15 5 1 8 12 14 9 19 6 10 29) #5=#A(t (11) (swank-backend::emacs-inspect function find-class find-method (function) (swank::f) swank::f swank::inspect-function #Y(nil nil nil (24 45 6 26 13 0 19 1 7 29) #5# #1# 5572) t clos::install-method)) #1# 5572) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #6=#A(t (17) (swank::inspect-function swank::f "Name" swank-backend::function-name swank-backend::label-value-line "Its argument list is: " swank-backend::arglist swank::inspector-princ (:newline) "Documentation" t swank::docstring-ispec function-lambda-expression "Lambda Expression" append #Y(swank::inspect-function nil nil (24 45 1 26 15 2 13 0 19 1 3 12 19 2 4 12 15 5 13 0 19 1 6 12 19 1 7 12 1 8 6 3 12 15 9 13 0 14 10 19 3 11 12 10 0 16 12 73 39 11 15 13 10 0 16 12 12 19 2 4 12 19 4 14 29) #6# #1# 5722) si::fset)) #1# 5722) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #7=#A(t (17) (swank::method-specializers-for-inspect method swank::spec #:g5034 clos::eql-specializer typep eql clos::eql-specializer-object class-name #Y(nil nil nil (24 45 2 26 10 0 45 3 13 0 15 4 19 2 5 39 13 15 6 13 1 19 1 7 6 2 73 38 6 13 1 19 1 8 43 1 29) #7# #1# 6080) clos::method-specializers mapcar #Y(swank::method-specializers-for-inspect nil nil (24 45 1 26 34 9 12 13 0 19 1 10 12 19 2 11 29) #7# #1# 6080) si::fset function "Return a \"pretty\" list of the method's specializers. Normal
  specializers are replaced by the name of the class, eql
  specializers are replaced by `(eql ,object)." si::set-documentation)) #1# 6080) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #8=#A(t (12) (swank::method-for-inspect-value method clos::method-generic-function clos::generic-function-name method-qualifiers swank::method-specializers-for-inspect append #Y(swank::method-for-inspect-value nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 6 1 12 13 0 19 1 4 12 13 0 19 1 5 12 19 3 6 29) #8# #1# 6567) si::fset function "Returns a \"pretty\" list describing METHOD. The first element
  of the list is the name of generic-function method is
  specialiazed on, the second element is the method qualifiers,
  the rest of the list is the method's specialiazers (as per
  method-specializers-for-inspect)." si::set-documentation)) #1# 6567) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 10 12 14 11 19 6 12 29) #9=#A(t (13) (swank-backend::emacs-inspect (standard-object) (swank::object) swank::object class-of class "Class: " :value (:newline) swank::all-slots-for-inspector #Y(nil nil nil (24 45 3 26 10 0 16 4 45 5 15 6 14 7 10 0 6 2 12 15 8 13 1 19 1 9 7 4 73 43 1 29) #9# #1# 7115) t clos::install-method)) #1# 7115) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*gf-method-getter* si::*make-special boundp swank::methods-by-applicability variable "This function is called to get the methods of a generic function.
The default returns the method sorted by applicability.
See `methods-by-applicability'." si::set-documentation)) #1# 7311) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #10=#A(t (17) (swank::specializer< swank::specializer1 swank::specializer2 swank::s2 swank::s1 clos::eql-specializer typep class clos::class-finalized-p clos::class-precedence-list #Y(swank::cpl nil nil (24 45 7 26 13 0 19 1 8 73 39 6 13 0 19 1 9 29) #10# #1# 7529) member #Y(swank::specializer< nil nil (24 45 1 24 45 2 26 13 1 13 0 46 3 46 4 13 0 15 5 19 2 6 39 12 13 1 15 5 19 2 6 76 73 38 18 30 1 10 13 2 13 1 32 0 18 1 12 19 2 11 43 1 43 2 29) #10# #1# 7529) si::fset function "Return true if SPECIALIZER1 is more specific than SPECIALIZER2." si::set-documentation)) #1# 7529) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 15 0 15 18 15 19 19 3 20 1 0 73 29) #11=#A(t (21) (swank::methods-by-applicability swank::gf swank::meth1 swank::meth2 clos::method-specializers #:loop-list5041 swank::s1 #:loop-list5042 swank::s2 0 swank::specializer< t #Y(swank::method< nil nil (24 45 2 24 45 3 26 58 60 104 77 13 2 19 1 4 12 46 5 46 6 77 13 3 19 1 4 12 46 7 46 8 57 9 61 2 2 69 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 3 19 2 10 39 7 75 73 36 5 38 15 13 3 13 1 19 2 10 39 6 11 11 73 36 5 35 0 0 62 73 43 2 43 2 63 29) #11# #1# 8020) clos::generic-function-methods copy-seq stable-sort #Y(swank::methods-by-applicability nil nil (24 45 1 26 31 1 12 13 1 19 1 13 16 14 12 32 0 12 19 2 15 43 1 29) #11# #1# 8020) si::fset function "Return methods ordered by most specific argument types.

`method-specializer<' is used for sorting." si::set-documentation)) #1# 8020) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #12=#A(t (15) (swank::abbrev-doc swank::doc swank::maxlen #\. position 1- 1+ length min subseq #Y(swank::abbrev-doc nil nil (24 45 1 25 40 3 9 80 46 2 26 13 1 9 0 15 3 13 1 19 2 4 40 5 10 0 16 5 16 6 12 13 0 10 1 16 7 12 19 3 8 12 19 3 9 29) #12# #1# 8637) si::fset function "Return the first sentence of DOC, but not more than MAXLAN characters." si::set-documentation)) #1# 8637) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 2 77 77 15 6 19 15 7 15 0 19 1 19 78 15 15 8 1 17 12 19 2 18 1 0 73 29) #13=#A(t (20) (swank::inspector-checklist swank::checklist. ((swank::buttons nil :type #14=(or null simple-vector)) (count 0)) ((swank::buttons nil #14# nil 0 nil) (count 0 t nil 1 nil)) swank::copy-inspector-checklist ((swank::%make-checklist (swank::buttons))) swank::inspector-checklist-p si::define-structure swank::%make-checklist swank::buttons count (or null simple-vector) typep (or null simple-vector) si::structure-type-error 0 si::make-structure #Y(swank::%make-checklist nil nil (24 45 9 26 8 0 45 10 13 1 15 11 19 2 12 76 39 12 13 1 15 13 15 0 15 9 19 4 14 15 15 13 1 13 0 19 3 16 29) #13# #1# 8892) si::fset find-class)) #1# 8892) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #15=#A(t (7) (swank::make-checklist swank::n :initial-element make-array swank::%make-checklist #Y(swank::make-checklist nil nil (24 45 1 26 13 0 14 2 77 19 3 3 12 19 1 4 29) #15# #1# 9090) si::fset)) #1# 9090) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #16=#A(t (8) (swank::reinitialize-checklist swank::checklist #:g5045 #:g5046 swank::inspector-checklist si::structure-set #Y(swank::reinitialize-checklist nil nil (24 45 1 26 10 0 45 2 8 0 45 3 13 1 15 4 9 1 13 0 19 4 5 43 1 43 1 10 0 73 29) #16# #1# 9177) si::fset)) #1# 9177) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #17=#A(t (21) (swank::make-checklist-button swank::checklist swank::checklist.buttons swank::checklist.count swank::i swank::buttons #:g5053 #:g5055 + #:g5054 swank::inspector-checklist si::structure-set :action svref "[X]" "[ ]" si::svset #Y(nil nil nil (26 13 0 13 1 13 0 10 1 17 13 76 12 19 3 16 29) #17# #1# 9410) (:refreshp t) #Y(swank::make-checklist-button nil nil (24 45 1 26 13 0 19 1 2 12 13 0 19 1 3 12 46 4 46 5 10 2 45 6 8 1 45 7 13 1 19 1 3 12 13 0 19 2 8 45 9 13 2 15 10 9 1 13 0 19 4 11 43 3 14 12 13 0 10 1 17 13 39 6 1 14 73 38 4 1 15 73 12 34 17 12 1 18 7 4 73 43 2 29) #17# #1# 9410) si::fset)) #1# 9410) #Y(si::bytecodes nil nil (15 0 1 20 12 14 21 9 2 19 4 22 15 0 15 23 15 24 19 3 25 1 0 73 29) #18=#A(t (26) (swank::do-checklist #:g5060 #:g5059 #:g5061 si::dm-too-few-arguments #:g5062 #:g5063 swank::idx swank::checklist swank::body si::dm-too-many-arguments "buttons" gensym swank::buttons let swank::checklist.buttons dotimes length when svref #Y(swank::do-checklist nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 4 45 9 10 3 39 6 13 7 19 1 10 15 11 19 1 12 45 13 15 14 13 0 15 15 10 2 6 2 6 2 6 1 12 15 16 13 3 15 17 10 0 6 2 6 2 12 15 18 15 19 13 0 10 3 6 3 12 10 1 7 3 6 3 6 3 73 43 1 29) #18# #1# 9805) t si::fset function "Iterate over all set buttons in CHECKLIST." si::set-documentation)) #1# 9805) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #19=#A(t (5) (swank::box swank::thing :box #Y(swank::box nil nil (24 45 1 26 14 2 10 0 3 73 29) #19# #1# 10108) si::fset)) #1# 10108) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #20=#A(t (8) (swank::ref swank::box (eq (car swank::box) :box) si::assert-failure :box eq #Y(swank::ref nil nil (24 45 1 26 38 6 15 2 19 1 3 10 0 4 12 11 4 17 5 76 40 -15 10 0 5 73 29) #20# #1# 10149) si::fset)) #1# 10149) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #21=#A(t (12) (#22=(setf swank::ref) swank::value swank::box (eq (car swank::box) :box) si::assert-failure :box eq #:g5066 #:g5067 rplacd #Y(#22# nil nil (24 45 1 24 45 2 26 38 6 15 3 19 1 4 10 0 4 12 11 5 17 6 76 40 -15 10 0 45 7 10 2 45 8 13 1 10 0 17 9 10 0 73 43 1 43 1 29) #21# #1# 10213) si::fset)) #1# 10213) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*inspector-slots-default-order* si::*make-special boundp :alphabetically variable "Accepted values: :alphabetically and :unsorted" si::set-documentation)) #1# 10303) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 19 3 6 1 0 73 29) #A(t (7) (swank::*inspector-slots-default-grouping* si::*make-special boundp :all variable "Accepted values: :inheritance and :all" si::set-documentation)) #1# 10415) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 29) #A(t (6) (swank::all-slots-for-inspector :delete-methods t :lambda-list (swank::object) ensure-generic-function)) #1# 10511) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 108 12 14 20 19 6 109 29) #23=#A(t (110) (swank::all-slots-for-inspector (standard-object) (swank::object) swank::object class-of class clos::class-direct-slots swank::direct-slots clos::class-slots swank::effective-slots #:loop-list5116 swank::slot #:loop-maxmin-flag-5119 #:loop-maxmin-temp-5118 #:loop-maxmin-5117 0 clos::slot-definition-name symbol-name length > t swank::longest-slot-name-length :checklist swank::make-checklist swank::ensure-istate-metadata swank::reinitialize-checklist swank::checklist :grouping-kind swank::*inspector-slots-default-grouping* swank::box swank::grouping-kind :sort-order swank::*inspector-slots-default-order* swank::sort-order swank::ref #:g5120 :alphabetically string< :unsorted constantly (:alphabetically :unsorted) si::ecase-error swank::sort-predicate copy-seq :key sort swank::sorted-slots #:g5121 :all :inheritance swank::stable-sort-by-inheritance (:all :inheritance) "--------------------" (:newline) " Group slots by inheritance " :action #:g5122 "[ ]" "[X]" (:all :inheritance) swank::checklist.buttons fill #:g5123 #:g5125 (:all :inheritance) #:g5124 (setf swank::ref) #Y(nil nil nil (26 13 5 19 1 60 12 77 19 2 61 10 4 45 62 13 5 19 1 34 45 63 10 0 42 48 5 11 49 38 14 42 49 5 11 48 38 7 13 0 1 64 17 41 43 1 45 65 13 0 13 1 33 66 18 2 43 1 43 1 29) #23# #1# 10560) (:refreshp t) (:newline) " Sort slots alphabetically  " #:g5126 "[ ]" "[X]" (:unsorted :alphabetically) #:g5127 #:g5129 (:unsorted :alphabetically) #:g5128 (setf swank::ref) #Y(nil nil nil (26 13 5 19 1 60 12 77 19 2 61 10 3 45 75 13 4 19 1 34 45 76 10 0 42 38 5 11 36 38 14 42 36 5 11 38 38 7 13 0 1 77 17 41 43 1 45 78 13 0 13 1 33 79 18 2 43 1 43 1 29) #23# #1# 10560) (:refreshp t) (:newline) (:newline) "All Slots:" (:newline) swank::make-slot-listing swank::list-all-slots-by-inheritance (:newline) "[set value]" #:|buttons5130| si::%dotimes-var swank::idx svref nth swank::query-and-set-slot 1+ < #Y(nil nil nil (26 13 5 19 1 60 45 90 10 0 16 18 45 91 8 0 45 92 38 30 13 2 10 0 17 93 39 15 13 12 13 13 13 0 10 3 17 94 12 19 3 95 10 0 16 96 51 0 75 13 0 13 1 19 2 97 40 -37 73 43 2 43 1 29) #23# #1# 10560) (:refreshp t) "  " "[make unbound]" #:|buttons5131| clos::slot-makunbound-using-class #Y(nil nil nil (26 13 5 19 1 60 45 102 10 0 16 18 45 91 8 0 45 92 38 30 13 2 10 0 17 93 39 15 13 12 13 13 13 0 10 3 17 94 12 19 3 103 10 0 16 96 51 0 75 13 0 13 1 19 2 97 40 -37 73 43 2 43 1 29) #23# #1# 10560) (:refreshp t) (:newline) append #Y(nil nil nil (24 45 3 26 10 0 16 4 45 5 13 0 19 1 6 45 7 13 1 19 1 8 45 9 58 60 90 77 13 1 46 10 46 11 9 0 9 0 77 46 12 46 13 46 14 57 15 61 2 2 55 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 19 1 16 16 17 16 18 51 2 10 3 76 40 8 13 2 13 1 19 2 19 39 9 11 20 51 3 10 2 51 1 35 0 0 10 1 73 36 6 62 43 3 43 2 63 45 21 13 4 14 22 10 1 16 18 12 19 1 23 12 19 3 24 12 19 1 25 45 26 13 5 14 27 14 28 19 1 29 12 19 3 24 45 30 13 6 14 31 14 32 19 1 29 12 19 3 24 45 33 13 0 19 1 34 45 35 10 0 42 36 5 33 37 38 15 42 38 6 75 16 39 38 7 13 0 1 40 17 41 43 1 45 42 10 5 16 43 12 13 0 14 44 33 16 12 19 4 45 45 46 13 3 19 1 34 45 47 10 0 42 48 5 10 1 38 21 42 49 12 13 1 13 9 13 2 19 3 50 38 7 13 0 1 51 17 41 43 1 45 9 15 52 15 53 15 54 14 55 13 4 19 1 34 45 56 10 0 42 48 6 1 57 73 38 15 42 49 6 1 58 73 38 7 13 0 1 59 17 41 12 43 1 34 67 12 1 68 7 4 12 15 69 15 70 14 55 13 3 19 1 34 45 71 10 0 42 38 6 1 72 73 38 15 42 36 6 1 73 73 38 7 13 0 1 74 17 41 12 43 1 34 80 12 1 81 7 4 12 15 82 13 4 19 1 34 42 48 27 15 83 15 84 15 85 13 5 13 10 13 9 13 0 13 8 13 6 19 6 86 7 4 73 38 23 42 49 18 13 5 13 10 13 9 13 0 13 8 13 6 19 6 87 38 3 75 73 12 15 88 14 55 15 89 34 98 12 1 99 7 4 12 15 100 14 55 15 101 34 104 12 1 105 7 4 12 1 106 6 5 12 19 2 107 7 9 73 43 10 29) #23# #1# 10560) clos::install-method)) #1# 10560) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #24=#A(t (36) (swank::list-all-slots-by-inheritance swank::checklist swank::object class swank::effective-slots swank::direct-slots swank::longest-slot-name-length swank::slot swank::slot-home-class-using-class #Y(swank::slot-home-class nil nil (24 45 7 26 13 0 13 4 19 2 8 29) #24# #1# 14544) swank::current-slots #:loop-list5139 swank::previous-home-class swank::home-class #:loop-list-head5140 #:loop-list-tail5141 0 eq (:newline) rplacd "~A:" class-name format (:newline) #:g5143 nreverse swank::make-slot-listing copy-list #:g5144 last (:newline) "~A:" (:newline) append #Y(swank::list-all-slots-by-inheritance nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 30 1 9 75 45 10 58 60 221 77 13 5 46 11 46 7 75 45 12 75 45 13 75 6 1 45 14 10 0 45 15 57 16 61 2 32 176 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 13 5 32 9 18 1 51 4 10 4 51 3 13 3 10 4 17 17 39 10 13 5 10 8 3 51 8 38 96 13 1 1 18 6 1 51 1 17 19 13 1 77 15 20 13 4 19 1 21 12 19 3 22 6 1 51 1 17 19 13 1 1 23 6 1 51 1 17 19 10 1 45 24 13 16 13 15 13 14 10 9 16 25 12 13 12 13 11 19 6 26 16 27 45 28 13 1 10 0 17 19 10 0 43 1 43 1 39 10 10 1 5 12 19 1 29 51 1 10 5 6 1 51 8 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 10 3 51 4 13 5 32 9 18 1 51 3 35 0 0 10 2 5 73 36 7 62 73 43 2 43 1 43 1 43 2 63 12 10 0 73 39 47 15 30 77 15 31 10 0 4 12 13 5 19 2 8 12 19 1 21 12 19 3 22 12 15 32 13 7 13 6 13 5 10 0 16 25 12 13 3 13 2 19 6 26 7 4 73 12 19 2 33 43 1 43 1 29) #24# #1# 14544) si::fset)) #1# 14544) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 1 0 73 29) #25=#A(t (33) (swank::make-slot-listing swank::checklist swank::object class swank::effective-slots swank::direct-slots swank::longest-slot-name-length swank::slot-name length - :initial-element #\  make-string #Y(swank::padding-for nil nil (24 45 7 26 13 1 10 0 16 8 12 19 2 9 12 14 10 15 11 19 3 12 29) #25# #1# 16084) #:loop-list5149 swank::effective-slot swank::direct-slot #:loop-list-head5150 #:loop-list-tail5151 0 clos::slot-definition-name :key find swank::inspector-princ swank::make-checklist-button rplacd "  " :value " = " swank::slot-value-for-inspector (:newline) #Y(swank::make-slot-listing nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 30 1 13 58 60 201 77 13 4 46 14 46 15 75 45 16 75 45 7 75 6 1 45 17 10 0 45 18 57 19 61 2 2 156 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 13 5 19 1 20 12 13 10 14 21 33 20 12 19 4 22 51 4 13 5 19 1 20 12 19 1 23 51 3 13 1 13 14 19 1 24 6 1 51 1 17 25 13 1 1 26 6 1 51 1 17 25 13 1 14 27 10 4 39 10 13 4 10 5 6 2 73 38 4 10 5 73 12 10 3 6 3 6 1 51 1 17 25 13 1 13 3 32 8 18 1 6 1 51 1 17 25 13 1 1 28 6 1 51 1 17 25 13 1 13 12 13 13 13 5 19 3 29 6 1 51 1 17 25 13 1 1 30 6 1 51 1 17 25 35 0 0 10 2 5 73 36 7 62 73 43 2 43 1 43 1 43 2 63 43 1 29) #25# #1# 16084) si::fset)) #1# 16084) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 15 0 15 0 77 15 6 15 7 1 16 12 14 2 19 6 17 12 19 2 18 29) #26=#A(t (19) (swank::slot-value-for-inspector :delete-methods t :lambda-list (class swank::object swank::slot) ensure-generic-function (t t t) (class swank::object swank::slot) class swank::object swank::slot clos::slot-boundp-using-class boundp :value clos::slot-value-using-class "#<unbound>" #Y(nil nil nil (24 45 8 24 45 9 24 45 10 26 13 2 13 1 13 0 19 3 11 45 12 10 0 39 17 14 13 13 3 13 2 13 1 19 3 14 6 2 73 38 4 1 15 73 43 1 29) #26# #1# 17160) clos::install-method clos::associate-methods-to-gfun)) #1# 17160) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #27=#A(t (17) (swank::slot-home-class-using-class swank::slot class clos::slot-definition-name swank::slot-name clos::class-precedence-list reverse #:loop-list5154 #:loop-it-5155 0 clos::class-direct-slots :key :test eq member #Y(swank::slot-home-class-using-class nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 58 60 85 77 13 2 19 1 5 16 6 12 46 7 46 2 75 45 8 57 9 61 2 2 56 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 5 13 2 19 1 10 12 14 11 33 3 12 14 12 33 13 12 19 6 14 39 3 10 2 51 1 39 6 10 1 73 36 4 35 0 0 62 73 43 1 43 2 63 43 1 29) #27# #1# 17448) si::fset)) #1# 17448) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #28=#A(t (12) (swank::stable-sort-by-inheritance swank::slots class swank::predicate :key swank::s swank::slot-home-class-using-class class-name #Y(nil nil nil (24 45 5 26 13 0 13 2 19 2 6 12 19 1 7 29) #28# #1# 17860) stable-sort #Y(swank::stable-sort-by-inheritance nil nil (24 45 1 24 45 2 24 45 3 26 13 2 13 0 14 4 34 8 12 19 4 9 29) #28# #1# 17860) si::fset)) #1# 17860) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 1 0 73 29) #29=#A(t (38) (swank::query-and-set-slot class swank::object swank::slot clos::slot-definition-name swank::slot-name "Set slot ~S to (evaluated) : " format swank::read-from-minibuffer-in-emacs swank::value-string "" string= #:g5164 #:g5165 0 :name abort :function si::temp #Y(nil nil nil (27 45 18 10 0 51 2 35 1 0 29) #29# #1# 18067) :report-function stream "Abort setting slot ~S" #Y(nil nil nil (24 45 21 26 13 0 15 22 13 5 19 3 7 29) #29# #1# 18067) si::make-restart si::*restart-clusters* #:g5168 #:g5169 #:g5170 read-from-string eval #:g5171 (setf clos::slot-value-using-class) t #Y(nil nil nil (26 77 14 33 72 2 29) #29# #1# 18067) apply #Y(swank::query-and-set-slot nil nil (24 45 1 24 45 2 24 45 3 26 13 0 19 1 4 45 5 77 15 6 13 0 19 3 7 12 19 1 8 45 9 10 0 39 9 13 0 15 10 19 2 11 76 73 39 94 57 12 60 90 75 45 13 57 14 61 1 67 14 15 15 16 14 17 34 19 12 14 20 34 23 12 19 6 24 6 1 12 11 25 3 48 25 10 7 45 26 10 7 45 27 10 7 45 28 13 6 19 1 29 16 30 45 31 13 0 13 3 13 2 13 1 33 32 18 4 43 1 43 3 36 2 44 1 34 34 12 13 1 19 2 35 36 2 62 73 43 1 63 43 2 29) #29# #1# 18067) si::fset)) #1# 18067) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 44 12 14 13 19 6 45 29) #30=#A(t (46) (swank-backend::emacs-inspect (standard-generic-function) (swank::gf) swank::gf swank::label swank::value swank-backend::label-value-line #Y(swank::lv nil nil (24 45 4 24 45 5 26 13 1 13 0 19 2 6 29) #30# #1# 18606) "Name" clos::generic-function-name "Arguments" clos::generic-function-lambda-list "Documentation" t swank::docstring-ispec "Method class" clos::generic-function-method-class "Method combination" clos::generic-function-method-combination ("Methods: " (:newline)) swank::*gf-method-getter* #:loop-list5187 method #:loop-list-head5188 #:loop-list-tail5189 0 #:g5190 :value swank::method-for-inspect-value swank::inspector-princ " " :action "[remove method]" swank::m remove-method #Y(nil nil nil (26 13 9 13 0 19 2 34 29) #30# #1# 18606) (:newline) copy-list #:g5191 rplacd last ((:newline)) swank::all-slots-for-inspector append #Y(nil nil nil (24 45 3 26 30 1 7 15 8 13 1 19 1 9 12 32 0 18 2 12 15 10 13 1 19 1 11 12 32 0 18 2 12 15 12 13 1 14 13 19 3 14 12 15 15 13 1 19 1 16 12 32 0 18 2 12 15 17 13 1 19 1 18 12 32 0 18 2 12 15 19 58 60 132 77 14 20 13 2 20 1 23 12 46 21 46 22 75 6 1 45 23 10 0 45 24 57 25 61 2 2 91 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 26 14 27 13 4 13 4 19 1 28 5 12 19 1 29 6 3 12 15 30 14 31 15 32 10 4 45 33 34 35 43 1 6 3 12 1 36 6 4 16 37 45 38 13 1 10 0 17 39 10 0 43 1 43 1 39 10 10 1 5 12 19 1 40 51 1 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 15 41 13 1 19 1 42 12 19 9 43 43 1 29) #30# #1# 18606) clos::install-method)) #1# 18606) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 29 12 14 12 19 6 30 29) #31=#A(t (31) (swank-backend::emacs-inspect (standard-method) (method) method clos::method-generic-function "Method defined on the generic function " :value clos::generic-function-name swank::inspector-princ ("Method without a generic function") (:newline) "Documentation" t swank::docstring-ispec "Lambda List: " clos::method-lambda-list (:newline) "Specializers: " clos::method-specializers swank::method-specializers-for-inspect (:newline) "Qualifiers: " method-qualifiers (:newline) "Method function: " clos::method-function (:newline) swank::all-slots-for-inspector append #Y(nil nil nil (24 45 3 26 13 0 19 1 4 39 31 15 5 14 6 13 0 19 1 4 12 13 0 19 1 4 12 19 1 7 12 19 1 8 6 3 6 2 73 38 4 1 9 73 12 15 10 15 11 13 0 14 12 19 3 13 12 15 14 14 6 13 0 19 1 15 6 2 12 15 16 15 17 14 6 13 0 19 1 18 12 13 0 19 1 19 12 19 1 8 6 3 12 15 20 15 21 14 6 13 0 19 1 22 6 2 12 15 23 15 24 14 6 13 0 19 1 25 6 2 12 15 26 13 0 19 1 27 7 13 12 19 2 28 7 2 12 19 2 28 29) #31# #1# 19668) clos::install-method)) #1# 19668) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #32=#A(t (17) (swank::specializer-direct-methods class clos::specializer-direct-methods copy-seq string< :key swank::x clos::method-generic-function clos::generic-function-name swank::name symbolp second symbol-name #Y(nil nil nil (24 45 6 26 13 0 19 1 7 12 19 1 8 45 9 10 0 16 10 39 5 10 0 38 5 10 0 16 11 43 1 16 12 29) #32# #1# 20711) sort #Y(swank::specializer-direct-methods nil nil (24 45 1 26 13 0 19 1 2 16 3 12 33 4 12 14 5 34 13 12 19 4 14 29) #32# #1# 20711) si::fset)) #1# 20711) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 67 12 14 29 19 6 68 29) #33=#A(t (69) (swank-backend::emacs-inspect (standard-class) (class) class "Name: " :value class-name (:newline) "Super classes: " clos::class-direct-superclasses swank::common-seperated-spec (:newline) "Direct Slots: " clos::class-direct-slots swank::slot clos::slot-definition-name swank::inspector-princ #Y(nil nil nil (24 45 14 26 14 5 13 0 13 0 19 1 15 12 19 1 16 6 3 73 29) #33# #1# 21118) (:newline) "Effective Slots: " clos::class-finalized-p clos::class-slots #Y(nil nil nil (24 45 14 26 14 5 13 0 13 0 19 1 15 12 19 1 16 6 3 73 29) #33# #1# 21118) "#<N/A (class not finalized)> " :action "[finalize]" clos::finalize-inheritance #Y(nil nil nil (26 13 0 19 1 26 29) #33# #1# 21118) (:newline) t documentation swank::doc "Documentation:" (:newline) (:newline) "Sub classes: " clos::class-direct-subclasses swank::sub #Y(nil nil nil (24 45 37 26 14 5 13 0 13 0 19 1 6 12 19 1 16 6 3 73 29) #33# #1# 21118) (:newline) "Precedence List: " clos::class-precedence-list #Y(nil nil nil (24 45 3 26 14 5 13 0 13 0 19 1 6 12 19 1 16 6 3 73 29) #33# #1# 21118) ("#<N/A (class not finalized)>") (:newline) clos::specializer-direct-methods "It is used as a direct specializer in the following methods:" (:newline) swank::specializer-direct-methods #:loop-list5201 method #:loop-list-head5202 #:loop-list-tail5203 0 "  " rplacd swank::method-for-inspect-value (:newline) "    Documentation: " swank::abbrev-doc (:newline) "Prototype: " clos::class-prototype "#<N/A (class not finalized)>" (:newline) swank::all-slots-for-inspector append #Y(nil nil nil (24 45 3 26 15 4 14 5 13 0 19 1 6 6 2 12 15 7 15 8 13 0 19 1 9 12 19 1 10 12 15 11 15 12 13 0 19 1 13 12 34 17 12 19 2 10 12 15 18 15 19 13 0 19 1 20 39 15 13 0 19 1 21 12 34 22 12 19 2 10 38 14 15 23 14 24 15 25 34 27 6 3 6 2 73 12 15 28 13 0 14 29 19 2 30 45 31 10 0 73 39 16 15 32 15 33 13 0 19 1 16 12 1 34 6 4 73 12 43 1 15 35 13 0 19 1 36 12 34 38 12 19 2 10 12 15 39 15 40 13 0 19 1 20 39 15 13 0 19 1 41 12 34 42 12 19 2 10 38 4 1 43 73 12 15 44 13 0 19 1 45 73 39 161 15 46 15 47 58 60 151 77 13 1 19 1 48 12 46 49 46 50 75 6 1 45 51 10 0 45 52 57 53 61 2 2 113 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 1 54 6 1 51 1 17 55 13 1 14 5 13 3 13 3 19 1 56 12 19 1 16 6 3 6 1 51 1 17 55 13 1 1 57 6 1 51 1 17 55 13 3 14 29 19 2 30 39 40 13 1 1 58 6 1 51 1 17 55 13 1 13 3 14 29 19 2 30 12 19 1 59 6 1 51 1 17 55 13 1 1 60 6 1 51 1 17 55 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 3 73 12 15 61 13 0 19 1 20 39 13 14 5 13 0 19 1 62 6 2 73 38 4 1 63 73 12 15 64 13 0 19 1 65 7 4 12 19 2 66 7 2 12 19 2 66 7 3 12 19 2 66 7 2 12 19 2 66 7 2 12 19 2 66 7 3 12 19 2 66 7 3 12 19 2 66 7 5 73 29) #33# #1# 21118) clos::install-method)) #1# 21118) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 24 12 14 25 19 6 26 29) #34=#A(t (27) (swank-backend::emacs-inspect (clos::standard-slot-definition) (swank::slot) swank::slot "Name: " :value clos::slot-definition-name (:newline) clos::slot-definition-documentation "Documentation:" (:newline) (:newline) "Init args: " clos::slot-definition-initargs (:newline) "Init form: " clos::slot-definition-initfunction clos::slot-definition-initform "#<unspecified>" (:newline) "Init function: " (:newline) swank::all-slots-for-inspector append #Y(nil nil nil (24 45 3 26 15 4 14 5 13 0 19 1 6 6 2 12 15 7 13 0 19 1 8 73 39 20 15 9 15 10 14 5 13 0 19 1 8 6 2 12 1 11 6 4 73 12 15 12 14 5 13 0 19 1 13 6 2 12 15 14 15 15 13 0 19 1 16 39 13 14 5 13 0 19 1 17 6 2 73 38 4 1 18 73 12 15 19 15 20 14 5 13 0 19 1 16 6 2 12 15 21 13 0 19 1 22 7 10 12 19 2 23 7 4 73 29) #34# #1# 23702) t clos::install-method)) #1# 23702) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 4 77 77 15 6 19 15 7 15 0 19 1 18 78 14 15 8 1 16 12 19 2 17 1 0 73 29) #35=#A(t (19) (swank::%package-symbols-container swank::%container. (swank::title swank::description swank::symbols swank::grouping-kind) ((swank::title nil t nil 0 nil) (swank::description nil t nil 1 nil) (swank::symbols nil t nil 2 nil) (swank::grouping-kind nil t nil 3 nil)) swank::copy-%package-symbols-container (swank::%%make-package-symbols-container) swank::%package-symbols-container-p si::define-structure swank::%%make-package-symbols-container (nil :grouping-kind :symbols :description :title) #:title #:description #:symbols #:grouping-kind 0 si::make-structure #Y(swank::%%make-package-symbols-container nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 2 77 46 13 15 14 13 3 13 2 13 1 13 0 19 5 15 29) #35# #1# 24534) si::fset find-class)) #1# 24534) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #36=#A(t (13) (swank::%make-package-symbols-container (nil :symbols :description :title) swank::title swank::description swank::symbols :title :description :symbols :grouping-kind :symbol swank::%%make-package-symbols-container #Y(swank::%make-package-symbols-container nil nil (28 1 22 40 2 77 46 2 22 40 2 77 46 3 22 40 2 77 46 4 14 5 13 2 14 6 13 1 14 7 13 0 14 8 14 9 19 8 10 29) #36# #1# 25150) si::fset)) #1# 25150) #Y(si::bytecodes nil nil (15 0 14 1 14 2 14 3 15 4 19 5 5 29) #A(t (6) (swank::make-symbols-listing :delete-methods t :lambda-list (swank::grouping-kind swank::symbols) ensure-generic-function)) #1# 25444) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 49 12 14 14 14 50 15 51 19 8 52 29) #37=#A(t (53) (swank::make-symbols-listing ((eql :symbol) t) (swank::grouping-kind swank::symbols) swank::grouping-kind swank::symbols #:loop-list5231 swank::s #:loop-maxmin-flag-5234 #:loop-maxmin-temp-5233 #:loop-maxmin-5232 0 symbol-name length > t swank::distance swank::max-length symbol swank::name - swank::padding string + :initial-element #\  make-string concatenate swank::symbol-classification-string #Y(swank::string-representations nil nil (24 45 17 26 10 0 16 11 45 18 10 0 16 12 45 12 13 3 13 0 19 2 19 45 20 15 21 13 2 13 0 13 5 19 2 22 12 14 23 15 24 19 3 25 12 19 3 26 12 13 3 19 1 27 12 72 2 43 3 29) #37# #1# 25505) "" "Symbols:" "Flags:" (:newline) #\- " " #:foo (:newline) #:loop-list5235 #:loop-list-head5236 #:loop-list-tail5237 #:g5238 swank::classification-string swank::symbol-string :value (:newline) copy-list #:g5239 rplacd last #Y(nil nil nil (24 45 3 24 45 4 26 58 60 88 77 13 1 46 5 46 6 9 0 9 0 77 46 7 46 8 46 9 57 10 61 2 2 52 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 10 4 16 11 16 12 51 2 10 3 76 40 8 13 2 13 1 19 2 13 39 9 11 14 51 3 10 2 51 1 35 0 0 10 1 73 36 6 62 73 43 3 43 2 63 12 9 10 46 15 46 16 30 1 28 15 29 15 30 9 -8 13 1 13 2 19 3 22 12 14 23 15 24 19 3 25 12 15 31 15 32 15 21 13 1 13 2 9 -1 19 3 22 12 14 23 15 33 19 3 25 12 15 34 15 35 19 1 27 12 19 4 26 12 15 36 58 60 115 77 13 4 46 37 46 17 75 6 1 45 38 10 0 45 39 57 10 61 2 2 81 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 40 13 4 32 7 18 1 47 1 41 45 42 14 43 13 6 10 0 6 3 12 13 1 1 44 6 3 43 2 16 45 45 46 13 1 10 0 17 47 10 0 43 1 43 1 39 10 10 1 5 12 19 1 48 51 1 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 8 73 43 1 43 2 29) #37# #1# 25505) :documentation "Returns an object renderable by Emacs' inspector side that
alphabetically lists all the symbols in SYMBOLS together with a
concise string representation of what each symbol
represents (see SYMBOL-CLASSIFICATION-STRING)" clos::install-method)) #1# 25505) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 71 12 14 47 14 72 15 73 19 8 74 29) #38=#A(t (75) (swank::make-symbols-listing ((eql :classification) t) (swank::grouping-kind swank::symbols) swank::grouping-kind swank::symbols :test eq make-hash-table :misc swank::+default-classification+ swank::table swank::classifications :fboundp member :macro :special-operator :function substitute remove #Y(swank::normalize-classifications nil nil (24 45 11 26 10 0 76 39 8 10 2 6 1 73 38 48 14 12 13 0 19 2 13 39 19 14 14 13 0 19 2 13 76 39 9 14 15 13 0 19 2 13 76 39 12 14 16 14 12 13 0 19 3 17 38 8 14 12 13 0 19 2 18 29) #38# #1# 27294) #:loop-list5348 symbol 0 swank::classify-symbol #:loop-list5358 swank::classification #:g5366 #:g5363 #:g5364 gethash #:g5365 si::hash-set #:g5369 #:loop-hashtab-5367 swank::k #:loop-it-5370 si::hash-table-iterator #:loop-hashtab-next-5368 #:loop-list-head5374 #:loop-list-tail5375 #:loop-hash-val-temp-5371 #:loop-hash-key-temp-5372 #:loop-hash-predicate-var-5373 rplacd swank::a swank::b eql t string< #Y(nil nil nil (24 45 44 24 45 45 26 13 1 10 4 17 46 39 5 75 73 38 21 13 0 10 4 17 46 39 6 11 47 73 38 8 13 1 13 0 19 2 48 29) #38# #1# 27294) sort #:loop-list5379 #:loop-list-head5380 #:loop-list-tail5381 #:g5382 symbol-name (:newline) :initial-element #\- make-string (:newline) :value (:newline) #Y(nil nil nil (24 45 21 26 14 61 13 0 10 0 16 55 6 3 12 1 62 6 2 73 29) #38# #1# 27294) nreverse mapcan ((:newline)) append copy-list #:g5383 last #Y(nil nil nil (24 45 3 24 45 4 26 14 5 33 6 12 19 2 7 12 14 8 46 9 46 10 30 1 19 77 13 3 46 20 46 21 57 22 61 2 2 103 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 77 13 1 19 1 23 12 32 3 18 1 12 46 24 46 25 57 22 61 2 2 57 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 4 45 26 10 2 45 27 10 9 45 28 13 2 13 1 13 0 19 2 29 3 45 30 13 2 13 1 13 0 19 3 31 43 4 35 0 0 62 43 2 35 0 0 62 43 2 43 1 58 60 99 77 77 13 1 77 46 32 46 33 46 34 46 35 10 2 16 36 45 37 75 6 1 45 38 10 0 45 39 57 22 61 2 2 51 13 3 20 0 23 47 2 40 47 1 41 45 42 10 0 39 9 10 2 51 10 10 1 51 8 10 0 51 7 43 3 76 39 4 35 0 1 13 1 10 5 6 1 51 1 17 43 35 0 0 10 2 5 73 36 8 62 43 2 43 1 43 4 63 45 11 13 0 34 49 12 19 2 50 45 11 58 60 140 77 13 1 46 51 46 25 75 45 4 75 6 1 45 52 10 0 45 53 57 22 61 2 2 100 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 13 9 19 2 29 51 3 10 1 45 54 10 5 16 55 12 15 56 9 64 14 57 15 58 19 3 59 12 15 60 34 63 12 10 4 16 64 12 19 2 65 12 15 66 19 2 67 7 5 16 68 45 69 13 1 10 0 17 43 10 0 43 1 43 1 39 10 10 1 5 12 19 1 70 51 1 35 0 0 10 2 5 73 36 6 62 73 43 2 43 1 43 2 63 43 2 43 2 29) #38# #1# 27294) :documentation "For each possible classification (cf. CLASSIFY-SYMBOL), group
all the symbols in SYMBOLS to all of their respective
classifications. (If a symbol is, for instance, boundp and a
generic-function, it'll appear both below the BOUNDP group and
the GENERIC-FUNCTION group.) As macros and special-operators are
specified to be FBOUNDP, there is no general FBOUNDP group,
instead there are the three explicit FUNCTION, MACRO and
SPECIAL-OPERATOR groups." clos::install-method)) #1# 27294) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 47 12 14 48 19 6 49 29) #39=#A(t (50) (swank-backend::emacs-inspect (swank::%package-symbols-container) (swank::%container) swank::%container #40=#:oo-5426 #:g5428 #:g5427 (swank::%container.title #40#) #:g5430 #:g5429 (swank::%container.description #40#) #:g5432 #:g5431 (swank::%container.symbols #40#) #:g5434 #:g5433 (swank::%container.grouping-kind #40#) swank::%container.title (:newline) (:newline) swank::%container.description (:newline) "  " swank::%container.grouping-kind #:g5435 :symbol :action "[Group by classification]" #:g5436 :classification #:g5437 swank::%package-symbols-container si::structure-set #Y(nil nil nil (26 10 1 45 28 11 29 45 30 13 1 15 31 9 3 13 0 19 4 32 43 1 43 1 29) #39# #1# 30222) (:refreshp t) "[Group by symbol]" #:g5438 #:g5439 #Y(nil nil nil (26 10 1 45 36 11 25 45 37 13 1 15 31 9 3 13 0 19 4 32 43 1 43 1 29) #39# #1# 30222) (:refreshp t) (:symbol :classification) si::ecase-error (:newline) (:newline) swank::%container.symbols swank::make-symbols-listing append #Y(nil nil nil (24 45 3 26 10 0 45 4 13 0 19 1 17 12 15 18 15 19 13 0 19 1 20 12 15 21 15 22 13 0 19 1 23 45 24 10 0 42 25 15 14 26 15 27 34 33 12 1 34 7 4 73 38 24 42 29 15 14 26 15 35 34 38 12 1 39 7 4 73 38 7 13 0 1 40 17 41 12 43 1 15 42 15 43 13 0 19 1 23 12 13 0 19 1 44 12 19 2 45 7 6 12 19 2 46 7 4 73 43 1 29) #39# #1# 30222) t clos::install-method)) #1# 30222) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #41=#A(t (17) (swank::display-link type swank::symbols length (nil :description :title) swank::title swank::description "0 ~A symbols." format :value :title :description :symbols swank::%make-package-symbols-container "~D ~A symbol~P." #Y(swank::display-link nil nil (24 45 1 24 45 2 24 45 3 28 4 22 40 2 77 46 5 22 40 2 77 46 6 10 3 76 39 11 77 15 7 13 4 19 3 8 38 34 14 9 14 10 13 1 14 11 13 0 14 12 13 3 19 6 13 12 77 15 14 13 2 13 4 13 2 19 5 8 6 3 73 29) #41# #1# 31143) si::fset)) #1# 31143) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 85 12 14 23 19 6 86 29) #42=#A(t (87) (swank-backend::emacs-inspect (package) (package) package package-name package-nicknames package-use-list package-used-by-list package-shadowing-symbols swank::external-symbols-length swank::external-symbols swank::inherited-symbols-length swank::inherited-symbols swank::internal-symbols-length swank::internal-symbols swank::present-symbols-length swank::present-symbols swank::shadowed-symbols :test eq make-hash-table #:seen-ht5518 (:inherited :internal :external) t si::packages-iterator #:g5519 #:g5520 swank::sym gethash si::hash-set 0 swank::symbol-status swank::status :inherited #:g5526 + #:g5529 :internal #:g5532 #:g5535 copy-list string< sort :key "" "Name: " :value (:newline) "Nick names: " swank::common-seperated-spec (:newline) documentation "Documentation:" (:newline) (:newline) "Use list: " #Y(nil nil nil (24 45 3 26 14 46 13 0 10 0 16 4 6 3 73 29) #42# #1# 31550) (:newline) "Used by list: " #Y(nil nil nil (24 45 3 26 14 46 13 0 10 0 16 4 6 3 73 29) #42# #1# 31550) (:newline) "present" :title "All present symbols of package \"~A\"" format :description ("A symbol is considered present in a package if it's" (:newline) "\"accessible in that package directly, rather than" (:newline) "being inherited from another package.\"" (:newline) "(CLHS glossary entry for `present')" (:newline)) swank::display-link (:newline) "external" "All external symbols of package \"~A\"" ("A symbol is considered external of a package if it's" (:newline) "\"part of the `external interface' to the package and" (:newline) "[is] inherited by any other package that uses the" (:newline) "package.\" (CLHS glossary entry of `external')" (:newline)) (:newline) "internal" "All internal symbols of package \"~A\"" ("A symbol is considered internal of a package if it's" (:newline) "present and not external---that is if the package is" (:newline) "the home package of the symbol, or if the symbol has" (:newline) "been explicitly imported into the package." (:newline) (:newline) "Notice that inherited symbols will thus not be listed," (:newline) "which deliberately deviates from the CLHS glossary" (:newline) "entry of `internal' because it's assumed to be more" (:newline) "useful this way." (:newline)) (:newline) "inherited" "All inherited symbols of package \"~A\"" ("A symbol is considered inherited in a package if it" (:newline) "was made accessible via USE-PACKAGE." (:newline)) (:newline) "shadowed" length "All shadowed symbols of package \"~A\"" append #Y(nil nil nil (24 45 3 26 10 0 16 4 12 10 0 16 5 12 10 0 16 6 12 10 0 16 7 12 10 0 16 8 12 77 9 0 77 9 0 77 9 0 77 9 0 46 9 46 10 46 11 46 12 46 13 46 14 46 15 46 16 46 17 46 7 46 6 46 5 46 4 14 18 33 19 12 19 2 20 45 21 58 60 190 13 15 15 22 14 23 19 3 24 45 25 75 45 26 75 45 27 38 165 13 2 20 0 23 51 1 55 0 1 10 1 76 39 5 75 73 36 3 13 0 13 4 19 2 28 76 39 136 13 0 13 4 14 23 19 3 29 57 30 61 1 121 13 1 13 19 19 2 31 45 32 13 0 11 33 17 19 39 26 13 2 10 16 3 51 16 8 1 45 34 13 18 13 0 19 2 35 51 18 43 1 35 1 0 13 2 10 12 3 51 12 8 1 45 36 13 14 13 0 19 2 35 51 14 43 1 13 0 11 37 17 19 39 25 13 2 10 14 3 51 14 8 1 45 38 13 16 13 0 19 2 35 51 16 43 1 38 23 13 2 10 18 3 51 18 8 1 45 39 13 20 13 0 19 2 35 51 20 43 1 43 1 62 75 39 -166 43 3 63 43 1 10 1 16 40 12 33 41 12 19 2 42 51 1 10 2 16 40 12 33 41 12 14 43 33 4 12 19 4 42 51 2 10 3 16 40 12 33 41 12 14 43 33 4 12 19 4 42 51 3 10 4 16 40 12 33 41 12 19 2 42 51 4 13 5 33 41 12 19 2 42 51 5 13 7 33 41 12 19 2 42 51 7 13 11 33 41 12 19 2 42 51 11 13 9 33 41 12 19 2 42 51 9 15 44 15 45 14 46 10 0 6 2 12 15 47 15 48 13 1 19 1 49 12 15 50 13 13 14 23 19 2 51 73 39 18 15 52 15 53 13 13 14 23 19 2 51 12 1 54 6 4 73 12 15 55 13 2 34 56 12 19 2 49 12 15 57 15 58 13 3 34 59 12 19 2 49 12 15 60 15 61 13 5 13 6 14 62 77 15 63 13 0 19 3 64 12 14 65 15 66 19 7 67 12 15 68 15 69 13 11 13 12 14 62 77 15 70 13 0 19 3 64 12 14 65 15 71 19 7 67 12 15 72 15 73 13 7 13 8 14 62 77 15 74 13 0 19 3 64 12 14 65 15 75 19 7 67 12 15 76 15 77 13 9 13 10 14 62 77 15 78 13 0 19 3 64 12 14 65 15 79 19 7 67 12 15 80 15 81 13 4 10 4 16 82 12 14 62 77 15 83 13 0 19 3 64 12 14 65 77 19 7 67 6 10 12 19 2 84 7 3 12 19 2 84 7 2 12 19 2 84 7 2 12 19 2 84 7 6 73 43 13 29) #42# #1# 31550) clos::install-method)) #1# 31550) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 27 12 14 28 19 6 29 29) #43=#A(t (30) (swank-backend::emacs-inspect (pathname) (pathname) pathname wild-pathname-p "A wild pathname." "A pathname." (:newline) "Namestring" namestring swank-backend::label-value-line "Host" pathname-host "Device" pathname-device "Directory" pathname-directory "Name" pathname-name "Type" pathname-type "Version" pathname-version append probe-file "Truename" truename #Y(nil nil nil (24 45 3 26 13 0 19 1 4 39 6 1 5 73 38 4 1 6 73 12 15 7 15 8 10 0 16 9 12 19 2 10 12 15 11 13 0 19 1 12 12 19 2 10 12 15 13 13 0 19 1 14 12 19 2 10 12 15 15 13 0 19 1 16 12 19 2 10 12 15 17 13 0 19 1 18 12 19 2 10 12 15 19 13 0 19 1 20 12 19 2 10 12 15 21 10 0 16 22 12 19 2 10 12 19 7 23 12 13 0 19 1 4 40 6 10 0 16 24 76 76 73 39 11 15 25 10 0 16 26 12 19 2 10 12 19 2 23 7 3 73 29) #43# #1# 37661) t clos::install-method)) #1# 37661) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 27 12 14 28 19 6 29 29) #44=#A(t (30) (swank-backend::emacs-inspect (logical-pathname) (pathname) pathname "Namestring" namestring swank-backend::label-value-line "Physical pathname: " translate-logical-pathname append "Host: " pathname-host " (" :value logical-pathname-translations ("other translations)" (:newline)) "Directory" pathname-directory "Name" pathname-name "Type" pathname-type "Version" pathname-version "Truename" wild-pathname-p probe-file #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 15 7 13 0 19 1 8 12 19 2 6 12 19 2 9 12 15 10 13 0 19 1 11 12 15 12 14 13 13 0 19 1 11 16 14 6 2 12 1 15 7 5 12 15 16 13 0 19 1 17 12 19 2 6 12 15 18 13 0 19 1 19 12 19 2 6 12 15 20 13 0 19 1 21 12 19 2 6 12 15 22 10 0 16 23 12 19 2 6 12 15 24 13 0 19 1 25 76 73 39 5 10 0 16 26 12 19 2 6 12 19 5 9 12 19 3 9 29) #44# #1# 38361) t clos::install-method)) #1# 38361) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 6 12 14 7 19 6 8 29) #45=#A(t (9) (swank-backend::emacs-inspect (number) (swank::n) swank::n "Value: " princ-to-string #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 6 2 73 29) #45# #1# 39188) t clos::install-method)) #1# 39188) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 15 0 15 30 15 31 19 3 32 1 0 73 29) #46=#A(t (33) (swank::format-iso8601-time swank::time-value swank::include-timezone-p swank::zone zerop "Z" abs 1.0 truncate swank::m swank::h "~:[+~;-~]~2,'0D:~2,'0D" > * round format #Y(swank::format-iso8601-timezone nil nil (24 45 3 26 10 0 16 4 39 6 1 5 73 38 46 10 0 16 6 12 15 7 19 2 8 47 1 9 45 10 77 15 11 13 2 9 0 19 2 12 12 13 0 9 60 13 1 19 2 13 12 19 1 14 12 19 5 15 43 2 29) #46# #1# 39267) decode-universal-time swank::dst swank::dow swank::year swank::month swank::day swank::hour swank::minute second "~4,'0D-~2,'0D-~2,'0DT~2,'0D:~2,'0D:~2,'0D~:[~*~;~A~]" + #Y(swank::format-iso8601-time nil nil (24 45 1 25 40 2 77 46 2 26 30 1 16 13 2 19 1 17 47 8 3 47 7 18 47 6 19 47 5 20 47 4 21 47 3 22 47 2 23 47 1 24 45 25 77 15 26 13 5 13 4 13 3 13 2 13 1 13 0 13 10 10 7 39 10 13 8 9 1 19 2 27 38 4 10 8 73 12 32 9 18 1 12 19 10 15 43 9 43 1 29) #46# #1# 39267) si::fset function "Formats a universal time TIME-VALUE in ISO 8601 format, with
    the time zone included if INCLUDE-TIMEZONE-P is non-NIL" si::set-documentation)) #1# 39267) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 31 12 14 28 19 6 32 29) #47=#A(t (33) (swank-backend::emacs-inspect (integer) (swank::i) swank::i "Value: ~D = #x~8,'0X = #o~O = #b~,,' ,8:B~@[ = ~E~]" #:g5562 #:g5563 0 error si::temp #Y(nil nil nil (24 45 9 26 10 0 51 2 35 1 0 29) #47# #1# 40464) si::*handler-clusters* float coerce condition format (:newline) char-code-limit < "Code-char" code-char swank-backend::label-value-line "Integer-length" integer-length #:g5565 #:g5566 #Y(nil nil nil (24 45 9 26 10 0 51 2 35 1 0 29) #47# #1# 40464) "Universal-time" t swank::format-iso8601-time append #Y(nil nil nil (24 45 3 26 77 15 4 13 0 13 0 13 0 13 0 57 5 60 50 75 45 6 57 7 61 1 24 15 8 34 10 3 6 1 12 11 11 3 48 11 13 3 1 12 17 13 36 2 44 1 10 1 45 14 77 13 0 72 2 43 1 36 2 62 73 43 1 63 12 19 7 15 12 1 16 6 2 12 9 -1 13 0 14 17 19 3 18 73 39 11 15 19 10 0 16 20 12 19 2 21 12 15 22 10 0 16 23 12 19 2 21 12 57 24 60 57 75 45 25 57 7 61 1 31 15 8 34 26 3 6 1 12 11 11 3 48 11 15 27 13 3 14 28 19 2 29 12 19 2 21 36 2 44 1 10 1 45 14 77 13 0 72 2 43 1 36 2 62 73 43 1 63 12 19 4 30 29) #47# #1# 40464) clos::install-method)) #1# 40464) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 10 12 14 11 19 6 12 29) #48=#A(t (13) (swank-backend::emacs-inspect (complex) (swank::c) swank::c "Real part" realpart swank-backend::label-value-line "Imaginary part" imagpart append #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 15 7 10 0 16 8 12 19 2 6 12 19 2 9 29) #48# #1# 40975) t clos::install-method)) #1# 40975) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 12 12 14 13 19 6 14 29) #49=#A(t (15) (swank-backend::emacs-inspect (ratio) (swank::r) swank::r "Numerator" numerator swank-backend::label-value-line "Denominator" denominator "As float" float append #Y(nil nil nil (24 45 3 26 15 4 10 0 16 5 12 19 2 6 12 15 7 10 0 16 8 12 19 2 6 12 15 9 13 0 19 1 10 12 19 2 6 12 19 3 11 29) #49# #1# 41132) t clos::install-method)) #1# 41132) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 33 12 14 34 19 6 35 29) #50=#A(t (36) (swank-backend::emacs-inspect (float) (swank::f) swank::f most-positive-long-float > "Positive infinity." most-negative-long-float < "Negative infinity." = "Not a Number." decode-float swank::sign swank::exponent swank::significand "Scientific: " "~E" format (:newline) "Decoded: " :value " * " " * " float-radix "^" (:newline) "Digits" float-digits swank-backend::label-value-line "Precision" float-precision append #Y(nil nil nil (24 45 3 26 13 0 14 4 19 2 5 39 8 1 6 6 1 73 38 129 13 0 14 7 19 2 8 39 8 1 9 6 1 73 38 113 13 0 13 0 19 2 10 76 39 8 1 11 6 1 73 38 96 10 0 16 12 47 2 13 47 1 14 45 15 15 16 77 15 17 13 3 19 3 18 12 15 19 15 20 14 21 10 2 6 2 12 15 22 14 21 10 0 6 2 12 15 23 14 21 10 3 16 24 6 2 12 15 25 14 21 10 1 6 2 12 1 26 6 12 12 15 27 10 3 16 28 12 19 2 29 12 15 30 10 3 16 31 12 19 2 29 12 19 3 32 43 3 29) #50# #1# 41323) t clos::install-method)) #1# 41323) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #51=#A(t (17) (swank::make-pathname-ispec pathname position "Pathname: " :value (:newline) "  " :action "[visit file and show current position]" :position (:bytep t) swank::ed-in-emacs #Y(nil nil nil (26 13 1 14 9 13 0 1 10 7 4 12 19 1 11 29) #51# #1# 42235) (:refreshp nil) (:newline) #Y(swank::make-pathname-ispec nil nil (24 45 1 24 45 2 26 15 3 14 4 10 1 6 2 12 15 5 15 6 10 0 39 17 14 7 15 8 34 12 12 1 13 7 4 12 1 14 6 2 7 5 73 29) #51# #1# 42235) si::fset)) #1# 42235) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #52=#A(t (16) (swank::make-file-stream-ispec stream #:g5571 #:g5572 0 error si::temp #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #52# #1# 42604) si::*handler-clusters* pathname condition open-stream-p file-position swank::make-pathname-ispec #Y(swank::make-file-stream-ispec nil nil (24 45 1 26 57 2 60 47 75 45 3 57 4 61 1 22 15 5 34 7 3 6 1 12 11 8 3 48 8 10 3 16 9 36 2 44 1 10 1 45 10 77 13 0 72 2 43 1 36 2 62 43 1 63 45 9 10 0 73 39 19 13 0 10 1 16 11 73 39 6 13 1 19 1 12 12 19 2 13 43 1 29) #52# #1# 42604) si::fset)) #1# 42604) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 8 12 14 9 19 6 10 29) #53=#A(t (11) (swank-backend::emacs-inspect (file-stream) (stream) stream call-next-method swank::content swank::make-file-stream-ispec append #Y(nil nil nil (24 45 3 26 19 0 4 45 5 13 1 19 1 6 12 13 0 19 2 7 43 1 29) #53# #1# 42945) t clos::install-method)) #1# 42945) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 12 12 14 13 19 6 14 29) #54=#A(t (15) (swank-backend::emacs-inspect (stream-error) (condition) condition call-next-method swank::content stream-error-stream stream file-stream typep swank::make-file-stream-ispec append #Y(nil nil nil (24 45 3 26 19 0 4 45 5 13 1 19 1 6 45 7 13 0 15 8 19 2 9 73 39 6 13 0 19 1 10 12 13 1 19 2 11 43 1 43 1 29) #54# #1# 43112) t clos::install-method)) #1# 43112) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #55=#A(t (16) (swank::common-seperated-spec list swank::v :value #Y(nil nil nil (24 45 2 26 14 3 10 0 6 2 73 29) #55# #1# 43406) swank::callback #:loop-list5577 swank::i #:loop-list-head5578 #:loop-list-tail5579 0 rplacd ", " butlast #Y(swank::common-seperated-spec nil nil (24 45 1 25 40 4 34 4 12 46 5 26 58 60 82 77 13 2 46 6 46 7 75 6 1 45 8 10 0 45 9 57 10 61 2 2 47 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 6 13 3 20 1 23 6 1 51 1 17 11 13 1 1 12 6 1 51 1 17 11 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 19 1 13 29) #55# #1# 43406) si::fset)) #1# 43406) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 0 15 9 15 10 19 3 11 1 0 73 29) #56=#A(t (12) (swank::inspector-princ list copy-pprint-dispatch *print-pprint-dispatch* (cons (member function)) set-pprint-dispatch princ-to-string #Y(swank::inspector-princ nil nil (24 45 1 26 19 0 2 48 3 15 4 77 19 2 5 10 0 16 6 44 1 29) #56# #1# 43652) si::fset function "Like princ-to-string, but don't rewrite (function foo) as #'foo.
Do NOT pass circular lists to this function." si::set-documentation)) #1# 43652) #Y(si::bytecodes nil nil (11 0 16 1 29) #A(t (2) (:swank-fancy-inspector provide)) #1# 43947))
